<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XWOS – 技术参考手册</title>
    <link>/docs/TechRefManual/</link>
    <description>Recent content in 技术参考手册 on XWOS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="/docs/TechRefManual/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 软件架构</title>
      <link>/docs/TechRefManual/Architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Architecture/</guid>
      <description>
        
        
        &lt;p&gt;XWOS在设计时就充分考虑了代码的复用性、移植性以及与第三方软件的兼容性，
代码被架构成多层结构：构建系统、BSP、操作系统内核、中间件和应用。&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 913px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Architecture/xwos-arch_hud68e8e8565694c7eb1f134c79006dda4_264347_903x688_fill_catmullrom_smart1_3.png&#34; width=&#34;903&#34; height=&#34;688&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS架构图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h2 id=&#34;构建系统&#34;&gt;构建系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbs&lt;/code&gt; : 构建系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bsp&#34;&gt;BSP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd&lt;/code&gt; : 编译器、CPU、SOC、外设驱动相关的代码
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd/ds&lt;/code&gt; : 玄武设备栈，XWOS的驱动框架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/perpheral&lt;/code&gt; : 基于玄武设备栈，实现的各种外设驱动，代码可被不同SOC共享&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/soc&lt;/code&gt; : 不同SOC的XWOS移植实现层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbd&lt;/code&gt; : 不同电路板的工程配置、调试脚本、链接脚本、驱动与应用。电路板目录还可以放在其他位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统内核&#34;&gt;操作系统内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos&lt;/code&gt; : 内核
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos/osal&lt;/code&gt; : 操作系统抽象层，统一的内核API，不区分操作系统的具体实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/ospl&lt;/code&gt; : 操作系统移植层，其中定义了内核提供给BSP的回调函数以及BSP需要提供给内核的函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/lib&lt;/code&gt; : 基本C函数库，包括原子操作库、位操作库、数据结构等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mm&lt;/code&gt; : 内存管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mp&lt;/code&gt; : 多核(mp)内核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/up&lt;/code&gt; : 单核(up)内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中间件&#34;&gt;中间件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd&lt;/code&gt; : 中间件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc&lt;/code&gt; : 系统间的通讯机制
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwcq&lt;/code&gt; : 线程间的循环队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwmq&lt;/code&gt; : 线程间的消息队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwssc&lt;/code&gt; : SOC与SOC间的点对点通讯协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/libc&lt;/code&gt; : 标准C库的适配代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/xwrust&lt;/code&gt; : XWOS RUST框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem&lt;/code&gt; : 第三方开源软件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/fs&lt;/code&gt; : 各种开源的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing&lt;/code&gt; : 序列化与反序列化
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing/nanopb&lt;/code&gt; : protocol-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/vm&lt;/code&gt; : 虚拟机
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/vm/lua&lt;/code&gt; : Lua语言虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwam&lt;/code&gt; : 参考代码以及应用代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwxr&lt;/code&gt; : API文档生成配置&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: XWOS标准</title>
      <link>/docs/TechRefManual/XwosStd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/XwosStd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;
&lt;p&gt;XWOS的所有可以确定位宽的数据类型被称为 &lt;a href=&#34;../../../capi/group__xwos__lib__type.html&#34;&gt;基本数据类型&lt;/a&gt; ，定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwu8_t&lt;/code&gt; 8位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws8_t&lt;/code&gt; 8位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu16_t&lt;/code&gt; 16位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws16_t&lt;/code&gt; 16位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu32_t&lt;/code&gt; 32位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws32_t&lt;/code&gt; 32位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu64_t&lt;/code&gt; 64位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws64_t&lt;/code&gt; 64位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsz_t&lt;/code&gt; 大小值（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssz_t&lt;/code&gt; 大小值（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwstk_t&lt;/code&gt; 栈帧（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwptr_t&lt;/code&gt; 指针的整数值（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwreg_t&lt;/code&gt; 寄存器（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsreg_t&lt;/code&gt; 寄存器（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwer_t&lt;/code&gt; 错误码（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsq_t&lt;/code&gt; 序列值/位置/偏移（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssq_t&lt;/code&gt; 序列值/位置/偏移（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsid_t&lt;/code&gt; ID（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwid_t&lt;/code&gt; ID（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* xwisr_f)(void)&lt;/code&gt; 中断向量（函数指针）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwirq_t&lt;/code&gt; 中断号（有符号），负的中断号表示系统异常，正的中断号表示外部中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwpr_t&lt;/code&gt; 优先级（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmp_t&lt;/code&gt; 位图（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwtm_t&lt;/code&gt; 时间（64位有符号整数，单位：纳秒）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlfq_t&lt;/code&gt; 无锁队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* ctor_f)(void * /*obj*/)&lt;/code&gt; 构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* dtor_f)(void * /*obj*/)&lt;/code&gt; 析构函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef xws64_t (* xwsc_f)(void * /*arg*/, ...)&lt;/code&gt; 系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据类型命名习惯&#34;&gt;数据类型命名习惯&lt;/h2&gt;
&lt;p&gt;用户在阅读XWOS源码时，要注意以下几个命名习惯的隐含意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于比较小的数据结构，XWOS会通过 &lt;code&gt;typedef&lt;/code&gt; 定义成一种类型。这种类型就像基本数据类型一样，
在函数间传递参数时是直接传递，不会使用 &lt;code&gt;type *&lt;/code&gt; 去传递指针，除非是返回数据。
&lt;ul&gt;
&lt;li&gt;命名通常是 &lt;code&gt;type_t&lt;/code&gt; 的形式，函数指针则为 &lt;code&gt;type_f&lt;/code&gt; 的形式，&lt;a href=&#34;../Xwobj##%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;对象描述符&lt;/a&gt; 则为 &lt;code&gt;xwobj_d&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于比较大的结构体，XWOS使用关键字 &lt;code&gt;struct&lt;/code&gt; 定义。XWOS代码中不会省略关键字 &lt;code&gt;struct&lt;/code&gt; 。
目的是提醒读者这是一个结构体，将它作为参数传递时是通过传递指针来引用数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原子类型&#34;&gt;原子类型&lt;/h2&gt;
&lt;p&gt;所有基本数据类型增加前缀 &lt;code&gt;atomic_&lt;/code&gt; 表示此类型的原子类型。例如： &lt;code&gt;_Atomic xwsq_t&lt;/code&gt; 等价于 &lt;code&gt;__xwcc_atomic xwsq_t&lt;/code&gt; 等价于 &lt;code&gt;atomic_xwsq_t&lt;/code&gt;。
原子类型的变量可以使用XWOS的 &lt;a href=&#34;../Xwlib/xwaop&#34;&gt;原子操作库&lt;/a&gt; 来操作，也可以使用标准C头文件 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 中定义的函数来操作。&lt;/p&gt;
&lt;h2 id=&#34;系统位数&#34;&gt;系统位数&lt;/h2&gt;
&lt;p&gt;XWOS内核支持32位与64位两种CPU。&lt;/p&gt;
&lt;h2 id=&#34;时间&#34;&gt;时间&lt;/h2&gt;
&lt;p&gt;XWOS内核使用64位有符号整数 &lt;code&gt;xwtm_t&lt;/code&gt; 表示时间，单位为纳秒。并提供一系列操作函数。&lt;/p&gt;
&lt;p&gt;详细参考头文件 &lt;a href=&#34;../../../capi/group__xwos__time.html&#34;&gt;&lt;strong&gt;xwos/osal/time.h&lt;/strong&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../Xwobj&#34;&gt;&lt;code&gt;xwos_object&lt;/code&gt;&lt;/a&gt; 是XWOS所有对象的父类。&lt;/p&gt;
&lt;h2 id=&#34;对象描述符&#34;&gt;对象描述符&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../Xwobj##%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;对象描述符&lt;/a&gt; 是XWOS为了解决对象野指针问题而引入的机制。&lt;/p&gt;
&lt;h2 id=&#34;调度器&#34;&gt;调度器&lt;/h2&gt;
&lt;p&gt;XWOS会为每个CPU创建独立的 &lt;a href=&#34;../Skd&#34;&gt;调度器&lt;/a&gt;，每个&lt;a href=&#34;../Skd&#34;&gt;调度器&lt;/a&gt; 独立调度线程，且都有一个私有的滴答定时器。&lt;/p&gt;
&lt;h2 id=&#34;滴答定时器&#34;&gt;滴答定时器&lt;/h2&gt;
&lt;p&gt;为调度器产生固定频率中断的硬件定时器。&lt;/p&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;p&gt;调度器内的基本调度单位为 &lt;a href=&#34;../Thd&#34;&gt;线程&lt;/a&gt; ，因此线程是与调度器绑定的。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器&#34;&gt;软件定时器&lt;/h2&gt;
&lt;p&gt;基于调度器的滴答定时器实现的 &lt;a href=&#34;../Swt&#34;&gt;软件定时器&lt;/a&gt; 也是与调度器绑定的。&lt;/p&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;p&gt;XWOS的锁机制有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Mutex&#34;&gt;互斥锁&lt;/a&gt; ：防止两个 &lt;strong&gt;线程&lt;/strong&gt; 竞争内存数据的锁。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Spinlock&#34;&gt;自选锁&lt;/a&gt; ：可防止任意上下文竞争内存数据的锁。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Seqlock&#34;&gt;顺序锁&lt;/a&gt; ：自选锁的改良锁，可分为读锁和写锁，读锁可共享，写锁独占。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步机制&#34;&gt;同步机制&lt;/h2&gt;
&lt;p&gt;XWOS的 &lt;strong&gt;基本同步机制&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Sem&#34;&gt;信号量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Cond&#34;&gt;条件量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Flg&#34;&gt;事件标志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Br&#34;&gt;线程栅栏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Sel&#34;&gt;信号选择器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通讯机制&#34;&gt;通讯机制&lt;/h2&gt;
&lt;p&gt;基于 &lt;strong&gt;基本同步机制&lt;/strong&gt; ，XWOS的中间件XWMD提供了线程间的通讯机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Isc/Xwmq&#34;&gt;消息队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Isc/Xwcq&#34;&gt;循环队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;p&gt;XWOS的内核提供了多种动态 &lt;a href=&#34;../Mm&#34;&gt;内存管理&lt;/a&gt; 的方法。&lt;/p&gt;
&lt;h2 id=&#34;电源管理&#34;&gt;电源管理&lt;/h2&gt;
&lt;p&gt;XWOS的内核为 &lt;a href=&#34;../Pm&#34;&gt;电源管理&lt;/a&gt; ，提供了一套基本的流程。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 代码风格</title>
      <link>/docs/TechRefManual/CodeStyle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/CodeStyle/</guid>
      <description>
        
        
        &lt;h2 id=&#34;c语言&#34;&gt;C语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;风格：KR&lt;/li&gt;
&lt;li&gt;缩进：8空格（不使用TAB）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c语言-1&#34;&gt;C++语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;风格：Google&lt;/li&gt;
&lt;li&gt;缩进：2空格（不使用TAB）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;makefile&#34;&gt;Makefile&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;shell&#34;&gt;Shell&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;emacslisp&#34;&gt;EmacsLisp&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;rust语言&#34;&gt;Rust语言&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;lua语言&#34;&gt;Lua语言&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 配置</title>
      <link>/docs/TechRefManual/Cfg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Cfg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;XWOS所有配置文件都集中于 &lt;code&gt;电路板名称/cfg&lt;/code&gt; 文件夹中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cfg/project.h&lt;/code&gt; ：工程配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/arch.h&lt;/code&gt; ：ARCH配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/cpu.h&lt;/code&gt; ：CPU配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/soc.h&lt;/code&gt; ：SOC配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/board.h&lt;/code&gt; ：电路板配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwos.h&lt;/code&gt; ：内核配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwmd.h&lt;/code&gt; ：中间件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwcd.h&lt;/code&gt; ：芯片与外设配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwem.h&lt;/code&gt; ：第三方组件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwam.h&lt;/code&gt; ：应用配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/oem.h&lt;/code&gt; ：OEM模块配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/autogen.h&lt;/code&gt; ：自动生成的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置说明&#34;&gt;配置说明&lt;/h2&gt;
&lt;p&gt;XWOS在设计之初曾考虑过使用现成的配置生成工具，例如Linux内核的Kconfig工具。
但为了降低跨平台开发的工作量和难度，最终选择使用C语言的头文件来描述所有配置。&lt;/p&gt;
&lt;h3 id=&#34;projecth-工程配置文件&#34;&gt;&lt;strong&gt;project.h&lt;/strong&gt; ：工程配置文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARCH&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_ARCH&lt;/code&gt; ：架构，可在 &lt;code&gt;xwcd/soc/&lt;/code&gt; 中选择 &lt;strong&gt;架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_SUBARCH&lt;/code&gt; ：子架构，可在 &lt;strong&gt;架构文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;子架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_COMPILER&lt;/code&gt; ：编译器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; ：选择gcc作为编译器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llvm&lt;/code&gt; / &lt;code&gt;clang&lt;/code&gt; ：选择clang作为编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_LIBC&lt;/code&gt; ：标准C库，目前支持
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newlib&lt;/code&gt; ：选择newlib作为C库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;picolibc&lt;/code&gt; ：选择picolibc作为C库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; ：不链接到C库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_LDSCRIPT&lt;/code&gt; ：链接脚本的的相对路径，相对于 &lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_CPU&lt;/code&gt; ：CPU子集，可在 &lt;strong&gt;架构文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;CPU文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOC&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_SOC&lt;/code&gt; ：片上系统，可在 &lt;strong&gt;CPU文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;SOC文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电路板&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_BOARD&lt;/code&gt; ：电路板，可在 &lt;code&gt;xwbd/&lt;/code&gt; 中选择 &lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核配置&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_CORE&lt;/code&gt; ：单核与多核的选择，可选择编译 &lt;code&gt;xwos/&lt;/code&gt; 下的哪种内核
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mp&lt;/code&gt; ：多核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt; ：单核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWCD&lt;/code&gt; ：是否需要引用芯片、驱动库，路径 &lt;code&gt;xwcd/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWMD&lt;/code&gt; ：是否需要引用中间件库，路径 &lt;code&gt;xwmd/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWEM&lt;/code&gt; ：是否需要引用第三方组件库，路径 &lt;code&gt;xwem/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWAM&lt;/code&gt; ：是否需要引用应用组件库，路径 &lt;code&gt;xwam/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_OEMPATH&lt;/code&gt; ：OEM模块的搜索路径
&lt;ul&gt;
&lt;li&gt;可以是相对路径，相对于 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以为绝对路径&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;archh-arch配置&#34;&gt;&lt;strong&gt;arch.h&lt;/strong&gt; ：ARCH配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据大小端选择，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LITTLE_ENDIAN&lt;/code&gt; ：小端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_BIG_ENDIAN&lt;/code&gt; ：大端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构位宽，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_32BIT&lt;/code&gt; ：32位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_64BIT&lt;/code&gt; ：64位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点单元
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_FPU&lt;/code&gt; ：是否包含浮点单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C标准库
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_COMPILER_ERRNO&lt;/code&gt; ：是否使用libc的 &lt;code&gt;errno.h&lt;/code&gt; 中定义的错误码，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位操作与原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位操作函数&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位图操作函数&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWAOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的原子操作函数集&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPAOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位图原子操作函数集&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpuh-cpu配置&#34;&gt;&lt;strong&gt;cpu.h&lt;/strong&gt; ：CPU配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_CPU_NUM&lt;/code&gt; ：CPU数量，仅仅对SMP的系统有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_L1_CACHELINE_SIZE&lt;/code&gt; ：L1缓存的CacheLine大小，仅对有1级缓冲的SOC有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;soch-soc配置&#34;&gt;&lt;strong&gt;soc.h&lt;/strong&gt; ：SOC配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ARM-M
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_PRIO_BITNUM&lt;/code&gt; ：ARM-M中断优先级寄存器的位数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_SUBPRIO_BITIDX&lt;/code&gt; ：ARM-M子中断优先级从第几位开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供 &lt;strong&gt;CRC32&lt;/strong&gt; 计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供 &lt;strong&gt;CRC8&lt;/strong&gt; 计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nuclei RISC-V bumblebee (rv32imac)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EPPC (e200z0)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为9&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_SYSHWT_SRCCLK&lt;/code&gt; ：滴答定时器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_SYSHWT_CHANNEL&lt;/code&gt; ：滴答定时器的通道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC&lt;/code&gt; ：是有启用外部快速晶振&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC_VALUE&lt;/code&gt; ：外部快速晶振的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC_DIV&lt;/code&gt; ：外部快速晶振的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC&lt;/code&gt; ：是否启用内部的快速RC振荡器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC_VALUE&lt;/code&gt; ：内部快速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC_DIV&lt;/code&gt; ：内部快速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC&lt;/code&gt; ：是否启用外部慢速晶振&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC_VALUE&lt;/code&gt; ：外部慢速晶振的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC_DIV&lt;/code&gt; ：外部慢速晶振的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SIRC_VALUE&lt;/code&gt; ：内部慢速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SIRC_DIV&lt;/code&gt; ：内部慢速RC振荡器的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FMPLL_VALUE&lt;/code&gt; ：锁相环的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BKUP&lt;/code&gt; ：是否启用备用RAM区域，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;boardh-电路板配置&#34;&gt;&lt;strong&gt;board.h&lt;/strong&gt; ：电路板配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XWOS HOOK
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt; ：是否使用空闲任务HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_idle_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_PRE_SWCX_HOOK&lt;/code&gt; ：是否使用任务切换前HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_pre_swcx_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_POST_SWCX_HOOK&lt;/code&gt; ：是否使用任务切换后HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_post_swcx_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt; ：是否使用系统滴答定时器中断HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_syshwt_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_STACK_POOL&lt;/code&gt; ：是否提供了线程栈的内存池，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;xwer_t board_thd_stack_pool_alloc(xwsz_t , xwstk_t **)&lt;/code&gt; 与 &lt;code&gt;xwer_t board_thd_stack_pool_free(xwstk_t *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_POSTINIT_HOOK&lt;/code&gt; ：是否使用线程初始化后HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_thd_postinit_hook(struct xwospl_thd *)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_LOG&lt;/code&gt; ：是否支持日志打印，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 。取值为 &lt;code&gt;1&lt;/code&gt; 时需要提供 &lt;code&gt;board_log_write()&lt;/code&gt; 的定义，用于log字符串的输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_DCACHE&lt;/code&gt; ：是否支持DCACHE，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_ICACHE&lt;/code&gt; ：是否支持ICACHE，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二进制标记
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_FIRMWARE_TAILFLAG&lt;/code&gt; ：定义编译后的bin文件尾的标记字符串，可用于升级功能检查文件是否完整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路板模块的配置： &lt;code&gt;BMCFG_&amp;lt;module&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;电路板模块的路径需要按照 &lt;a href=&#34;./BuildSystem#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;&lt;strong&gt;构建系统&lt;/strong&gt;&lt;/a&gt; 的规则转换为配置宏，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwosh-内核配置&#34;&gt;&lt;strong&gt;xwos.h&lt;/strong&gt; ：内核配置&lt;/h3&gt;
&lt;p&gt;操作系统相关的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_BUG&lt;/code&gt; ：是否启用BUG调试，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;玄武C库：
&lt;ul&gt;
&lt;li&gt;日志
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; ：是否启用Log调试，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; ：最低日志等级；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_BUFSIZE&lt;/code&gt; ：日志格式化缓冲区大小；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_SC&lt;/code&gt; ：是否启用系统调用，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP8&lt;/code&gt; ：是否启用8位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP16&lt;/code&gt; ：是否启用16位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP32&lt;/code&gt; ：是否启用32位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP64&lt;/code&gt; ：是否启用64位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWBMPAOP&lt;/code&gt; ：是否启用位图原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据结构
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_MAP&lt;/code&gt; ：是否启用键值对，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRC
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32&lt;/code&gt; ：是否启用CRC32，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0X04C11DB7&lt;/code&gt; ：是否启用CRC32多项式0x04C11DB7，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0XEDB88320&lt;/code&gt; ：是否启用CRC32多项式0xEDB88320，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8&lt;/code&gt; ：是否启用CRC8，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X07&lt;/code&gt; ：是否启用CRC8多项式0x07，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X31&lt;/code&gt; ：是否启用CRC8多项式0x31，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X9B&lt;/code&gt; ：是否启用CRC8多项式0x9B，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;长跳转
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_SETJMP&lt;/code&gt; ：是否启用 &lt;code&gt;setjmp()/longjmp()&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存管理
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_ALIGNMENT&lt;/code&gt; ：内存管理对齐的字节数，通常设置为8字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_ALIGNMENT&lt;/code&gt; ：线程栈对齐的字节数，通常设置为8字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_SIZE_DEFAULT&lt;/code&gt; ：栈内存的默认大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_SIZE_MIN&lt;/code&gt; ：栈内存大小的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_GUARD_SIZE_DEFAULT&lt;/code&gt; ：栈的默认警戒线位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_CHK_SWCX&lt;/code&gt; ：是否在切换上下文时检查栈溢出，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;栈的类型，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FD_STACK&lt;/code&gt; ：满递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_ED_STACK&lt;/code&gt; ：空递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FA_STACK&lt;/code&gt; ：满递增栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_EA_STACK&lt;/code&gt; ：满递增栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMSLICE&lt;/code&gt; ：是否启用内存切片算法，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_BMA&lt;/code&gt; ：是否启用伙伴算法，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMPOOL&lt;/code&gt; ：是否启用内存池，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核配置
&lt;ul&gt;
&lt;li&gt;调度器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYSHWT_PERIOD&lt;/code&gt; ：硬件定时器周期，单位纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_PRIORITY_RT_NUM&lt;/code&gt; ：调度器实时优先级数量，数量越小越省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_IDLE_STACK_SIZE&lt;/code&gt; ：空闲任务栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_IDLE_TLS&lt;/code&gt; ：是否启用空闲任务的TLS(线程本地私有变量)，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH&lt;/code&gt; ：是否启用中断底半部，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH_STACK_SIZE&lt;/code&gt; ：中断底半部栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH_TLS&lt;/code&gt; ：是否启用中断底半部任务的TLS(线程本地私有变量)，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_PM&lt;/code&gt; ：是否启用电源管理，此配置只对单核系统有效，多核系统不可关闭电源管理。取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_PRIVILEGED_DEFAULT&lt;/code&gt; ：线程是否默认为特权线程，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_MEMPOOL&lt;/code&gt; ：是否启用mempool线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_MEMSLICE&lt;/code&gt; ：是否启用memslice线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_SMA&lt;/code&gt; ：是否启用sma线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_STDC_MM&lt;/code&gt; ：是否启用C标准库中的 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建线程对象，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_LOCAL_DATA_NUM&lt;/code&gt; ：线程私有数据的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_EXIT&lt;/code&gt; ：是否启用线程退出，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT&lt;/code&gt; ：是否启用软件定时器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_MEMPOOL&lt;/code&gt; ：是否启用mempool软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_MEMSLICE&lt;/code&gt; ：是否启用memslice软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_SMA&lt;/code&gt; ：是否启用sma软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建定时器对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_PLSEM&lt;/code&gt; ：是否启用管道信号量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_RTSEM&lt;/code&gt; ：是否启用实时信号量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_MEMPOOL&lt;/code&gt; ：是否启用mempool信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_MEMSLICE&lt;/code&gt; ：是否启用memslice信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_SMA&lt;/code&gt; ：是否启用sma信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建信号量对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND&lt;/code&gt; ：是否启用条件量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_MEMPOOL&lt;/code&gt; ：是否启用mempool条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_MEMSLICE&lt;/code&gt; ：是否启用memslice条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_SMA&lt;/code&gt; ：是否启用memslice条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建条件量对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT&lt;/code&gt; ：是否启用事件，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_MEMPOOL&lt;/code&gt; ：是否启用mempool事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_MEMSLICE&lt;/code&gt; ：是否启用memslice事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_SMA&lt;/code&gt; ：是否启用sma事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建事件对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX&lt;/code&gt; ：是否启用互斥锁，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_MEMPOOL&lt;/code&gt; ：是否启用mempool互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_MEMSLICE&lt;/code&gt; ：是否启用memslice互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_SMA&lt;/code&gt; ：是否启用sma互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建互斥锁对象，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_FAKEMTX&lt;/code&gt; ：是否启用虚假互斥锁，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwmdh-中间件配置&#34;&gt;&lt;strong&gt;xwmd.h&lt;/strong&gt; ：中间件配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc&lt;/code&gt; ：是否启用点对点通讯协议，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_LOG&lt;/code&gt; ：是否开启日志，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_PORT_NUM&lt;/code&gt; ：消息通道的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_PRI_NUM&lt;/code&gt; ：消息优先级的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RETRY_PERIOD&lt;/code&gt; ：重发消息的周期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RETRY_NUM&lt;/code&gt; ：重发消息的最大次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_MEMBLK_SIZE&lt;/code&gt; ：用于发送与接收的单位内存块的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_MEMBLK_ODR&lt;/code&gt; ：单位内存块的数量，以2的n次方形式表示，此处配置的是指数n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RXTHD_PRIORITY&lt;/code&gt; ：接收线程的优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_TXTHD_PRIORITY&lt;/code&gt; ：发送线程的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq&lt;/code&gt; ：是否启用消息队列，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwcq&lt;/code&gt; ：是否启用循环队列，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc&lt;/code&gt; ：是否启用libc的适配代码，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_xwrust_ffi&lt;/code&gt; ：是否启用XWOS RUST的底层C语言接口，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwcdh芯片与外设配置&#34;&gt;xwcd.h：芯片与外设配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds&lt;/code&gt; ：是否启用玄武设备栈，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LITE&lt;/code&gt; ：是否启用LITE版的玄武设备栈，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_PM&lt;/code&gt; ：是否启用电源管理，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC&lt;/code&gt; ：是否启用SOC，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_CLK&lt;/code&gt; ：是否启用SOC的Clock，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_PWR&lt;/code&gt; ：是否启用SOC的Power，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_GPIO&lt;/code&gt; ：是否启用SOC的GPIO，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_EIRQ&lt;/code&gt; ：是否启用SOC的外部IO中断，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_EIRQ_ROISRT&lt;/code&gt; ：SOC外部IO中断向量表是否为 &lt;code&gt;const&lt;/code&gt; 的，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_DMA&lt;/code&gt; ：是否启用SOC的DMA，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_DMA_ROCBT&lt;/code&gt; ：SOC外部DMA回调函数表是否为 &lt;code&gt;const&lt;/code&gt; 的，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_UART&lt;/code&gt; ：是否启用UART，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_UART_RXQ_SIZE&lt;/code&gt; ：UART接收队列的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_I2C_MASTER&lt;/code&gt; ：是否启用I2C总线控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_I2C_PERIPHERAL&lt;/code&gt; ：是否启用I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SPI_MASTER&lt;/code&gt; ：是否启用SPI总线控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SPI_PERIPHERAL&lt;/code&gt; ：是否启用SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LIN&lt;/code&gt; ：是否启用LIN总线，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LINID&lt;/code&gt; ：是否启用LIN总线的ID校验表，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN&lt;/code&gt; ：是否启用CAN总线，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER&lt;/code&gt; ：是否启用CAN控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_ROCBT&lt;/code&gt; ：CAN控制器的回调函数表是否为只读，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_SDU_MAXSIZE&lt;/code&gt; ：CAN消息数据的最大数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_RXQNUM&lt;/code&gt; ：CAN接收队列的最大数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_I2CP&lt;/code&gt; ：CAN控制器是否为I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_SPIP&lt;/code&gt; ：CAN控制器是否为SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER&lt;/code&gt; ：是否启用CAN接收器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER_I2CP&lt;/code&gt; ：CAN接收器是否为I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER_SPIP&lt;/code&gt; ：CAN接收器是否为SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_MISC&lt;/code&gt; ：是否启用MISC设备，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_i2c_eeprom&lt;/code&gt; ：是否启用I2C EEPROM的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_spi_flash_w25qxx&lt;/code&gt; ：是否启用SPI FLASH W25Q的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_spi_lcd_st7735&lt;/code&gt; ：是否启用SPI LCD ST7735的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_can_transceiver_tja1042&lt;/code&gt; ：是否启用CAN收发器TJA1042的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwemh第三方软件配置&#34;&gt;xwem.h：第三方软件配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_serializing_nanopb&lt;/code&gt; ：是否启用protobuf-nanopb，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_fatfs&lt;/code&gt; ：是否启用FatFs，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_littlefs&lt;/code&gt; ：是否启用littlefs，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_spiffs&lt;/code&gt; ：是否启用spiffs，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_dhara&lt;/code&gt; ：是否启用dhara，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua&lt;/code&gt; ：是否启用Lua语言，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_INT_TYPE&lt;/code&gt; ：Lua语言中整数类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_FLOAT_TYPE&lt;/code&gt; ：Lua语言中浮点类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_THD_STACK_SIZE&lt;/code&gt; ：Lua交互式解释器线程的栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_BRDLIBS&lt;/code&gt; ：是否启用BSP中Lua库，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwamh应用配置&#34;&gt;xwam.h：应用配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_xwobj&lt;/code&gt; ：是否启用示例 &lt;strong&gt;玄武对象&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_new&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的创建&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_exit&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的退出&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_sleep&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的睡眠&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_swt&lt;/code&gt; ：是否启用示例 &lt;strong&gt;软件定时器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_cpuirq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;CPU中断&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_mtx&lt;/code&gt; ：是否启用示例 &lt;strong&gt;互斥锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_spinlock&lt;/code&gt; ：是否启用示例 &lt;strong&gt;自旋锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_seqlock&lt;/code&gt; ：是否启用示例 &lt;strong&gt;顺序锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_sem&lt;/code&gt; ：是否启用示例 &lt;strong&gt;信号量&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_cond&lt;/code&gt; ：是否启用示例 &lt;strong&gt;条件量&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_br&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程栅栏&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_flg&lt;/code&gt; ：是否启用示例 &lt;strong&gt;事件标志&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_sel&lt;/code&gt; ：是否启用示例 &lt;strong&gt;信号选择器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_sma&lt;/code&gt; ：是否启用示例 &lt;strong&gt;简单内存分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_memslice&lt;/code&gt; ：是否启用示例 &lt;strong&gt;内存切片分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_bma&lt;/code&gt; ：是否启用示例 &lt;strong&gt;伙伴算法分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_xwlib_crc&lt;/code&gt; ：是否启用示例 &lt;strong&gt;CRC计算&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_cxx&lt;/code&gt; ：是否启用示例 &lt;strong&gt;C++&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_isc_xwmq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;消息队列&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_isc_xwcq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;循环队列&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_application_w25qrpt&lt;/code&gt; ：是否启用应用 &lt;strong&gt;W25Q读写工具&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_application_ramcode&lt;/code&gt; ：是否启用应用 &lt;strong&gt;RAMCODE&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 构建系统</title>
      <link>/docs/TechRefManual/BuildSystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/BuildSystem/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;俗话说：工欲善其事，必先利其器。
一切美好的想法都需要合适的开发环境来实践。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS构建系统基于 &lt;code&gt;make&lt;/code&gt; 编写，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持纯命令行方式编译，可用于持续集成环境中；&lt;/li&gt;
&lt;li&gt;可跨平台使用，支持linux、Windows、MACOS；&lt;/li&gt;
&lt;li&gt;支持基于Eclipse的IDE；&lt;/li&gt;
&lt;li&gt;为了方便集成第三方软件，XWOS参考了Android的构建系统的 &lt;code&gt;Android.mk&lt;/code&gt; 设计出 &lt;code&gt;xwmo.mk&lt;/code&gt; ，
称为 &lt;strong&gt;玄武模块&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建流程&#34;&gt;构建流程&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TD
    make(&amp;#34;make&amp;#34;) --&amp;gt; cfg
    cfg[&amp;#34;生成配置&amp;#34;] --&amp;gt; arch
    arch[&amp;#34;编译arch.a&amp;#34;] --&amp;gt; cpu
    cpu[&amp;#34;编译cpu.a&amp;#34;] --&amp;gt; soc
    soc[&amp;#34;编译soc.a&amp;#34;] --&amp;gt; brd
    brd[&amp;#34;编译brd.a&amp;#34;] --&amp;gt; xwos
    xwos[&amp;#34;编译XWOS内核&amp;#34;] --&amp;gt; xwmd
    xwmd[&amp;#34;编译中间件模块&amp;#34;] --&amp;gt; xwcd
    xwcd[&amp;#34;编译设备模块&amp;#34;] --&amp;gt; bm
    bm[&amp;#34;编译电路板模块&amp;#34;] --&amp;gt; xwem
    xwem[&amp;#34;编译第三方软件模块&amp;#34;] --&amp;gt; xwam
    xwam[&amp;#34;编译应用模块&amp;#34;] --&amp;gt; oem
    oem[&amp;#34;编译OEM模块&amp;#34;] --&amp;gt; elf
    elf[&amp;#34;链接ELF文件&amp;#34;] --&amp;gt; bin
    bin[&amp;#34;生成bin文件&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;开始&#34;&gt;开始&lt;/h3&gt;
&lt;p&gt;XWOS的构建是从 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 下执行命令 &lt;code&gt;make&lt;/code&gt; 开始的，以 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; 代表此目录。
执行 &lt;code&gt;make&lt;/code&gt; 时，可传递参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WKSPC=output-dir&lt;/code&gt; ：配置输出文件的路径，可为相对于 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 的路径，也可为绝对路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS=topdir&lt;/code&gt; ：配置XWOS的根路径，可为相对于 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 的路径，也可为绝对路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成配置&#34;&gt;生成配置&lt;/h3&gt;
&lt;p&gt;构建系统调用脚本 &lt;code&gt;XWOS/xwbs/util/el/mkcfg.el&lt;/code&gt; 处理 &lt;code&gt;$(XWOS_BRD_DIR)/cfg&lt;/code&gt; 下的所有配置文件，
将它们转化成三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/XWOS.cfg&lt;/code&gt; ， &lt;code&gt;makefile&lt;/code&gt; 环境变量，之后被 &lt;code&gt;makefile&lt;/code&gt; 引入。
&lt;ul&gt;
&lt;li&gt;其中包含一些关键的路径信息，不同的SOC通过这些路径找到各自的编译配置：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_PATH)&lt;/code&gt; ： XWOS源码的根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_ARCH_DIR)&lt;/code&gt; ：架构相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_CPU_DIR)&lt;/code&gt; ：CPU相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_SOC_DIR)&lt;/code&gt; ：SOC相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; ：电路板相关的源码路径，此路经也是最开始执行&lt;code&gt;make&lt;/code&gt;的地方；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BM_DIR)&lt;/code&gt; ：电路板相关的玄武模块路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; ：OEM相关的玄武模块路径，通常为私有代码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; ： &lt;code&gt;$(XWOS_WKSPC_DIR)/obj&lt;/code&gt; ，编译输出的目录；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BRD_DIR)/cfg/autogen.h&lt;/code&gt; ，自动生成的头文件，被顶级头文件 &lt;code&gt;xwos/standard.h&lt;/code&gt; 包含&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/XWOS.cfg.rs&lt;/code&gt; ：Rust语言的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/env.rc&lt;/code&gt; ， &lt;strong&gt;shell&lt;/strong&gt; 环境变量脚本，可通过 &lt;code&gt;source&lt;/code&gt; 命令引入这个文件，使得 &lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt; 生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译-archa&#34;&gt;编译 &lt;code&gt;arch.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_ARCH_DIR)/arch.mk&lt;/code&gt; 编译架构描述层(Arch Description Layer)的源码。
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_ARCH_DIR)/arch.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-cpua&#34;&gt;编译 &lt;code&gt;cpu.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_CPU_DIR)/arch.mk&lt;/code&gt; 编译CPU描述层(CPU Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_CPU_DIR)/cpu.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-soca&#34;&gt;编译 &lt;code&gt;soc.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_SOC_DIR)/soc.mk&lt;/code&gt; 编译SOC描述层(SOC Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_SOC_DIR)/soc.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-brda&#34;&gt;编译 &lt;code&gt;brd.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_BRD_DIR)/brd.mk&lt;/code&gt; 编译电路板描述层(Board Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_BRD_DIR)/brd.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译xwos内核&#34;&gt;编译XWOS内核&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;xwos/xwos.mk&lt;/code&gt; 编译XWOS内核的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_XWOS_DIR)/xwos.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译中间件模块&#34;&gt;编译中间件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwmd/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWMDCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译设备模块&#34;&gt;编译设备模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwcd/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWCDCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译电路板模块&#34;&gt;编译电路板模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;$(XWOS_BM_DIR)&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/board.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;BMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译第三方软件模块&#34;&gt;编译第三方软件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwem/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWEMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译应用模块&#34;&gt;编译应用模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwam/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWAMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译oem模块&#34;&gt;编译OEM模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OEM文件夹路径由位于配置文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/XWOS.h&lt;/code&gt; 中的
配置 &lt;code&gt;XWCFG_OEMPATH&lt;/code&gt; 指定：
&lt;ul&gt;
&lt;li&gt;可以是相对于 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; 的相对路径；&lt;/li&gt;
&lt;li&gt;可以是绝对路径；&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外。&lt;/li&gt;
&lt;li&gt;配置工具 &lt;code&gt;xwbs/util/el/mkcfg.el&lt;/code&gt; 会根据此配置生成变量 &lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)/oem&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/oem.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;OEMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链接elf文件&#34;&gt;链接ELF文件&lt;/h3&gt;
&lt;p&gt;构建系统最终会将以上生成的所有 &lt;code&gt;.a&lt;/code&gt; 静态库链接成 &lt;code&gt;XWOS.elf&lt;/code&gt; 文件，
连接脚本由位于配置文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/XWOS.h&lt;/code&gt; 中的 &lt;code&gt;XWCFG_LDSCRIPT&lt;/code&gt; 指定。&lt;/p&gt;
&lt;h3 id=&#34;生成bin文件&#34;&gt;生成bin文件&lt;/h3&gt;
&lt;p&gt;构建系统会将 &lt;strong&gt;XWOS.elf&lt;/strong&gt; 文件转换成 &lt;strong&gt;.bin&lt;/strong&gt; 文件以及 &lt;strong&gt;.hex&lt;/strong&gt; 文件。&lt;/p&gt;
&lt;h2 id=&#34;构建选项&#34;&gt;构建选项&lt;/h2&gt;
&lt;h4 id=&#34;v&#34;&gt;&lt;code&gt;V&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用：输出完整的编译过程。&lt;/li&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项&lt;/li&gt;
&lt;li&gt;0: 关闭选项（默认值）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#b8860b&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;d&#34;&gt;&lt;code&gt;D&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用：优化编译，输出体积较小的二进制，但不利于调试。&lt;/li&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项（默认值）&lt;/li&gt;
&lt;li&gt;0: 关闭选项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#b8860b&#34;&gt;D&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;玄武模块&#34;&gt;玄武模块&lt;/h2&gt;
&lt;p&gt;XWOS的设备模块、中间件模块、第三方软件模块、电路板模块、以及OEM模块，
都是使用 &lt;code&gt;xwmo.mk&lt;/code&gt; 来描述编译规则的，将它们统一称为 &lt;strong&gt;玄武模块(XWMO)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个 &lt;strong&gt;玄武模块&lt;/strong&gt; ，其原理类似于Android系统中的 &lt;code&gt;Android.mk&lt;/code&gt; 。
构建系统会另启一个进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中源代码列表、附加编译选项、头文件路径等对每个编译玄武模块的子进程都是独立的。&lt;/p&gt;
&lt;p&gt;示例， &lt;code&gt;xwam/example/cxx&lt;/code&gt; 的&lt;code&gt; xwmo.mk&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含环境变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; mif.c                                     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; task.cxx                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; test/vector.cxx                         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; test/literal.cxx test/exception.cxx &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加仅对gcc生效的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; -Wno-unused-value                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; -fexceptions                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加仅对gcc生效的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的头文件搜索路径，其中使用函数getXwmoDir获得当前xwmo的路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.mk&lt;/span&gt;                                    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模块路径命名规则&#34;&gt;模块路径命名规则&lt;/h3&gt;
&lt;p&gt;由于模块路径需要对应于C语言中的一个宏定义作为编译开关，
因此模块路径需要符合C语言标识符的规则，但可以包含几个特殊符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径各级目录命名要符合C语言命名规则；&lt;/li&gt;
&lt;li&gt;路径中每级目录以 &lt;code&gt;/&lt;/code&gt; 隔开；&lt;/li&gt;
&lt;li&gt;路径中可包含 &lt;code&gt;.&lt;/code&gt; ，但不能出现 &lt;code&gt;../&lt;/code&gt; 和 &lt;code&gt;./&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中可包含 &lt;code&gt;-&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模块编译开关的命名规则&#34;&gt;模块编译开关的命名规则&lt;/h3&gt;
&lt;p&gt;模块必须要有一个与路径对应的宏开关，并被配置为 &lt;code&gt;1&lt;/code&gt; ，才能被编译：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块路径只需要转换相对路径部分：
&lt;ul&gt;
&lt;li&gt;中间件模块：取 &lt;code&gt;xwmd/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;设备驱动模块：取 &lt;code&gt;xwcd/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;电路板模块：取 &lt;code&gt;$(XWOS_BRD_DIR)/bm/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;第三方软件模块：取 &lt;code&gt;xwem/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;应用模块：取 &lt;code&gt;xwam/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;OEM模块：取 &lt;code&gt;OEM文件夹/&lt;/code&gt; （不含）之后的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;_&lt;/code&gt; ，需要两个 &lt;code&gt;_&lt;/code&gt; 来表示；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;/&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;.&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;-&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;增加前缀：
&lt;ul&gt;
&lt;li&gt;中间件模块： &lt;code&gt;XWMDCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设备模块： &lt;code&gt;XWCDCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;电路板模块： &lt;code&gt;BMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三方软件模块： &lt;code&gt;XWEMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用模块： &lt;code&gt;XWAMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OEM模块： &lt;code&gt;OEMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例：
&lt;ul&gt;
&lt;li&gt;中间件模块： &lt;code&gt;xwmd/isc/xwpcp&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWMDCFG_isc_xwpcp&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;设备驱动模块： &lt;code&gt;xwcd/perpheral/ds/i2c/eeprom&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWCDCFG_perpheral_ds_i2c_eeprom&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;电路板模块： &lt;code&gt;xwbd/WeActMiniStm32H750/bm/stm32_cube&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;BMCFG_stm32__cube&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;第三方软件模块： &lt;code&gt;xwem/vm/l__u_a-5.4.6&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWEMCFG_vm_l____u__a_5_4_6&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;应用模块： &lt;code&gt;xwam/example/cxx&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWAMCFG_example_cxx&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;OEM模块： &lt;code&gt;oem/app&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;OEMCFG_app&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以借助 &lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt; 中的 &lt;code&gt;xwmc&lt;/code&gt; 命令生成编译开关的宏标识符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;增加模块&#34;&gt;增加模块&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中间件模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwmd/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设备驱动模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwcd/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;电路板模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;$(XWOS_BRD_DIR)/bm/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/board.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;第三方软件模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwem/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;应用模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwam/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;OEM模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于OEM文件夹内；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/oem.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwmomk-语法说明&#34;&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 语法说明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 是 &lt;code&gt;makefile&lt;/code&gt; 的一部分，其中语法简化为定义几个特殊的变量即可完成编译。&lt;/p&gt;
&lt;h4 id=&#34;cc&#34;&gt;C/C++&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到gcc头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到llvm头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_LUASRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 转换为C语言数组的Lua脚本源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.mk&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;rust模块&#34;&gt;RUST模块&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.rust.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;预编译模块&#34;&gt;预编译模块&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_PREBUILT&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 预先编译好的.a文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.prebuilt.mk&lt;/span&gt;                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;xwmomk-中可用的函数&#34;&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 中可用的函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getXwmoDir&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;$(call getXwmoDir)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：获取当前 &lt;strong&gt;玄武模块&lt;/strong&gt; 的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getXwmoName&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;$(call getXwmoName)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：获取当前 &lt;strong&gt;玄武模块&lt;/strong&gt; 的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoWildcard&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoWildcard,WILDCARD,DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：在目录 &lt;code&gt;DIR&lt;/code&gt; 中搜索符合通配符 &lt;code&gt;WILDCARD&lt;/code&gt; 的文件，并输出文件列表。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;XWMO_CSRCS += $(call XwmoWildcard,*.c,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：在 &lt;code&gt;picolibc&lt;/code&gt; 搜索所有的 &lt;code&gt;*.c&lt;/code&gt; 文件，并将返回的文件列表赋值给 &lt;code&gt;XWMO_CSRCS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoWildcardRecursively&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoWildcardRecursively,WILDCARD,DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：在目录 &lt;code&gt;DIR&lt;/code&gt; 以及其子目录中搜索符合通配符 &lt;code&gt;WILDCARD&lt;/code&gt; 的文件，并输出文件列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoReqCfg&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoReqCfg,CFG,VALUE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：测试配置 &lt;code&gt;CFG&lt;/code&gt; 是否为 &lt;code&gt;VALUE&lt;/code&gt; ，如果不是就报错。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;$(call XwmoReqCfg,XWCFG_LIBC,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：如果配置 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 不为 &lt;code&gt;picolibc&lt;/code&gt; 就报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoReqNotCfg&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoReqNotCfg,CFG,VALUE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：测试配置 &lt;code&gt;CFG&lt;/code&gt; 是否为 &lt;code&gt;VALUE&lt;/code&gt; ，如果是就报错。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;$(call XwmoReqCfg,XWCFG_LIBC,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：如果配置 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 为 &lt;code&gt;picolibc&lt;/code&gt; 就报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;辅助功能&#34;&gt;辅助功能&lt;/h2&gt;
&lt;p&gt;XWOS的编译系统类似于Android，也定义了一些与编译相关的辅助命令。&lt;/p&gt;
&lt;h3 id=&#34;初始化环境&#34;&gt;初始化环境&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;source&lt;/span&gt; xwbd/WeActMiniStm32H750/env.sh &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 以电路板WeActMiniStm32H750为例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmc&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块编译开关的C语言宏标识符。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; XWEMCFG_vm_lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmn&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块的 &lt;strong&gt;.a&lt;/strong&gt; 文件名。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; xwem_vm_lua.a &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：编译整个XWOS工程，类似Android的 &lt;code&gt;m&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;用法： &lt;code&gt;xwm [选项] [目标]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;目标：make的目标&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 编译整个工程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm c &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 清理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm d &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 侧底清理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的 &lt;code&gt;mm&lt;/code&gt; 命令，使用当前路径作为模块的路径。&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的 &lt;code&gt;mmm&lt;/code&gt; 命令，需要指定模块的路径。&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmmm xwem/vm/lua
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcroot&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到XWOS的根目录，类似Android的 &lt;code&gt;croot&lt;/code&gt; 命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcbd&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到电路板描述层目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 启动流程</title>
      <link>/docs/TechRefManual/BootFlow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/BootFlow/</guid>
      <description>
        
        
        &lt;h2 id=&#34;xwos的启动流程&#34;&gt;XWOS的启动流程&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart LR
    预初始化阶段 --&amp;gt; 初始化阶段 --&amp;gt; 后初始化阶段 --&amp;gt; 主函数阶段

    subgraph 预初始化阶段
        direction TB
        exc[&amp;#34;异常初始化&amp;#34;]
        exc[&amp;#34;浮点单元初始化&amp;#34;]
        exc[&amp;#34;内存初始化&amp;#34;]
    end

    subgraph 初始化阶段
        xwos_init[&amp;#34;xwos_init()&amp;#34;]
    end

    subgraph 后初始化阶段
        direction LR
        device[&amp;#34;设备驱动初始化&amp;#34;]
        mm[&amp;#34;动态内存分配器的初始化&amp;#34;]
    end

    subgraph 主函数阶段
        direction LR
        skd_init[&amp;#34;初始化调度器: xwos_skd_init_lc()&amp;#34;]
        thd[&amp;#34;建立线程&amp;#34;]
        skd_start[&amp;#34;启动调度器: xwos_skd_start_lc()&amp;#34;]
    end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XWOS将初始化流程分为四个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预初始化阶段（用户定义）：&lt;code&gt;xwos_preinit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化阶段（XWOS定义）：&lt;code&gt;xwos_init()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后初始化阶段（用户定义）：&lt;code&gt;xwos_postinit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主函数阶段（用户定义）：&lt;code&gt;xwos_main()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;预初始化阶段&#34;&gt;预初始化阶段&lt;/h3&gt;
&lt;p&gt;预初始化阶段，用户需要提供函数的定义： &lt;code&gt;void xwos_preinit(void)&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要完成CPU架构低级初始化，例如：中断的初始化，浮点运算单元的初始化等；&lt;/li&gt;
&lt;li&gt;需要完成对内存的初始化，以及数据区的重定向工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化阶段&#34;&gt;初始化阶段&lt;/h3&gt;
&lt;p&gt;初始化阶段的函数 &lt;code&gt;void xwos_init(void)&lt;/code&gt; 由XWOS定义，对XWOS内核进行初始化。用户不可重新定义此函数。
&lt;code&gt;xwos_init()&lt;/code&gt; 会访问全局变量，因此必须保证在 &lt;strong&gt;预初始化阶段&lt;/strong&gt; 完成对内存的初始化以及数据区的重定向工作。
在多核系统中， &lt;code&gt;xwos_init()&lt;/code&gt; 在每个CPU的初始化流程中都会被调用一次。&lt;/p&gt;
&lt;h3 id=&#34;后初始化阶段&#34;&gt;后初始化阶段&lt;/h3&gt;
&lt;p&gt;后初始化阶段，用户需要提供函数的定义： &lt;code&gt;void xwos_postinit(void)&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可选择在此阶段完成驱动的初始化；&lt;/li&gt;
&lt;li&gt;用户可选择在此阶段完成动态内存分配器的初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主函数阶段&#34;&gt;主函数阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户可选择在此阶段完成驱动的初始化；&lt;/li&gt;
&lt;li&gt;用户可选择在此阶段完成动态内存分配器的初始化；&lt;/li&gt;
&lt;li&gt;用户需要在此阶段建立线程；&lt;/li&gt;
&lt;li&gt;用户需要在此阶段调用 &lt;code&gt;xwos_skd_start_lc()&lt;/code&gt; 启动调度器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户自定义的启动流程&#34;&gt;用户自定义的启动流程&lt;/h2&gt;
&lt;p&gt;如果用户使用自定义的启动流程，需要在调用XWOS任何API之前调用 &lt;code&gt;xwos_init()&lt;/code&gt; 。
此函数会访问全局变量，需要在数据区重定向工作完成之后才可被调用。&lt;/p&gt;
&lt;p&gt;在多核系统中， &lt;code&gt;xwos_init()&lt;/code&gt; 需要在每个CPU的初始化流程中被调用一次。&lt;/p&gt;
&lt;h3 id=&#34;自定义的启动流程举例&#34;&gt;自定义的启动流程举例&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: XWOS对象</title>
      <link>/docs/TechRefManual/Xwobj/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwobj/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的内核对象全部继承于 &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_object {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; magic;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;atomic_xwsq_t&lt;/span&gt; refcnt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        xwobj_gc_f gcfunc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tik&lt;/code&gt; ：对象的标签，是由系统分配的独一无二的整数。此标签即为对象的 &lt;strong&gt;身份证ID&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magic&lt;/code&gt; ：常数 &lt;code&gt;0x58574F53U&lt;/code&gt; ，用于确定内存地址是否为 &lt;strong&gt;XWOS的对象&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refcnt&lt;/code&gt; ：XWOS的对象使用引用计数法管理生命周期，当对象的引用计数减为 &lt;code&gt;0&lt;/code&gt; ，会调用 &lt;code&gt;gcfunc()&lt;/code&gt; 进行垃圾回收；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcfunc&lt;/code&gt; ：垃圾回收函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照面向对象的思想， &lt;code&gt;struct xwos_object&lt;/code&gt; 应当作为子类对象结构体的第一个成员。 &lt;code&gt;struct xwos_object *&lt;/code&gt; 就可强制类型转换为子类对象的指针。&lt;/p&gt;
&lt;h2 id=&#34;对象描述符&#34;&gt;对象描述符&lt;/h2&gt;
&lt;p&gt;当使用对象指针访问对象时，有可能会出现一种情况：
对象已经被释放，甚至被释放后的内存又被用来构建新的对象。但是对象指针的持有者并不知道这种情况。由此引发各种指针问题。
为了解决这类问题，XWOS引入 &lt;strong&gt;对象描述符&lt;/strong&gt; 。&lt;strong&gt;对象描述符&lt;/strong&gt; 由 &lt;strong&gt;对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_object &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; obj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwobj_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;p&gt;相应的，当 &lt;code&gt;struct xwos_object&lt;/code&gt; 被子类继承后，子类也应该有对应的 &lt;strong&gt;对象描述符&lt;/strong&gt; 。
例如，线程对象的 &lt;strong&gt;线程对象描述符&lt;/strong&gt; 、互斥锁对象的 &lt;strong&gt;互斥锁对象描述符&lt;/strong&gt; 等。&lt;/p&gt;
&lt;h2 id=&#34;对象的生命周期&#34;&gt;对象的生命周期&lt;/h2&gt;
&lt;p&gt;XWOS的对象使用引用计数法管理生命周期，XWOS对象的生命周期分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造阶段&lt;/strong&gt; ：对象通过 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga908c48f09f38f5be9d69758fe30c5d3f&#34;&gt;&lt;code&gt;xwos_object_construct()&lt;/code&gt;&lt;/a&gt; 构造后进入 &lt;strong&gt;构造阶段&lt;/strong&gt; ，
此时对象的引用计数为 &lt;strong&gt;0&lt;/strong&gt; 。如果存在派生与继承，需要按照从 &lt;strong&gt;基类到子类&lt;/strong&gt; 的顺序依次调用构造函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用阶段&lt;/strong&gt; ：处于构造阶段的对象，通过 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga82ce393acdabdb355bf091c21f784444&#34;&gt;&lt;code&gt;xwos_object_activate()&lt;/code&gt;&lt;/a&gt; 激活后进入 &lt;strong&gt;应用阶段&lt;/strong&gt; 。
如果存在派生与继承，需要按照从 &lt;strong&gt;基类到子类&lt;/strong&gt; 的顺序依次调用激活函数。
此阶段对象的引用计数 &lt;strong&gt;&amp;gt;= 1&lt;/strong&gt; ，对象可以开始被使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放阶段&lt;/strong&gt; ：当对象引用计数从 &lt;strong&gt;&amp;gt;= 1&lt;/strong&gt; 减少为 &lt;strong&gt;0&lt;/strong&gt; ，对象进入 &lt;strong&gt;释放阶段&lt;/strong&gt; ，此阶段会调用对象的 &lt;code&gt;gcfunc()&lt;/code&gt; 释放对象。
用户需要提供 &lt;code&gt;gcfunc()&lt;/code&gt; 的定义， &lt;code&gt;gcfunc()&lt;/code&gt; 内还需要调用对象的析构函数 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gaaaa2a74387092ee01a9e495a2994d1fa&#34;&gt;&lt;code&gt;xwos_object_destruct()&lt;/code&gt;&lt;/a&gt;
如果存在派生与继承，需要按照从 &lt;strong&gt;子类到基类&lt;/strong&gt; 的顺序依次调用析构函数。
至此对象生命周期结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象的生命周期管理&#34;&gt;对象的生命周期管理&lt;/h3&gt;
&lt;p&gt;XWOS提供两组对象的生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga78e0a4c3320e9e2348d4443294147458&#34;&gt;&lt;code&gt;xwos_object_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gad75451193241a605aef8b9fc6f934dcb&#34;&gt;&lt;code&gt;xwos_object_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga33f685c358784c30a9f1fb8a5ca11d3d&#34;&gt;&lt;code&gt;xwos_object_rawput()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，引用计数为 &lt;strong&gt;0&lt;/strong&gt; 时不调用垃圾回收函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gac510a6eb1b6a08450ec6d65fe3bf7694&#34;&gt;&lt;code&gt;xwos_object_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gac2826d86066a8dfdcc77fe7a8c53edfc&#34;&gt;&lt;code&gt;xwos_object_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;局限性&#34;&gt;局限性&lt;/h2&gt;
&lt;p&gt;频繁地管理对象的生命周期会影响CPU的运行效率，因为引用计数的操作是原子操作，原子操作会影响CPU的性能，
CPU性能越强，影响越巨大。因此，除了必要的情况，XWOS内核各种对象的CAPI被设计为直接使用 &lt;strong&gt;对象的指针&lt;/strong&gt; 作为参数，并且不会自动管理对象的生命周期。
对象的有效性，身份的合法性，生命周期需要由用户手动管理。&lt;/p&gt;
&lt;p&gt;通常，在简单的MCU RTOS应用，这些对象都是只创建不释放的，也没有必要关心生命周期。
事实上，对象的生命周期的CAPI主要是给高级语言设计的，例如 &lt;strong&gt;Lua&lt;/strong&gt; 虚拟机用来实现对象生命周期的自动管理。&lt;/p&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/object.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 中断管理</title>
      <link>/docs/TechRefManual/Irq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Irq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;异常与中断&#34;&gt;异常与中断&lt;/h2&gt;
&lt;p&gt;XWOS将中断分为EXC和IRQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EXC是指架构中定义的中断，在某些架构中被称为 &lt;strong&gt;异常(Exception)&lt;/strong&gt; ，中断号用负数表示；&lt;/li&gt;
&lt;li&gt;IRQ是指外设中断，例如UART的中断等，中断号用 &lt;strong&gt;0&lt;/strong&gt; 和 &lt;strong&gt;正数&lt;/strong&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内核中断&#34;&gt;内核中断&lt;/h2&gt;
&lt;p&gt;XWOS内核的中断包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切换上下文的中断：用于切换线程；&lt;/li&gt;
&lt;li&gt;滴答定时器的中断：用于提供周期性定时中断；&lt;/li&gt;
&lt;li&gt;调度器服务中断：用于启动调度、退出线程、冻结线程、电源管理等其他操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中断优先级&#34;&gt;中断优先级&lt;/h2&gt;
&lt;p&gt;XWOS对中断优先级的要求：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;切换上下文的中断为系统中最低优先级中断
切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;cpu中断开关&#34;&gt;CPU中断开关&lt;/h2&gt;
&lt;p&gt;CPU只能操作自身的中断开关，不可操作其他CPU的中断。下面的函数运行在哪个CPU，就对哪个CPU起作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga4e777c174af9414602e004935f9ce44c&#34;&gt;&lt;code&gt;xwos_cpuirq_enable_lc()&lt;/code&gt;&lt;/a&gt; ：开启CPU的中断开关&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gaa4e10b3911a94474d3caf07e2002c9f3&#34;&gt;&lt;code&gt;xwos_cpuirq_disable_lc()&lt;/code&gt;&lt;/a&gt; ：关闭CPU的中断开关&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga6786862246388dace5c878fa112fac4d&#34;&gt;&lt;code&gt;xwos_cpuirq_save_lc()&lt;/code&gt;&lt;/a&gt; ：保存当前CPU的中断开关状态后关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gab348bfecc115e0d9bb7fc54646f26ebd&#34;&gt;&lt;code&gt;xwos_cpuirq_restore_lc()&lt;/code&gt;&lt;/a&gt; ：恢复之前保存的CPU的中断开关状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要在操作系统移植实现层(XWOSIMPL)中给出上述函数的具体实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_enable_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_enable_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_disable_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_disable_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_save_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_save_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_restore_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_restore_lc()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用局限&#34;&gt;使用局限&lt;/h3&gt;
&lt;p&gt;关闭与开启CPU总中断开关需要确保不会发生嵌套，例如下面的嵌套代码是 &lt;strong&gt;错误&lt;/strong&gt; 的，因为 &lt;strong&gt;临界区1&lt;/strong&gt; 结束时会意外地将CPU中断打开，
从而无法保证 &lt;strong&gt;临界区0&lt;/strong&gt; 的安全性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_disable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区1 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_enable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_disable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 错误！！！发生嵌套 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 此处CPU中断被意外打开 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_enable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当关闭中断的代码发生嵌套时，需要保存与恢复CPU总中断开关，上面的例子可以更正为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwreg_t&lt;/span&gt; cpuirq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_save_lc&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区1 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_restore_lc&lt;/span&gt;(cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwreg_t&lt;/span&gt; cpuirq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_save_lc&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_restore_lc&lt;/span&gt;(cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;外设中断&#34;&gt;外设中断&lt;/h2&gt;
&lt;h3 id=&#34;获取当前代码的中断号&#34;&gt;获取当前代码的中断号&lt;/h3&gt;
&lt;p&gt;XWOS提供CAPI &lt;a href=&#34;../../../capi/group__xwos__irq.html#ga5b3edca9786bee32463bb95c2bcb27ee&#34;&gt;&lt;code&gt;xwos_irq_get_id()&lt;/code&gt;&lt;/a&gt; 可以获取当前中断的中断号。
如果不在中断内使用此CAPI，将返回错误码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-ENOTISRCTX&lt;/code&gt; ：当前上下文不为中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，此CAPI还可用于判断是否为 &lt;strong&gt;中断上下文&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_get_id()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_get_id()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外设中断的其他capi&#34;&gt;外设中断的其他CAPI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gac8e3525698cdb1785a323248d4dca617&#34;&gt;&lt;code&gt;xwos_irq_enable()&lt;/code&gt;&lt;/a&gt; ：开启某个外设中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga09330a9bee1901dbd57994b4fc48a822&#34;&gt;&lt;code&gt;xwos_irq_disable()&lt;/code&gt;&lt;/a&gt; ：关闭某个外设中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga882084561afe57f26871d6881b4a999e&#34;&gt;&lt;code&gt;xwos_irq_save()&lt;/code&gt;&lt;/a&gt; ：保存某个外设中断的开关，然后将其关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga8e390ff7129fb539b2d784e1d19ec3b9&#34;&gt;&lt;code&gt;xwos_irq_restore()&lt;/code&gt;&lt;/a&gt; ：恢复某个外设中断的开关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_enable()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_enable()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_disable()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_disable()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_save()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_save()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_restore()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_restore()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/irq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 调度器</title>
      <link>/docs/TechRefManual/Skd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Skd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS调度器最基本的调度单位是 &lt;strong&gt;线程&lt;/strong&gt; ，暂时不支持 &lt;strong&gt;MMU虚拟内存&lt;/strong&gt; 与 &lt;strong&gt;进程&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;线程&lt;/strong&gt; 都有自己独立的 &lt;strong&gt;栈&lt;/strong&gt; 内存，但所有内存对所有线程都可见，除非使用MPU增加限制；&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;线程&lt;/strong&gt; 都有调度优先级；&lt;/li&gt;
&lt;li&gt;调度器可以冻结线程，支持电源管理；&lt;/li&gt;
&lt;li&gt;每个CPU都有自己独立的调度器，线程只能在自身CPU的调度器中调度，如果需要在CPU间移动，需要进行 &lt;strong&gt;迁移&lt;/strong&gt; 操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;
&lt;p&gt;XWOS的优先级，用类型 &lt;code&gt;xwpr_t&lt;/code&gt; 表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值越 &lt;strong&gt;小&lt;/strong&gt; ，优先级越 &lt;strong&gt;低&lt;/strong&gt; ，优先级的值越 &lt;strong&gt;大&lt;/strong&gt; ，优先级越 &lt;strong&gt;高&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;为了保证今后的扩展性，应该使用宏，而不要直接使用 &lt;code&gt;xwpr_t&lt;/code&gt; 的数值：
&lt;ul&gt;
&lt;li&gt;最小优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga440d65baefaf78c6d4d2ac4a817470bd&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_MIN&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;最大优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#gab96ee2b3dd640e72ea2da7aa40f7e1c0&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_MAX&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;无效优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga18540129b73106a735c623179b54e37e&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_INVALID&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;其他优先级应该使用最大优先级和最小优先级进行计算获取：
&lt;ul&gt;
&lt;li&gt;降低优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga80d502888629efa9bef83dddf93d2d2f&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_DROP&lt;/code&gt;&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;提高优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#gaa931e264469c6a30fb720b85d60b8295&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RAISE&lt;/code&gt;&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度算法&#34;&gt;调度算法&lt;/h2&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个优先级都有一个先进先出(FIFO)的 &lt;strong&gt;就绪&lt;/strong&gt; 队列；&lt;/li&gt;
&lt;li&gt;使用一个位图标记每个优先级队列是否为空；非空的队列对应的位被置1，否则被清0。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Skd/ready-queue_hu9b60b1c85faa2d0c7a8cad73f43546b4_90524_680x680_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;680&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS调度器就绪队列
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;调度流程&#34;&gt;调度流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义操作&lt;strong&gt;fls&lt;/strong&gt;：从最高位起查找第一个被置1的位，并返回其序号，
如果所有位都为0，返回-1。此操作需要CPU的相关指令来实现，例如ARM的clz，
DEC Alpha的ctlz，x86的lzcnt，PowerPC的cntlz等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流程图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TB
    start --&amp;gt; fls
    fls --&amp;gt; idx
    idx --否--&amp;gt; idle
    idx --是--&amp;gt; q
    q --&amp;gt; t
    t --&amp;gt; skd
    skd --&amp;gt; e
    idle --&amp;gt; e

    start(&amp;#34;开始&amp;#34;)
    fls[&amp;#34;idx = fls(bitmap)&amp;#34;]
    idx{&amp;#34;idx &amp;gt;= 0 ?&amp;#34;}
    idle[&amp;#34;调度空闲任务&amp;#34;]
    q[&amp;#34;选择优先级为idx的就绪队列&amp;#34;]
    t[&amp;#34;从就绪队列头部选择第一个线程&amp;#34;]
    skd[&amp;#34;调度选择的线程&amp;#34;]
    e(&amp;#34;结束&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;启动调度器&#34;&gt;启动调度器&lt;/h2&gt;
&lt;p&gt;当 &lt;a href=&#34;BootFlow&#34;&gt;启动流程&lt;/a&gt; 进入 &lt;code&gt;xwos_main()&lt;/code&gt; 后，可调用 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga41a4beaa63dc64bef8a346afbdbd6bee&#34;&gt;&lt;code&gt;xwos_skd_start_lc()&lt;/code&gt;&lt;/a&gt; 启动调度器，此时上下文(Context)将由 &lt;strong&gt;启动&lt;/strong&gt; 切换为 &lt;strong&gt;线程&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;抢占&#34;&gt;抢占&lt;/h2&gt;
&lt;p&gt;调度器始终选择优先级最高的线程，高优先级的线程可以抢占低优先级的线程。&lt;/p&gt;
&lt;p&gt;相同的优先级的线程，调度器按照 &lt;strong&gt;先进先出&lt;/strong&gt; 的方法调度，同优先级线程之间 &lt;strong&gt;不能&lt;/strong&gt; 相互抢占。&lt;/p&gt;
&lt;p&gt;用户可以关闭抢占： &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga50fdb4d22f93b80c109b628b5f7690d7&#34;&gt;&lt;code&gt;xwos_skd_dspmpt_lc()&lt;/code&gt;&lt;/a&gt; ，
也可以打开抢占： &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga4006c65a55cf7b4897cbcaef2a74c10e&#34;&gt;&lt;code&gt;xwos_skd_enpmpt_lc()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;调度器中的特殊任务&#34;&gt;调度器中的特殊任务&lt;/h2&gt;
&lt;h3 id=&#34;空闲任务&#34;&gt;空闲任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器中没有任何线程&lt;strong&gt;就绪&lt;/strong&gt;，调度器会调度空闲任务；&lt;/li&gt;
&lt;li&gt;空闲任务比较特殊，属于 &lt;strong&gt;最低优先级&lt;/strong&gt; 的线程上下文，但不能使用任何会导致睡眠与阻塞的函数。&lt;/li&gt;
&lt;li&gt;用户可在空闲任务中HOOK用户代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;xwbd/电路板/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;board_xwskd_idle_hook()&lt;/code&gt; 并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断底半部任务&#34;&gt;中断底半部任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器配置 &lt;code&gt;XWOSCFG_SD_BH&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，
调度器会为系统预留一个 &lt;strong&gt;最高优先级&lt;/strong&gt; 线程；&lt;/li&gt;
&lt;li&gt;中断底半部任务比较特殊，属于线程上下文，但不能使用任何会导致睡眠、阻塞的函数；&lt;/li&gt;
&lt;li&gt;中断底半部任务可抢占任何线程；&lt;/li&gt;
&lt;li&gt;当开启中断底半部时，调度器的滴答定时器任务运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;XWOS的中断底半部并未完全开发完成，目前只开放给滴答定时器任务使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户可以关闭中断底半部： &lt;a href=&#34;../../../capi/group__xwos__skd.html#gaf0f7900e90d47f8e5e3866ad8fe4be06&#34;&gt;&lt;code&gt;xwos_skd_dsbh_lc()&lt;/code&gt;&lt;/a&gt; ，
也可以打开中断底半部： &lt;a href=&#34;../../../capi/group__xwos__skd.html#gae8f42d03c7733220185c152e36a558fb&#34;&gt;&lt;code&gt;xwos_skd_enbh_lc()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;滴答定时器任务&#34;&gt;滴答定时器任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统内核通常都会包含一个定时器，用于产生固定周期的 &lt;strong&gt;滴答&lt;/strong&gt; （或称为 &lt;strong&gt;节拍&lt;/strong&gt; ）中断；&lt;/li&gt;
&lt;li&gt;滴答定时器任务也即是在此定时器中断中执行的周期性任务；&lt;/li&gt;
&lt;li&gt;如果 &lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt; 配置为 &lt;code&gt;1&lt;/code&gt; ，滴答定时器任务运行在中断底半部任务内部；&lt;/li&gt;
&lt;li&gt;如果 &lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt; 配置为 &lt;code&gt;0&lt;/code&gt; ，滴答定时器任务运行在中断上下文中；&lt;/li&gt;
&lt;li&gt;用户可以在滴答定时器任务中HOOK自己的代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;board_xwskd_syshwt_hook()&lt;/code&gt; 并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器的中断&#34;&gt;调度器的中断&lt;/h2&gt;
&lt;h3 id=&#34;切换上下文的中断&#34;&gt;切换上下文的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度器用于切换正在执行的线程的中断&lt;/li&gt;
&lt;li&gt;中断优先级： &lt;strong&gt;最低&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户可在切换上下文时，Hook自己的代码：
&lt;ul&gt;
&lt;li&gt;在切换上下文开始之前：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_PRE_SWCX_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义Hook函数 &lt;code&gt;board_thd_preinit_hook()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在切换上下文开始之后：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_POST_SWCX_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义Hook函数 &lt;code&gt;board_thd_postinit_hook()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滴答定时器的中断&#34;&gt;滴答定时器的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于产生固定周期的 &lt;strong&gt;滴答&lt;/strong&gt; （或称为 &lt;strong&gt;节拍&lt;/strong&gt; ）的定时器中断，&lt;a href=&#34;#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;由此中断触发执行。&lt;/li&gt;
&lt;li&gt;中断优先级： &lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度器服务中断&#34;&gt;调度器服务中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于执行调度器特殊操作的软中断，包括：
&lt;ul&gt;
&lt;li&gt;调度器休眠 &lt;code&gt;xwosplcb_skd_suspend_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程退出 &lt;code&gt;xwosplcb_thd_exit_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程冻结 &lt;code&gt;xwosplcb_thd_freeze_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程迁移 &lt;code&gt;xwosplcb_thd_immigrate_lic()&lt;/code&gt; 和 &lt;code&gt;xwosplcb_thd_outmigrate_lic()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断优先级：&lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬件定时器&#34;&gt;硬件定时器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS内核要求每个CPU都有一个私有的滴答定时器，产生固定频率的中断；&lt;/li&gt;
&lt;li&gt;通常配置为 &lt;strong&gt;1000HZ&lt;/strong&gt; ，可参考配置文件 &lt;code&gt;xwbd/电路板/cfg/xwos.h&lt;/code&gt; 中的配置 &lt;code&gt;XWOSCFG_SYSHWT_PERIOD&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;XWOS的滴答定时器会产生三个变量：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 滴答计数
&lt;ul&gt;
&lt;li&gt;在每次滴答定时器中断时，&lt;code&gt;tickcount&lt;/code&gt; 都会自增1；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 可以表示滴答定时器中断了多少次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;tickcount&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#ga0e2076d41b83f77080d40bb5cb9c7210&#34;&gt;&lt;code&gt;xwtm_nowtc()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;tickcount&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 系统时间
&lt;ul&gt;
&lt;li&gt;XWOS内核使用 &lt;strong&gt;纳秒(ns)&lt;/strong&gt; 作为时间的基本单位，假设滴答器频率 &lt;strong&gt;1000HZ&lt;/strong&gt; ， &lt;code&gt;tickcount&lt;/code&gt; 每1ms增加一次，即每1ms增加 &lt;code&gt;1000000&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 与 &lt;code&gt;tickcount&lt;/code&gt; 的关系： &lt;code&gt;timetick = tickcount * 1000000&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;timetick&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#gad144b9695441072c91d83aabc54ab5c4&#34;&gt;&lt;code&gt;xwtm_now()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;timetick&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 系统时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是以纳秒为单位的系统时间戳；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是通过把滴答定时器到下一次中断还剩多少时间计算出来，再累加到 &lt;code&gt;timetick&lt;/code&gt; 上获取的，其精度由SOC的主频与计数器的位宽决定；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;timestamp&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#gabdeea033c32e82ed1d6e5abcdf8d1aee&#34;&gt;&lt;code&gt;xwtm_nowts()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;timestamp&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;超时管理&#34;&gt;超时管理&lt;/h2&gt;
&lt;h3 id=&#34;时间树&#34;&gt;时间树&lt;/h3&gt;
&lt;p&gt;XWOS内核中，每个需要超时管理的对象（线程、软件定时器）都是以 &lt;strong&gt;时间树节点&lt;/strong&gt; 组织到时间树中。
&lt;strong&gt;时间树节点&lt;/strong&gt; 中包含了超时的 &lt;strong&gt;系统时间点&lt;/strong&gt; ，调度器每次进入滴答定时器任务时，都会检测时间树中是否有节点超时。
在时间树中，所有节点的 &lt;strong&gt;系统时间点&lt;/strong&gt; 都是未来的时间。最先超时的节点一定是 &lt;strong&gt;系统时间点&lt;/strong&gt; 最小的节点。
因此时间树的超时问题就是寻找最小值的问题。XWOS使用红黑树解决此最小值的问题，因此算法被称为 &lt;strong&gt;时间树&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个 &lt;strong&gt;leftmost&lt;/strong&gt; 指针指向最小值，超时可直接从 &lt;strong&gt;leftmost&lt;/strong&gt; 快速获取最小值，时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;超时后， &lt;strong&gt;leftmost&lt;/strong&gt; 从红黑树中被删除，按照二叉树的性质，下一任 &lt;strong&gt;leftmost&lt;/strong&gt; 是前任的右孩子（即后继）。
如果前任的后继为叶子，下一任 &lt;strong&gt;leftmost&lt;/strong&gt; 一定是前任的父节点，算法时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;删除 &lt;strong&gt;leftmost&lt;/strong&gt; 在系统中是一个高频次的操作，但由于 &lt;strong&gt;leftmost&lt;/strong&gt; 缺少左子树，根据红黑树性质，右子树也不可能太复杂，
意味着删除 &lt;strong&gt;leftmost&lt;/strong&gt; 后，调整红黑树的代价不会太大；&lt;/li&gt;
&lt;li&gt;插入操作需要遍历树，时间复杂度为 &lt;strong&gt;O(logn)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;红黑树中不允许存在关键字相同的节点，因此拥有相同 &lt;strong&gt;系统时间点&lt;/strong&gt; 的节点组成链表，超时后它们全部被唤醒。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Skd/timetree_hu5a14de9a02930993b5ae32946216e0fc_64326_680x490_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;490&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS时间树
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;超时函数的统一形式&#34;&gt;超时函数的统一形式&lt;/h3&gt;
&lt;p&gt;XWOS所有带超时管理的CAPI函数，都是以后缀 &lt;strong&gt;_to&lt;/strong&gt; 结尾，超时的参数都为 &lt;strong&gt;xwtm_t to&lt;/strong&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 睡眠 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_sleep_to&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号量 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sem_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sem &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sem, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待条件量 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cond_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_cond &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cond,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;union&lt;/span&gt; xwlk_ulock lock, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; lktype,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkdata, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkst);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待互斥锁 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_mtx_lock_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_mtx &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mtx, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号旗 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_flg_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_flg &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; flg, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; trigger, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; action,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; origin[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; msk[],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号选择器 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sel_select_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sel &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sel, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; msk[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; trg[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待线程同步 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_br_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_br &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; br, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; pos, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; sync[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数 &lt;strong&gt;to&lt;/strong&gt; 表明线程期望在未来的某个时间点被唤醒。&lt;/p&gt;
&lt;p&gt;当用户实现了一个具有超时功能的接口，写接口时发现其中需要调用多个具有超时功能的CAPI，
更糟糕的是这些CAPI内部可能又调用了其他具有超时功能的CAPI。&lt;/p&gt;
&lt;p&gt;计算每个CAPI花费了多少时间，然后将他们从超时时间中减去，显然很难实现。
最简单的方式就是只看结果，即 &lt;strong&gt;只关注未来什么时间点要唤醒&lt;/strong&gt; 。
将这个 &lt;strong&gt;未来时间点&lt;/strong&gt; 在内部CAPI中传递，无论这些带有超时功能的CAPI调用多少层，只要发生超时就唤醒。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;my_api&lt;/span&gt;(..., &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_mtx_lock_to&lt;/span&gt;(mtx, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sem_wait_to&lt;/span&gt;(sem, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;无论 &lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt; 等待了多少时间，也不会影响 &lt;code&gt;xwos_sem_wait_to()&lt;/code&gt; 在 &lt;code&gt;to&lt;/code&gt; 这个时间点唤醒。
当 &lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt; 把时间用尽， &lt;code&gt;to&lt;/code&gt; 就变成 &lt;strong&gt;过去的时间点&lt;/strong&gt; ， &lt;code&gt;xwos_sem_wait_to()&lt;/code&gt; 会立即返回 &lt;strong&gt;-ETIMEDOUT&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;获取上下文&#34;&gt;获取上下文&lt;/h2&gt;
&lt;p&gt;XWOS提供CAPI &lt;a href=&#34;../../../capi/group__xwos__skd.html#gace60b65a388c9ca8f796451733208173&#34;&gt;&lt;code&gt;xwos_skd_get_context_lc()&lt;/code&gt;&lt;/a&gt; 可以获取上下文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_INIT_EXIT&lt;/code&gt; ：初始化与反初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_THD&lt;/code&gt; ：线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_ISR&lt;/code&gt; ：中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_BH&lt;/code&gt; ：中断底半部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_IDLE&lt;/code&gt; ：空闲任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;暂停和继续调度器&#34;&gt;暂停和继续调度器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html#ga6fd2598d05fd97e1e9afdc93e16ec672&#34;&gt;&lt;code&gt;xwos_skd_pause_lc()&lt;/code&gt;&lt;/a&gt; ：暂停本地CPU调度器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停调度器包括几个操作：
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;关闭本地CPU调度器的抢占；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关闭本地CPU调度器的中断底半部；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;关闭本地CPU的系统定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html#ga21200028ffbf1fe2027b947a76b949ad&#34;&gt;&lt;code&gt;xwos_skd_continue_lc()&lt;/code&gt;&lt;/a&gt; ：继续运行本地CPU调度器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继续运行调度器包括几个操作：
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;启动本地CPU的系统定时器；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;打开本地CPU调度器的中断底半部；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;打开本地CPU调度器的抢占。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/skd.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__time.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/time.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程</title>
      <link>/docs/TechRefManual/Thd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Thd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt; 是XWOS最基本的调度单位，在其他RTOS中可能称之为 &lt;strong&gt;任务&lt;/strong&gt; 。
XWOS的线程，除了最基本的运行、睡眠、退出操作外，还支持冻结与解冻，迁移等操作。&lt;/p&gt;
&lt;p&gt;XWOS线程的函数，是仿造 &lt;code&gt;pthread&lt;/code&gt; 的函数设计的。&lt;/p&gt;
&lt;h3 id=&#34;线程的状态&#34;&gt;线程的状态&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 760px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Thd/thread-state_huaec0f5f93355fc1242cf72cb5941b922_44070_750x500_fill_catmullrom_smart1_3.png&#34; width=&#34;750&#34; height=&#34;500&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS线程状态图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;待命（standby）&lt;/strong&gt; ：线程对象已被初始化，但未指定主函数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪（ready）&lt;/strong&gt; ：线程已加入到就绪队列中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行（running）&lt;/strong&gt; ：线程正在运行，每个CPU中只可能存在一个线程正在运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;睡眠（sleeping）&lt;/strong&gt; ：线程正在睡眠；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞（blocking）&lt;/strong&gt; ：线程正在等待，可与&lt;strong&gt;睡眠&lt;/strong&gt;态组合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可被冻结（freezable）&lt;/strong&gt; ：线程可被冻结；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冻结（frozen）&lt;/strong&gt; ：线程已被冻结；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出（exiting）&lt;/strong&gt; ：线程即将结束；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移（migrating）&lt;/strong&gt; ：线程正处于迁移到别的CPU的过程中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; ：分离态的线程退出后由操作系统自动回收其内存资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已连接(joined)&lt;/strong&gt; ： &lt;strong&gt;连接态(joinable)&lt;/strong&gt; 的线程被其他线程 &lt;code&gt;join()&lt;/code&gt; 后的状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可被中断（uninterrupted）&lt;/strong&gt; ：线程的 &lt;strong&gt;阻塞&lt;/strong&gt; 与 &lt;strong&gt;睡眠&lt;/strong&gt; 不可被中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的分离态与连接态&#34;&gt;线程的分离态与连接态&lt;/h3&gt;
&lt;p&gt;XWOS线程的分离态与连接态是参考 &lt;strong&gt;pthread&lt;/strong&gt; 设计的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;code&gt;xwos_thd_join()&lt;/code&gt; 或 &lt;code&gt;xwos_thd_stop()&lt;/code&gt; 来回收其内存资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程对象与对象描述符&#34;&gt;线程对象与对象描述符&lt;/h3&gt;
&lt;p&gt;线程对象是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，线程对象也用 &lt;strong&gt;线程对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../api/structxwos__thd__d.html&#34;&gt;&lt;code&gt;xwos_thd_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;线程对象描述符由 &lt;strong&gt;线程对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; thd; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 线程对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_thd_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;线程的初始化与创建&#34;&gt;线程的初始化与创建&lt;/h2&gt;
&lt;h3 id=&#34;线程属性&#34;&gt;线程属性&lt;/h3&gt;
&lt;p&gt;线程在创建或初始化时，可通过参数 &lt;a href=&#34;../../../api/structxwos__thd__attr.html&#34;&gt;&lt;code&gt;struct xwos_thd_attr&lt;/code&gt;&lt;/a&gt; 设定其属性。
XWOS的线程属性参考 &lt;strong&gt;pthread&lt;/strong&gt; 来实现，其结构体定义也与 &lt;code&gt;pthread_attr_t&lt;/code&gt; 类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::privileged&lt;/code&gt; ：表示线程拥有系统特权。
&lt;ul&gt;
&lt;li&gt;在ARMv6m/ARMv7m中，是通过 &lt;code&gt;CONTROL&lt;/code&gt; 寄存器的 &lt;code&gt;bit0(nPRIV)&lt;/code&gt; 来实现的；&lt;/li&gt;
&lt;li&gt;在Embedded PowerPC中，是通过 &lt;code&gt;MSR&lt;/code&gt; 寄存器的 &lt;code&gt;bit17(PR)&lt;/code&gt; 来实现的；&lt;/li&gt;
&lt;li&gt;在RISCV32中，是通过 &lt;code&gt;MCAUSE&lt;/code&gt; 寄存器的 &lt;code&gt;bit28&lt;/code&gt; 和 &lt;code&gt;bit29(MPP)&lt;/code&gt; 来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::detached&lt;/code&gt; ：表示线程是分离的，类似于POSIX线程的detached属性。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;code&gt;xwos_thd_join()&lt;/code&gt; 或 &lt;code&gt;xwos_thd_stop()&lt;/code&gt; 来回收其内存资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack&lt;/code&gt; ：表示线程的栈的首地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack_size&lt;/code&gt; ：表示线程的栈的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack_guard_size&lt;/code&gt; ：表示线程的警戒线位置。
&lt;ul&gt;
&lt;li&gt;当栈指针sp增长超过了警戒线位置会触发 &lt;strong&gt;stackoverflow&lt;/strong&gt; 警告，但这需要SOC的MPU或MMU来提供支持，
可以在线程创建后的HOOK函数 &lt;code&gt;board_thd_postinit_hook()&lt;/code&gt; 来针对不同的SOC设置MPU或MMU。&lt;/li&gt;
&lt;li&gt;XWOS内部也提供了一种基于 &lt;code&gt;if...else...&lt;/code&gt; 的检测逻辑，但 &lt;strong&gt;stack overflow&lt;/strong&gt; 后导致程序跑飞，可能没有机会运行检测逻辑的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::name&lt;/code&gt; ：表示线程的名字，用于调试时的日志输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::priority&lt;/code&gt; ：表示线程的优先级，XWOS的优先级是数值越大，优先级越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;静态初始化&#34;&gt;静态初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaa65fb89529f37b1b87a2003fe562d99b&#34;&gt;&lt;code&gt;xwos_thd_init()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;静态初始化线程还需预先定义栈数组，作用域为全局。&lt;/li&gt;
&lt;li&gt;栈数组的首地址与大小，必须要满足CPU的ABI规则。例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 &lt;code&gt;__xwcc__aligned(8)&lt;/code&gt; 来修饰，且大小是8的倍数。&lt;/li&gt;
&lt;li&gt;如果CPU内有L1Cache，应该使用 &lt;code&gt;__xwcc_alignl1cache&lt;/code&gt; 来修饰栈数组，让其对其到L1Cache的缓存线上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd static_thd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwos_thd_d static_thdd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;__xwcc_aligned&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwstk_t&lt;/span&gt; static_thd_stack[&lt;span style=&#34;color:#666&#34;&gt;512&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程函数... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;some_function&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_attr_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;static.thd&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; static_thd_stack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack_size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(static_thd_stack);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.priority &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; THD_PRIORITY;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.detached &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.privileged &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;static_thd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;static_thdd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr, thd_func, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;动态创建&#34;&gt;动态创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaf224b65a6b895c5fa4ca51bfa3ff92e1&#34;&gt;&lt;code&gt;xwos_thd_create()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;li&gt;动态方式创建的线程，栈内存也可以动态申请，其地址对齐问题由操作系统内核处理。&lt;/li&gt;
&lt;li&gt;动态方式创建的线程，栈内存也支持使用静态方式定义的数组。栈数组的首地址与大小，必须要满足CPU的ABI规则。
例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 &lt;code&gt;__xwcc__aligned(8)&lt;/code&gt; 来修饰，且大小是8的倍数。&lt;/li&gt;
&lt;li&gt;如果CPU内有L1Cache，应该使用 &lt;code&gt;__xwcc_alignl1cache&lt;/code&gt; 来修饰栈静态方式定义的数组，让其对其到L1Cache的缓存线上。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwos_thd_d dynamic_thdd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程函数... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;some_function&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd_attr attr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_attr_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;dynamic.thd&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack_size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2048&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.priority &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; THD_PRIORITY;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.detached &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.privileged &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_create&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;dynamic_thdd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr, thd_func, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;中断线程的阻塞态与睡眠态&#34;&gt;中断线程的阻塞态与睡眠态&lt;/h2&gt;
&lt;p&gt;但线程调用了会 &lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;睡眠&lt;/strong&gt; 的函数而进入 &lt;strong&gt;阻塞态&lt;/strong&gt; 或 &lt;strong&gt;睡眠态&lt;/strong&gt; 时，它会让出CPU，调度器会重新调度。
其他线程或上下文可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga2fc40de236c05f0a22420a4bca61ac56&#34;&gt;&lt;code&gt;xwos_thd_intr()&lt;/code&gt;&lt;/a&gt; 中断其 &lt;strong&gt;阻塞态&lt;/strong&gt; 或 &lt;strong&gt;睡眠态&lt;/strong&gt; ，
&lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;睡眠&lt;/strong&gt; 的函数会以错误码 &lt;strong&gt;-EINTR&lt;/strong&gt; ( &lt;strong&gt;-4&lt;/strong&gt; ) 返回。&lt;/p&gt;
&lt;h2 id=&#34;线程的退出与返回值&#34;&gt;线程的退出与返回值&lt;/h2&gt;
&lt;h3 id=&#34;线程的退出&#34;&gt;线程的退出&lt;/h3&gt;
&lt;p&gt;线程退出通常有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主函数直接 &lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;主函数中调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac5fbf8b3d9060ff19a12563cb3202beb&#34;&gt;&lt;code&gt;xwos_cthd_exit(rc)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此CAPI的用法类似于POSIX中的函数 &lt;code&gt;pthread_exit()&lt;/code&gt; ，调用的线程会立即终止并抛出返回值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_exit&lt;/span&gt;(XWOK); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程在此处结束，并抛出返回值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 后面的代码不再执行 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;线程分离&#34;&gt;线程分离&lt;/h3&gt;
&lt;p&gt;线程退出的行为，与属性 &lt;code&gt;xwos_thd_attr::detached&lt;/code&gt; 有关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga26965560c7f4ad21b5089eed17a30e25&#34;&gt;&lt;code&gt;xwos_thd_stop()&lt;/code&gt;&lt;/a&gt; 来回收其内存资源。
若忘记调用，资源不会自动被回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通知线程退出&#34;&gt;通知线程退出&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gab4cdf4d2e068124cc11888b462da5de4&#34;&gt;&lt;code&gt;xwos_thd_quit()&lt;/code&gt;&lt;/a&gt; 可用于通知线程退出。
调用此CAPI，可为线程设置 &lt;strong&gt;退出状态&lt;/strong&gt; ，并中断线程的 &lt;strong&gt;阻塞状态&lt;/strong&gt; 和 &lt;strong&gt;睡眠状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被通知退出的线程&lt;/strong&gt; 正在调用的 &lt;strong&gt;阻塞和睡眠&lt;/strong&gt; 的CAPI将以返回值 &lt;code&gt;-EINTR&lt;/code&gt; 返回。除非 &lt;strong&gt;被通知退出的线程&lt;/strong&gt; 是 &lt;strong&gt;不可被中断&lt;/strong&gt; 的。&lt;/p&gt;
&lt;p&gt;线程自己可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac642513fb53a00db87738c6d2dd8e430&#34;&gt;&lt;code&gt;xwos_cthd_frz_shld_stop()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;退出状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;等待线程退出&#34;&gt;等待线程退出&lt;/h3&gt;
&lt;p&gt;若线程是 &lt;strong&gt;连接态(joinable)&lt;/strong&gt; 的，其他线程可通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 等待线程结束并获取其返回值。
此CAPI调用后，操作系统还会回收线程的资源。&lt;/p&gt;
&lt;h3 id=&#34;终止线程&#34;&gt;终止线程&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga26965560c7f4ad21b5089eed17a30e25&#34;&gt;&lt;code&gt;xwos_thd_stop()&lt;/code&gt;&lt;/a&gt; 可终止线程并等待它退出。
此CAPI等价于 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gab4cdf4d2e068124cc11888b462da5de4&#34;&gt;&lt;code&gt;xwos_thd_quit()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;线程自身检测-退出状态&#34;&gt;线程自身检测 &lt;strong&gt;退出状态&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;线程自己可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;退出状态&lt;/strong&gt; 。
可以作为线程循环的结束条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_stop&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...thread loop... */&lt;/span&gt; ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线程自身的睡眠&#34;&gt;线程自身的睡眠&lt;/h2&gt;
&lt;p&gt;XWOS内核提供多种线程睡眠方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gad1072fb4ff4803b8181fc7f54fcb3880&#34;&gt;&lt;code&gt;xwos_cthd_sleep()&lt;/code&gt;&lt;/a&gt; ：睡眠的时间的起点由此CAPI自己获取，这种方式只需告诉CAPI需要睡眠多少事件，使用简单，但精度较低。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga067c6169bf591a14813b004494e41f45&#34;&gt;&lt;code&gt;xwos_cthd_sleep_to()&lt;/code&gt;&lt;/a&gt; ：指定未来的某个时间点被唤醒，精度较高。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga46e5a1cbd6c58a36dda954a76e44b3e2&#34;&gt;&lt;code&gt;xwos_cthd_sleep_from()&lt;/code&gt;&lt;/a&gt;：睡眠时间的起点和持续时间由调用者提供，时间起点可以是 &lt;strong&gt;过去&lt;/strong&gt; 的时间点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果线程只是想让调度器在同优先级的就绪队列中重新调度一下，可以通过调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac453f990c2da012a43e7cbe121b8ec10&#34;&gt;&lt;code&gt;xwos_cthd_sleep()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;线程的冻结与解冻&#34;&gt;线程的冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;线程自身冻结&#34;&gt;线程自身冻结&lt;/h3&gt;
&lt;p&gt;线程的冻结，是用来支持内核的一些特殊功能的，用户不能随意冻结线程。
在以下情况，XWOS内核要求线程进入冻结状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统准备进入低功耗模式。如果此时线程还在运行，很有可能因其正在访问硬件资源、
占用锁，导致系统关闭硬件、清理资源时发生异常。因此线程需要运行到一个特殊的点后冻结，这个点就是 &lt;strong&gt;冻结点&lt;/strong&gt; 。
线程进入冻结点前，需要返回到最外层的主函数中，并释放掉所有的锁和硬件资源。&lt;/li&gt;
&lt;li&gt;线程迁移至另一个CPU。线程迁移时，也需要返回至最外层的冻结点，保证不能占用当前CPU的任何资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga9bde1c6bafdb881079b41803296b69ee&#34;&gt;&lt;code&gt;xwos_cthd_shld_frz()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;可被冻结&lt;/strong&gt; 状态。
一旦检测到 &lt;strong&gt;可被冻结&lt;/strong&gt; 状态，就需要调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga7088d8e2a4c5ee8497dba07ff2dbc32d&#34;&gt;&lt;code&gt;xwos_cthd_freeze()&lt;/code&gt;&lt;/a&gt; 冻结自己。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_stop&lt;/span&gt;()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断线程是否需要退出 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;do_sth&lt;/span&gt;(&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程在内部阻塞在某个同步对象或锁上 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;EINTR &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; rc) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 当线程需要冻结，阻塞/睡眠将被中断会以-EINTR返回 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_frz&lt;/span&gt;()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断是否需要冻结 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;release_resource&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 释放资源... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_freeze&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 冻结 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程解冻后，从这里继续执行。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 如果线程发生了迁移，线程在另一个CPU上也是从此处开始运行。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;acquire_resource&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 重新获取资源... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 处理其他原因导致的中断... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果线程冻结之前不需要释放任何资源，可以使用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac642513fb53a00db87738c6d2dd8e430&#34;&gt;&lt;code&gt;xwos_cthd_frz_shld_stop()&lt;/code&gt;&lt;/a&gt; 。
此CAPI等价于 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga9bde1c6bafdb881079b41803296b69ee&#34;&gt;&lt;code&gt;xwos_cthd_shld_frz()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga7088d8e2a4c5ee8497dba07ff2dbc32d&#34;&gt;&lt;code&gt;xwos_cthd_freeze()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线程循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; wasfrz;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_frz_shld_stop&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;wasfrz)) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 通过wasfrz可以获知线程是否被冻结过 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程循环... */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;线程的解冻不由用户来操作，系统完成特殊功能后会自动对线程进行解冻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统退出低功耗模式时&lt;/li&gt;
&lt;li&gt;线程迁移操作已经完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的迁移&#34;&gt;线程的迁移&lt;/h2&gt;
&lt;p&gt;在多核系统中，XWOS的线程只会在某个CPU上被调度，XWOS内核并不会自动对线程做均衡处理，但支持将线程迁移到另一个CPU上。&lt;/p&gt;
&lt;h3 id=&#34;迁移流程&#34;&gt;迁移流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假定条件：线程正在CPU-A上，准备迁移到CPU-B上&lt;/li&gt;
&lt;li&gt;流程：
&lt;ul&gt;
&lt;li&gt;用户在任意CPU的任意上下文调用CAPI： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaccabca6cd9608f56205e634f9676a8f5&#34;&gt;&lt;code&gt;xwos_thd_migrate()&lt;/code&gt;&lt;/a&gt; ；
&lt;ul&gt;
&lt;li&gt;系统向CPU-A发送调度器服务中断，提出 &lt;strong&gt;迁移出&lt;/strong&gt; 的申请；&lt;/li&gt;
&lt;li&gt;CPU-A切换至调度器服务中断，向线程设置冻结标志，并中断线程的阻塞态和睡眠态，然后退出中断上下文；&lt;/li&gt;
&lt;li&gt;CPU-A中线程被重新调度，并运行到冻结点；&lt;/li&gt;
&lt;li&gt;线程在冻结点向CPU-A发送调度器服务中断，执行 &lt;strong&gt;冻结&lt;/strong&gt; 操作；&lt;/li&gt;
&lt;li&gt;线程冻结后，CPU-A向CPU-B申请调度器服务中断，提出 &lt;strong&gt;迁移进&lt;/strong&gt; 的申请；&lt;/li&gt;
&lt;li&gt;CPU-B切换至调度器服务中断，把线程加入到自己的调度器中，解除线程的冻结状态，并加入就绪列表中；&lt;/li&gt;
&lt;li&gt;迁移完成，线程开始在CPU-B中调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的本地存储&#34;&gt;线程的本地存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;C11&lt;/strong&gt; 标准之后引入线程本地存储(TLS)，XWOS支持关键字 &lt;code&gt;_Thread_local&lt;/code&gt; ( &lt;strong&gt;C99&lt;/strong&gt; )、 &lt;code&gt;thread_local&lt;/code&gt; ( &lt;strong&gt;C2X&lt;/strong&gt; ) ，
以及 &lt;strong&gt;gcc&lt;/strong&gt; 以及 &lt;strong&gt;clang&lt;/strong&gt; 编译器扩展的关键字 &lt;code&gt;__thread&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;strong&gt;C99&lt;/strong&gt; 以前的标准，用户可以通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gae188b894f4ddcf94b3df3c7cd1f071d5&#34;&gt;&lt;code&gt;xwos_cthd_set_data()&lt;/code&gt;&lt;/a&gt; ：设置线程自身私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga160c44b91fdff5f5610a32e72c822639&#34;&gt;&lt;code&gt;xwos_cthd_get_data()&lt;/code&gt;&lt;/a&gt; ：获取线程自身私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga62529c26dfb773bd973f0841e3c06ed4&#34;&gt;&lt;code&gt;xwos_thd_set_data()&lt;/code&gt;&lt;/a&gt; ：设置任意线程私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gaf2fdd413163f2868c68199c12467c2a0&#34;&gt;&lt;code&gt;xwos_thd_get_data()&lt;/code&gt;&lt;/a&gt; ：获取任意线程私有变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程对象的生命周期管理&#34;&gt;线程对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;线程对象的基类是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
线程对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga1183035d75506a5e3d7ea52a096cabe7&#34;&gt;&lt;code&gt;xwos_thd_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga3a3e3d71eed7967d5fd21915317dfe8c&#34;&gt;&lt;code&gt;xwos_thd_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga4b75215c8821082a451e274bc07fcd2d&#34;&gt;&lt;code&gt;xwos_thd_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga12a0141b2c54bd3c0b73fe74049155cb&#34;&gt;&lt;code&gt;xwos_thd_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/thd.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 软件定时器</title>
      <link>/docs/TechRefManual/Swt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Swt/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;软件定时器是基于调度器的&lt;a href=&#34;../Skd#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;实现的，因此时间精度最小为滴答定时器的中断频率。
软件定时器可以是 &lt;strong&gt;单次&lt;/strong&gt; 的，也可以是 &lt;strong&gt;周期&lt;/strong&gt; 的。&lt;/p&gt;
&lt;h3 id=&#34;软件定时器对象与对象描述符描述符&#34;&gt;软件定时器对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;软件定时器对象是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，软件定时器对象也用 &lt;strong&gt;软件定时器对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../api/structxwos__swt__d.html&#34;&gt;&lt;code&gt;xwos_swt_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;软件定时器对象描述符由 &lt;strong&gt;软件定时器对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_swt &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; swt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 软件定时器对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_swt_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器的初始化销毁与动态创建删除&#34;&gt;软件定时器的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga6caba60b647d79eaedc3c27574eed0dd&#34;&gt;&lt;code&gt;xwos_swt_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的软件定时器： &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaea2454a168f5c6c5e73d49e40951aca1&#34;&gt;&lt;code&gt;xwos_swt_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga66c1d6aeb17f7409f8ea0a891da4f301&#34;&gt;&lt;code&gt;xwos_swt_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的软件定时器： &lt;a href=&#34;../../../capi/group__xwos__swt.html#gac631b6c398b820410a9507bb3b24645a&#34;&gt;&lt;code&gt;xwos_swt_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软件定时器的标志&#34;&gt;软件定时器的标志&lt;/h2&gt;
&lt;p&gt;软件定时器在初始化或创建时，需要指定 &lt;strong&gt;标志&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga2b8e3dc8c11fed042cdf140302bd3e3c&#34;&gt;&lt;code&gt;XWOS_SWT_FLAG_NULL&lt;/code&gt;&lt;/a&gt; ：无任何标志，占位符，也表示定时器为单次的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gaa30937ca651cbc12c7d2827d3eae987f&#34;&gt;&lt;code&gt;XWOS_SWT_FLAG_RESTART&lt;/code&gt;&lt;/a&gt; ：定时器为周期性的，即超时后自动重新开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;启动软件定时器&#34;&gt;启动软件定时器&lt;/h2&gt;
&lt;p&gt;软件定时器初始化或创建完成后，可以使用 &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga3defb3f4a851acb451b38adbdf28d0cb&#34;&gt;&lt;code&gt;xwos_swt_start()&lt;/code&gt;&lt;/a&gt; 启动。&lt;/p&gt;
&lt;p&gt;启动时，需要指定开始的时间起点，周期，以及回调函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf5517e151d64405f9db648f50a71ee07&#34;&gt;&lt;code&gt;xwos_swt_f&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器的回调函数&#34;&gt;软件定时器的回调函数&lt;/h2&gt;
&lt;p&gt;软件定时器超时后，其回调函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf5517e151d64405f9db648f50a71ee07&#34;&gt;&lt;code&gt;xwos_swt_f&lt;/code&gt;&lt;/a&gt; 会被调用。其原型被定义为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwos_swt_f) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_swt &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中第一个参数是软件定时器自己的指针，第二个参数是在 &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga3defb3f4a851acb451b38adbdf28d0cb&#34;&gt;&lt;code&gt;xwos_swt_start()&lt;/code&gt;&lt;/a&gt; 指定的回调函数的参数。&lt;/p&gt;
&lt;p&gt;软件定时器的回调函数运行在滴答定时器任务中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当开启中断底半部时，软件定时器的回调函数运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;当关闭中断底半部时，软件定时器的回调函数运行在中断上下文中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是运行在中断底半部还是中断上下文，软件定时器的回调函数都 &lt;strong&gt;不&lt;/strong&gt; 可使用任何会导致睡眠、阻塞的API。&lt;/p&gt;
&lt;h2 id=&#34;停止软件定时器&#34;&gt;停止软件定时器&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gab2fe98dd896049aeba43a524909a8a5b&#34;&gt;&lt;code&gt;xwos_swt_stop()&lt;/code&gt;&lt;/a&gt; 停止已经启动的软件定时器。&lt;/p&gt;
&lt;p&gt;对于未启动的软件定时器，此函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gab2fe98dd896049aeba43a524909a8a5b&#34;&gt;&lt;code&gt;xwos_swt_stop()&lt;/code&gt;&lt;/a&gt; 只会返回错误码，
不会产生任何破坏性的影响。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器对象的生命周期管理&#34;&gt;软件定时器对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;软件定时器对象的基类是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
软件定时器对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf804ccd1a6eab3e80edcd9cd5a8d7752&#34;&gt;&lt;code&gt;xwos_swt_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga29900a2342065235217f98d5048bdcac&#34;&gt;&lt;code&gt;xwos_swt_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga585f2ef89c9a4565006beedd7c10aacd&#34;&gt;&lt;code&gt;xwos_swt_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gab6df0a49f8b9be89f96d9c95773d13c2&#34;&gt;&lt;code&gt;xwos_swt_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/swt.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 锁</title>
      <link>/docs/TechRefManual/Lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;临界区管理&#34;&gt;临界区管理&lt;/h2&gt;
&lt;p&gt;临界区是指访问共用资源的程序片段，传统RTOS中，通常使用以下几种方式保护临界区资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用协作式内核：线程（任务）不主动放弃CPU不会发生调度，因此共享的资源在
线程（任务）中访问都是安全的。&lt;/li&gt;
&lt;li&gt;关闭抢占：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;li&gt;关闭中断：可用于保护线程与线程、线程与中断共享的资源。&lt;/li&gt;
&lt;li&gt;互斥锁：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS内核是假定系统为MP来设计的（UP可以视为MP的特例），
因此在进入临界区的方式与传统RTOS有些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭抢占：使用自旋锁或其派生锁的&lt;code&gt;lock&lt;/code&gt;与&lt;code&gt;unlock&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;关闭CPU总中断：使用自旋锁或其派生锁的&lt;code&gt;lock_cpuirq&lt;/code&gt;与&lt;code&gt;unlock_cpuirq&lt;/code&gt;形式的API。
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_cpuirqsv&lt;/code&gt;与&lt;code&gt;unlock_cpuirqrs&lt;/code&gt;
形式的API来保存与恢复CPU总中断开关标志，防止内层锁解锁时意外地把CPU总中断打开；&lt;/li&gt;
&lt;li&gt;关闭部分中断：使用自旋锁或其派生锁的&lt;code&gt;lock_irqs&lt;/code&gt;与&lt;code&gt;unlock_irqs&lt;/code&gt;形式的API，
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_irqssv&lt;/code&gt;与&lt;code&gt;unlock_irqsrs&lt;/code&gt;
形式的API来保存与恢复部分中断开关标志，防止内层锁解锁时意外地把这些中断打开；&lt;/li&gt;
&lt;li&gt;关闭中断底半部：使用自旋锁或其派生锁的&lt;code&gt;lock_bh&lt;/code&gt;与&lt;code&gt;unlock_bh&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;互斥锁：只能用于保护被多个线程共享的资源；&lt;/li&gt;
&lt;li&gt;原子操作：XWOS中提供原子操作的函数库&lt;code&gt;xwos/lib/xwaop.h&lt;/code&gt;，并抽象了std:atomic类似的内存模型。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 同步</title>
      <link>/docs/TechRefManual/Sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/</guid>
      <description>
        
        
        &lt;p&gt;XWOS提供多种同步机制，它们统一称为&lt;strong&gt;同步对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;条件量&lt;/li&gt;
&lt;li&gt;事件标志&lt;/li&gt;
&lt;li&gt;线程栅栏&lt;/li&gt;
&lt;li&gt;信号选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;与&lt;strong&gt;条件量&lt;/strong&gt;是操作系统最基本的两种同步机制，
其他复杂的同步机制都可基于这两种同步机制实现。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 内存管理</title>
      <link>/docs/TechRefManual/Mm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Mm/</guid>
      <description>
        
        
        &lt;p&gt;XWOS提供四种内存管理的算法。&lt;/p&gt;
&lt;h2 id=&#34;简单内存分配器&#34;&gt;简单内存分配器&lt;/h2&gt;
&lt;p&gt;简单内存分配器只分配大小最适应内存块，不对内存进行回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单，代码量非常小；&lt;/li&gt;
&lt;li&gt;运行时间稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：内存一旦分配出去不再回收，释放函数只是一个 &lt;strong&gt;Dummy&lt;/strong&gt; 函数；&lt;/li&gt;
&lt;li&gt;适用性：简单的RTOS应用场合或不需要回收内存的场合&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__sma.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/sma.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存切片分配器&#34;&gt;内存切片分配器&lt;/h2&gt;
&lt;p&gt;内存切片分配器将内存切割成等量的块，就像 &lt;strong&gt;卡片&lt;/strong&gt; 一样，然后将它们连接在一起形成队列，
每次分配时取一块内存，回收时再把内存切片放回到队列中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单，代码量较小；&lt;/li&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;申请与释放操作的运行时间是稳定的；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;内存块大小固定，如果要求的内存过小，会造成内存浪费；
如果要求的内存超过内存块的大小，无法满足需求；&lt;/li&gt;
&lt;li&gt;连续申请的两块内存不能保证是连续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：对时间稳定性要求高的RTOS应用场合。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__memslice.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/memslice.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;伙伴算法分配器&#34;&gt;伙伴算法分配器&lt;/h2&gt;
&lt;p&gt;伙伴算法分配器在分配时，会将内存不断地二等分，直到切割到能满足要求的最小内存大小为止。
释放时会检查与之相邻并等长的内存块（称为伙伴）是否也空闲，
如果是，就和“伙伴”合并成更大的内存块，
然后继续检测合并后的内存块是否也存在可以合并的伙伴，一直向上合并到不能合并为止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;支持大小不固定的内存申请操作；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;代码稍微复杂；&lt;/li&gt;
&lt;li&gt;因为存在合并与切割的循环，申请与释放操作的所需要的时间不是特别稳定；&lt;/li&gt;
&lt;li&gt;内存大小固定为2的指数，如果申请的内存过小，会造成内存浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：对内存复用性要求高的应用场合。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__bma.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/bma.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存池&#34;&gt;内存池&lt;/h2&gt;
&lt;p&gt;内存池是结合了内存切片分配器与伙伴算法分配器的算法。内存管理的基本单位为页，
一页内存为4096字节，页内存使用伙伴算法分配器管理。
内存池还使用对象缓存算法建立各种小尺寸的块：8字节、16字节、32字节、
64字节、96字节、128字节、160字节、192字节、256字节、320字节、384字节、
512字节、768字节、1024字节、2048字节。
当申请内存大于2048字节，直接分配页内存；当申请的内存小于等于2048字节，
就从尺寸最合适的对象缓存分配器中分配一块内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;支持大小不固定的内存申请操作；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片；&lt;/li&gt;
&lt;li&gt;小内存块不会浪费过多的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;代码复杂；&lt;/li&gt;
&lt;li&gt;申请与释放操作的所需要的时间不稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：外接尺寸较大的SRAM或SDRAM的内存管理，C++和Lua虚拟机的对象池。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__mempool.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/mempool.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 电源管理</title>
      <link>/docs/TechRefManual/Pm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Pm/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS有两套电源管理框架，分别用于MP系统和UP系统。&lt;/p&gt;
&lt;p&gt;XWOS的电源管理框架只提供了基本流程，最终SOC如何休眠由BSP中的回调函数实现：
用户可以自行决定是否保持SDRAM的刷新、是否保持某些GPIO的输出、或则是否进入最低功耗的待机等等。&lt;/p&gt;
&lt;h2 id=&#34;mp系统的电源管理&#34;&gt;MP系统的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;电源管理领域&#34;&gt;电源管理领域&lt;/h3&gt;
&lt;p&gt;MP系统中，CPU不唯一，XWOS中使用 &lt;strong&gt;电源管理领域(PMDM)&lt;/strong&gt; 来统一管理所有CPU的休眠与唤醒。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 789px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Pm/mp-pm-flow_huad237c88a54a050d1276e5f5ab1230e1_100614_779x658_fill_catmullrom_smart1_3.png&#34; width=&#34;779&#34; height=&#34;658&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
MP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了可以进行 &lt;strong&gt;电源管理阶段&lt;/strong&gt; 转换的方向。
&lt;strong&gt;电源管理领域&lt;/strong&gt; 将电源管理分为四个阶段（图中绿色的框）：&lt;/p&gt;
&lt;h5 id=&#34;正在运行--xwmp_pmdm_stage_running-&#34;&gt;正在运行 ( &lt;code&gt;XWMP_PMDM_STAGE_RUNNING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;所有CPU正常运行，可以使用下面CAPI进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此CAPI是操作系统抽象层 &lt;strong&gt;OSAL&lt;/strong&gt; 中的CAPI，实际调用的是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwmp_pmdm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;冻结调度器--解冻调度器--xwmp_pmdm_stage_freezing---xwmp_pmdm_stage_thawing-&#34;&gt;冻结调度器 —— 解冻调度器 ( &lt;code&gt;XWMP_PMDM_STAGE_FREEZING - XWMP_PMDM_STAGE_THAWING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，PMDM会通知所有CPU冻结线程。当调度器中线程全部冻结后，调度器会向PMDM报告 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态。
调度器冻结线程的过程是一个比较复杂的过程，这个阶段又分为几个子阶段（图中蓝色的框）：&lt;/p&gt;
&lt;h6 id=&#34;冻结线程--解冻线程--xwmp_skd_wklkcnt_freezing---xwmp_skd_wklkcnt_thawing-&#34;&gt;冻结线程 —— 解冻线程 ( &lt;code&gt;XWMP_SKD_WKLKCNT_FREEZING - XWMP_SKD_WKLKCNT_THAWING&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;调度器会中断所有线程的 &lt;strong&gt;等待&lt;/strong&gt; 和 &lt;strong&gt;睡眠&lt;/strong&gt; 态，并为所有线程设置 &lt;strong&gt;可冻结&lt;/strong&gt; 标志，
然后依次调度每个线程，直到它们运行到 &lt;strong&gt;冻结点&lt;/strong&gt; 进行冻结，这个过程耗时比较长，
在执行过程中如果遇到唤醒事件，调度器会在唤醒事件中断中切换为解冻流程：
解冻已经冻结的线程，并取消未冻结的线程的 &lt;strong&gt;可冻结&lt;/strong&gt; 标志。&lt;/p&gt;
&lt;h6 id=&#34;全部线程已经冻结--xwmp_skd_wklkcnt_allfrz-&#34;&gt;全部线程已经冻结 ( &lt;code&gt;XWMP_SKD_WKLKCNT_ALLFRZ&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断。
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照 &lt;a href=&#34;../Skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt; 中的约束，唤醒事件中断的优先级低于调度器服务中断，
因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，
滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h6 id=&#34;调度器已经暂停--xwmp_skd_wklkcnt_suspended-&#34;&gt;调度器已经暂停 ( &lt;code&gt;XWMP_SKD_WKLKCNT_SUSPENDED&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;CPU从上一步骤的调度器服务中断中退出后，会切换回线程上下文，此时因所有线程已经冻结，
CPU只可能运行在 &lt;a href=&#34;../Skd#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1&#34;&gt;空闲任务&lt;/a&gt; 中。
CPU会在空闲任务中向PMDM报告调度器 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态。此过程不能在调度器服务中断中进行，
因为调度器服务中断是最高优先级中断，不能被唤醒事件中断打断，有可能会导致无法唤醒的问题。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复--xwmp_pmdm_stage_suspending---xwmp_pmdm_stage_resuming-&#34;&gt;正在暂停 —— 正在恢复 ( &lt;code&gt;XWMP_PMDM_STAGE_SUSPENDING - XWMP_PMDM_STAGE_RESUMING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;当最后一个CPU报告了 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态后，会在最后一个CPU的 &lt;strong&gt;空闲任务&lt;/strong&gt; 中执行用户的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数。
此时，如果出现唤醒事件，电源管理的阶段会从 &lt;strong&gt;正在暂停&lt;/strong&gt; 切换为 &lt;strong&gt;正在恢复&lt;/strong&gt; ，并执行用户的 &lt;code&gt;resume()&lt;/code&gt; 回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt; 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt; 回调函数用于在唤醒之前执行与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时，PMDM会自动锁定 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; ，并关闭当前CPU的总中断开关。
&lt;strong&gt;resume-suspend锁&lt;/strong&gt; 是自旋锁，如果CPU-1正在执行 &lt;code&gt;suspend()&lt;/code&gt; 回调函数，此时出现了唤醒事件，会分下面两种情况进行处理：
&lt;ul&gt;
&lt;li&gt;唤醒事件中断也绑定在CPU-1上，唤醒事件中断会挂起，直到 &lt;code&gt;suspend()&lt;/code&gt; 回调函数返回，
PMDM解锁 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; 并打开CPU总中断开关，才被处理，然后执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;li&gt;唤醒事件中断绑定在CPU-2上，CPU-2会立即进入唤醒事件中断，但一直会 &lt;strong&gt;自旋&lt;/strong&gt; 等待CPU-1释放 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; ，
直到获得 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; 后，才会执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例WeActMiniStm32H750的 &lt;code&gt;resume()&lt;/code&gt; 与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_resume&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 恢复stm32cube中的所有设备 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwds_pm_resume&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 暂停stm32cube：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 暂停所有设备
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 配置GPIO */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwds_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置休眠方式为STOP模式：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           STOP模式下寄存器与内部RAM数据不丢失，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           因此休眠方式为SuspendToRAM，唤醒后运行状态可恢复。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_SetRegulModeDS&lt;/span&gt;(LL_PWR_REGU_DSMODE_LOW_POWER);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_EnableFlashPowerDown&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD1PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D1STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD2PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D2STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD3PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D3STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableDeepSleep&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置ARMv7-m的DEEPSLEEP位 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableDeepSleep&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;已经暂停--xwmp_pmdm_stage_suspended-&#34;&gt;已经暂停 ( &lt;code&gt;XWMP_PMDM_STAGE_SUSPENDED&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt; ：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt; ：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当最后一个CPU的 &lt;strong&gt;空闲任务&lt;/strong&gt; 执行完上一阶段的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数后，
PMDM将电源管理步骤切换到此阶段，并执行 &lt;code&gt;sleep()&lt;/code&gt; 回调函数。
SOC系统在 &lt;code&gt;sleep()&lt;/code&gt; 回调函数内部进入低功耗状态，
此时时钟停止，代码停止运行， &lt;code&gt;sleep()&lt;/code&gt; 回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将 &lt;code&gt;sleep()&lt;/code&gt; 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。
例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ &lt;code&gt;WFI&lt;/code&gt; ），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现， &lt;code&gt;wakeup()&lt;/code&gt; 回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数 &lt;code&gt;sleep()&lt;/code&gt; 与 &lt;code&gt;wakeup()&lt;/code&gt; 之间没有锁的保护，
因此 &lt;code&gt;sleep()&lt;/code&gt; 回调函数需要设计成能被 &lt;code&gt;wakeup()&lt;/code&gt; 回调函数打断。&lt;/p&gt;
&lt;p&gt;示例，WeActMiniStm32H750的 &lt;code&gt;wakeup()&lt;/code&gt; 与 &lt;code&gt;sleep()&lt;/code&gt; 回调函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_wakeup&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableSleep&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 清除DEEPSLEEP位 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;SystemClock_Config&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从STOP模式恢复后，需要重新配置时钟 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_sleep&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;cm_wfi&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分为两种情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中的 &lt;code&gt;WFI&lt;/code&gt; 指令执行后出现唤醒事件：
唤醒流程执行完毕后，代码会回到 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中 &lt;strong&gt;位置2&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中的 &lt;code&gt;WFI&lt;/code&gt; 指令执行之前出现唤醒事件：
唤醒事件中断会打断 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 函数，
然后执行 &lt;code&gt;stm32cube_pm_wakeup()&lt;/code&gt; 函数，
函数 &lt;code&gt;LL_LPM_EnableSleep()&lt;/code&gt; 会清除ARMv7-m的DEEPSLEEP位，接下来的唤醒流程也会将滴答定时器重新打开，
当再次回到 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 的 &lt;strong&gt;位置1&lt;/strong&gt; 时， &lt;code&gt;WFI&lt;/code&gt; 指令只会使CPU进入ARMv7-m的SLEEP模式，
只是短暂地暂停了一下CPU时钟，即将到来的滴答定时器中断可使系统恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;up内核的电源管理&#34;&gt;UP内核的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;流程-1&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 683px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Pm/up-pm-flow_hud28fc7ba75fb6cae820cff89a3e4c72a_66458_673x499_fill_catmullrom_smart1_3.png&#34; width=&#34;673&#34; height=&#34;499&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
UP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了 &lt;strong&gt;电源管理阶段&lt;/strong&gt; 切换的方向。
UP系统电源管理分为五个阶段：&lt;/p&gt;
&lt;h5 id=&#34;正在运行--xwup_pm_stage_running-&#34;&gt;正在运行 ( &lt;code&gt;XWUP_PM_STAGE_RUNNING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;调度器正常运行，可以使用下面CAPI进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwup_skd_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;正在冻结线程--正在解冻线程--xwup_pm_stage_freezing---xwup_pm_stage_thawing-&#34;&gt;正在冻结线程 —— 正在解冻线程 ( &lt;code&gt;XWUP_PM_STAGE_FREEZING - XWUP_PM_STAGE_THAWING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，调度器会中断所有线程的 &lt;strong&gt;等待&lt;/strong&gt; 和 &lt;strong&gt;睡眠&lt;/strong&gt; 态，并通知所有线程冻结。这个过程耗时比较长，
在执行过程中如果遇到唤醒事件，调度器可在唤醒事件中断中切换为解冻流程：解冻已冻结的线程，并将调度器状态逐步恢复至 &lt;strong&gt;正在运行&lt;/strong&gt; 。&lt;/p&gt;
&lt;h5 id=&#34;调度器中全部线程已经冻结--xwup_pm_stage_allfrz-&#34;&gt;调度器中全部线程已经冻结 ( &lt;code&gt;XWUP_PM_STAGE_ALLFRZ&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断，
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照 &lt;a href=&#34;../Skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt; 中的约束，唤醒事件中断的优先级低于调度器服务中断，
因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复--xwup_pm_stage_suspending---xwup_pm_stage_resuming-&#34;&gt;正在暂停 —— 正在恢复 ( &lt;code&gt;XWUP_PM_STAGE_SUSPENDING - XWUP_PM_STAGE_RESUMING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;当全部线程冻结后，调度器只能调度 &lt;strong&gt;空闲任务&lt;/strong&gt; ，调度器会在 &lt;strong&gt;空闲任务&lt;/strong&gt; 中执行用户的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数。
此时，如果出现唤醒事件，系统会在唤醒事件中断中将状态从 &lt;strong&gt;正在暂停&lt;/strong&gt; 切换为 &lt;strong&gt;正在恢复&lt;/strong&gt; ，并执行用户的 &lt;code&gt;resume()&lt;/code&gt; 回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt; 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt; 回调函数用于在唤醒之前执行与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时系统会关闭CPU总中断开关。如果正在执行 &lt;code&gt;suspend()&lt;/code&gt; 回调函数时出现了唤醒事件，
唤醒事件中断会挂起，直到 &lt;code&gt;suspend()&lt;/code&gt; 回调函数，系统打开CPU总中断开关时才被处理，然后执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;已经暂停--xwup_pm_stage_suspended-&#34;&gt;已经暂停 ( &lt;code&gt;XWUP_PM_STAGE_SUSPENDED&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt; ：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt; ：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 &lt;strong&gt;空闲任务&lt;/strong&gt; 执行完上一阶段的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数后，电源管理步骤切换到此阶段，并执行 &lt;code&gt;sleep()&lt;/code&gt; 回调函数。
SOC系统在 &lt;code&gt;sleep()&lt;/code&gt; 回调函数内部进入休眠状态，此时时钟停止，代码停止运行， &lt;code&gt;sleep()&lt;/code&gt; 回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将 &lt;code&gt;sleep()&lt;/code&gt; 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。
例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ &lt;code&gt;WFI&lt;/code&gt; ），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现， &lt;code&gt;wakeup()&lt;/code&gt; 回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数 &lt;code&gt;sleep()&lt;/code&gt; 与 &lt;code&gt;wakeup()&lt;/code&gt; 之间没有锁的保护，
因此 &lt;code&gt;sleep()&lt;/code&gt; 回调函数需要设计成能被 &lt;code&gt;wakeup()&lt;/code&gt; 回调函数打断。&lt;/p&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__pm.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/pm.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 通用库</title>
      <link>/docs/TechRefManual/Xwlib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: 系统间通讯机制</title>
      <link>/docs/TechRefManual/Isc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: C/C&#43;&#43;</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Lua语言</title>
      <link>/docs/TechRefManual/Lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lua/</guid>
      <description>
        
        
        &lt;p&gt;现代的MCU已经有足够的性能运行解释型语言。XWOS集成了Lua语言 —— 一种轻量小巧的脚本语言。
Lua语言在XWOS中的移植被称为 &lt;strong&gt;XWLUA&lt;/strong&gt; ， &lt;strong&gt;XWLUA&lt;/strong&gt; 有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交互式解释器：一个独立的线程，用户通过串口终端，可在线运行Lua语言的函数，也可运行文件系统中的脚本；&lt;/li&gt;
&lt;li&gt;多线程：Lua语言并不支持多线程，XWLUA扩展了Lua语言，实现了多线程的功能；&lt;/li&gt;
&lt;li&gt;锁机制：支持互斥锁、自旋锁、顺序锁；&lt;/li&gt;
&lt;li&gt;同步机制：支持信号量、条件量、事件标志、信号选择器、线程栅栏；&lt;/li&gt;
&lt;li&gt;驱动库：已经完成部分驱动的封装。
&lt;ul&gt;
&lt;li&gt;GPIO&lt;/li&gt;
&lt;li&gt;I2C&lt;/li&gt;
&lt;li&gt;SPI&lt;/li&gt;
&lt;li&gt;UART&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 780px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Lua/xwlua-repl_huba7457b0b89d1acb56e6b6901db3c0e1_79894_770x623_fill_catmullrom_smart1_3.png&#34; width=&#34;770&#34; height=&#34;623&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWLUA交互式解释器
&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;运行Lua虚拟机需要有足够的内存和浮点运算单元，因此只能在资源比较丰富的MCU上开启Lua语言，
XWOS自带的参考工程中，以下工程开启了Lua语言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/EmbedFireStm32H743XWOS.git&#34;&gt;EmbedFireStm32H743XWOS&lt;/a&gt;：野火STM32H743-Pro开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/AtkApolloH743XWOS.git&#34;&gt;AtkApolloH743XWOS&lt;/a&gt;：正点原子阿波罗STM32H743开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/FK429M1XWOS.git&#34;&gt;FK429M1XWOS&lt;/a&gt;：反客STM32F429-M1开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/WeActMiniStm32H750XWOS.git&#34;&gt;WeActMiniStm32H750XWOS&lt;/a&gt;：微行电子MiniStm32H750开发板&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工程结构&#34;&gt;工程结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工程路径： &lt;code&gt;xwem/vm/lua&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目录结构
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt; ：lua的官方源码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlua&lt;/code&gt; ：xwlua的实现
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;port.h, port.c, prefix.h, readline.c&lt;/code&gt; ：Lua语言在XWOS上的移植代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lua.c&lt;/code&gt; ：以XWOS线程方式运行的交互式解释器(REPL)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwvm&lt;/code&gt; ：虚拟机库：虚拟机之间的数据交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos&lt;/code&gt; ：XWOS内核的binding库：包括线程、信号量、条件量、事件标志、信号选择器、线程栅栏、互斥锁、自旋锁、顺序锁、电源管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlib&lt;/code&gt; ：XWOS基本C函数的binding库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwds&lt;/code&gt; ：玄武设备栈的binding库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwxt&lt;/code&gt; ：多线程共享数据的全局导出表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mif.h, mif.c&lt;/code&gt; ：玄武模块的启动接口，交互式解释器(REPL)线程在此处启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; ：玄武模块的编译规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwlua的扩展&#34;&gt;XWLUA的扩展&lt;/h2&gt;
&lt;h3 id=&#34;多线程&#34;&gt;多线程&lt;/h3&gt;
&lt;p&gt;原生的Lua语言不支持多线程（Lua中的类型 &lt;code&gt;thread&lt;/code&gt; 并不是真正的线程，而是协程。），脚本中的全局变量只能由执行脚本的线程自身访问。
XWLUA在C语言层面开发了多线程的功能，每个线程都拥有一个 &lt;strong&gt;独立的Lua虚拟机&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;全局导出表&#34;&gt;全局导出表&lt;/h3&gt;
&lt;p&gt;为了实现多线程共享数据，XWLUA中实现了一个 &lt;strong&gt;全局导出表(xwxt)&lt;/strong&gt; ，全局导出表中的数据对所有线程可见，并且是线程安全的。
全局导出表也是Lua中的一个独立的虚拟机。&lt;/p&gt;
&lt;h3 id=&#34;新的metamethod__copy&#34;&gt;新的Metamethod：&lt;code&gt;__copy&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;元方法 &lt;code&gt;__copy()&lt;/code&gt; 用于将用户数据从一个虚拟机（全局导出表、线程） &lt;strong&gt;深拷贝&lt;/strong&gt; 到另一个虚拟机（线程、全局导出表）中。
只有 &lt;strong&gt;userdata&lt;/strong&gt; 可以定义 &lt;code&gt;__copy()&lt;/code&gt; 元方法。&lt;/p&gt;
&lt;p&gt;元方法 &lt;code&gt;__copy()&lt;/code&gt; 有两个参数，第一个参数是 &lt;strong&gt;数据&lt;/strong&gt; ，第二参数是 &lt;strong&gt;目的虚拟机&lt;/strong&gt; ，无返回值。
元方法 &lt;code&gt;__copy()&lt;/code&gt; 运行在 &lt;strong&gt;保护模式&lt;/strong&gt; ，可以 &lt;strong&gt;抛出错误&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;实现元方法 &lt;code&gt;__copy()&lt;/code&gt; 时，若拷贝失败，应该在 &lt;strong&gt;目的虚拟机&lt;/strong&gt; 中压入一个 &lt;strong&gt;nil&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;XWLUA的对象都提供了元方法 &lt;code&gt;__copy()&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;对象强指针&#34;&gt;对象强指针&lt;/h3&gt;
&lt;p&gt;XWLUA使用 &lt;strong&gt;对象强指针&lt;/strong&gt; 管理XWOS内核中的对象（线程、信号量、条件量、事件标志、信号选择器、线程栅栏、互斥锁、自旋锁、顺序锁）。
&lt;strong&gt;对象强指针&lt;/strong&gt; 是一种 &lt;strong&gt;userdata&lt;/strong&gt; 。 &lt;strong&gt;对象强指针&lt;/strong&gt; 就是对XWOS中的 &lt;a href=&#34;../XwosStd#%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;对象描述符&lt;/a&gt; 的封装。
再借助于Lua虚拟机的GC机制，可实现对象的生命周期自动管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lua虚拟机每引用一个 &lt;strong&gt;对象强指针&lt;/strong&gt; ，都会增加相关联对象的引用计数；&lt;/li&gt;
&lt;li&gt;Lua虚拟机每 &lt;strong&gt;&amp;ldquo;GC&amp;rdquo;&lt;/strong&gt; 一个 &lt;strong&gt;对象强指针&lt;/strong&gt; ，都会减少相关联对象的引用计数；&lt;/li&gt;
&lt;li&gt;当相关联对象的引用计数为 &lt;strong&gt;0&lt;/strong&gt; 时，就会执行C语言层面对象的 &lt;code&gt;GC&lt;/code&gt; 函数 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对象强指针&lt;/strong&gt; 的概念源于Lua语言的 &lt;strong&gt;强引用&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;luaapi参考手册luadoc&#34;&gt;&lt;a href=&#34;../../../luadoc&#34;&gt;LuaAPI参考手册&lt;/a&gt;&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Rust语言</title>
      <link>/docs/TechRefManual/Rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Rust/</guid>
      <description>
        
        
        &lt;h2 id=&#34;rustapi参考手册rustdocxwrust&#34;&gt;&lt;a href=&#34;../../../rustdoc/xwrust/&#34;&gt;RustAPI参考手册&lt;/a&gt;&lt;/h2&gt;

      </description>
    </item>
    
  </channel>
</rss>
