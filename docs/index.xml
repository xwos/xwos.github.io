<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XWOS – 文档</title>
    <link>/docs/</link>
    <description>Recent content in 文档 on XWOS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: GD32V移植说明</title>
      <link>/docs/Note/SOC/RISC-V/GD32V/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/SOC/RISC-V/GD32V/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;GD32V相关的代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构描述层(ADL)： &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CPU描述层(CDL)： &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SOC描述层(SDL)
&lt;ul&gt;
&lt;li&gt;GD32V： &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;启动流程&#34;&gt;启动流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序入口： &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_boot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中断&#34;&gt;中断&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;采用 &lt;strong&gt;非向量模式&lt;/strong&gt; ，统一的入口： &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_isr_entry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用RISC-V标准寄存器 &lt;code&gt;mscratch&lt;/code&gt; 来实现ARM-Cortex-M类似的双栈结构的工作方式&lt;/li&gt;
&lt;li&gt;异常统一的入口 &lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_esr_entry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;源码：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_soc_irq.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度&#34;&gt;调度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;源码：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosasmimpl_skd.S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;栈结构&#34;&gt;栈结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RISC-V要求栈必须按 &lt;strong&gt;16字节&lt;/strong&gt; 对齐；&lt;/li&gt;
&lt;li&gt;RISC-V只使用 &lt;strong&gt;满递减栈&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;RISC-V的ABI文档中将寄存器分为两类：caller-saved (即volatile)和callee-saved (即non-volatile) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;caller-saved栈结构&#34;&gt;caller-saved栈结构&lt;/h4&gt;
&lt;p&gt;从线程进入中断时，中断入口程序会自动将caller-saved寄存器保存到栈中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  __caller&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;saved&lt;/span&gt; (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt;) context__
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;19&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;t6&lt;/span&gt; (x31) &lt;span style=&#34;color:#666&#34;&gt;----------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;t5&lt;/span&gt; (x30)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;17&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;t4&lt;/span&gt; (x29)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;t3&lt;/span&gt; (x28)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;a7&lt;/span&gt; (x17)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;a6&lt;/span&gt; (x16)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      msubm &lt;span style=&#34;color:#666&#34;&gt;--------+&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      mepc          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      mcause        &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      mscratch      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a5&lt;/span&gt; (x15)      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; RV32I
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a4&lt;/span&gt; (x14)      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a3&lt;/span&gt; (x13)      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a2&lt;/span&gt; (x12)    RV32E &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a1&lt;/span&gt; (x11)      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;a0&lt;/span&gt; (x10)      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;t2&lt;/span&gt; (x7)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;t1&lt;/span&gt; (x6)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;t0&lt;/span&gt; (x5)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;ra&lt;/span&gt; (x1)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  __caller&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;saved&lt;/span&gt; (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt;) context__
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;callee-saved栈结构&#34;&gt;callee-saved栈结构&lt;/h4&gt;
&lt;p&gt;切换上下文时，需要保存与恢复callee-saved寄存器栈结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  __callee&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;saved&lt;/span&gt; (non&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt;) context__
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;s11&lt;/span&gt; (x27)         &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;s10&lt;/span&gt; (x26)         &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;s9&lt;/span&gt; (x25)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;      &lt;span style=&#34;color:#00a000&#34;&gt;s8&lt;/span&gt; (x24)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s7&lt;/span&gt; (x23)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s6&lt;/span&gt; (x22)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s5&lt;/span&gt; (x21)        RV32I
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s4&lt;/span&gt; (x20)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s3&lt;/span&gt; (x19)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s2&lt;/span&gt; (x18)          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       mstatus &lt;span style=&#34;color:#666&#34;&gt;------+&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s1&lt;/span&gt; (x9)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;s0&lt;/span&gt; (x8)     RV32E &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;       &lt;span style=&#34;color:#00a000&#34;&gt;tp&lt;/span&gt; (x4)       &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;  __callee&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;saved&lt;/span&gt; (non&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt;) context__
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;滴答定时器&#34;&gt;滴答定时器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用RISC-V标准中定义的定时器来产生滴答中断。&lt;/li&gt;
&lt;li&gt;源码：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tls&#34;&gt;TLS&lt;/h2&gt;
&lt;p&gt;TLS是C11标准开始引入的语言特性。XWOS支持TLS：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;XWOS/xwcd/soc/riscv/nuclei/xwosimpl_tls.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XWOS将TLS数据段放在线程栈内存起始的位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Thread Stack Memmory &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;+----------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   SP &lt;span style=&#34;color:#666&#34;&gt;---&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;     Stack Region     &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;+----------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;     Stack Guard      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;+----------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;      TLS Region      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#666&#34;&gt;------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RISC-V有专门用于TLS的寄存器x4(tp)，在线程初始化时，需要让x4指向TLS的起始位置。
切换上下文时也要切换x4的值。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: git-msg规范</title>
      <link>/docs/Standard/GitMsg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Standard/GitMsg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;格式&#34;&gt;格式&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# [标题] &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): :emoji: &amp;lt;subject&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - type: feat, fix, perf, refactor, style, revert, docs, test, ci,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;#         chore, milestone, release, revision, alpha, beta, rc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - scope: 可为空&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - subject: 以动词开始的短语，结尾无句号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 页眉只占一行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 每行总长度不超过72个字符（中文字符计2个字符）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# [正文] 描述&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 为什么需要修改？&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 如何定位问题？&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 修改有什么副作用？&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 每行总长度不超过72个字符（中文字符计2个字符）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# [脚注] &amp;lt;token:&amp;gt; &amp;lt;text&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 问题的ID或链接&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - BREAKING-CHANGE（破坏性修改）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# - 每行总长度不超过72个字符（中文字符计2个字符）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考：&lt;a href=&#34;https://www.conventionalcommits.org/&#34;&gt;https://www.conventionalcommits.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-commit-message格式规则&#34;&gt;git-commit-message格式规则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;标题信息必须以一个可选的 &lt;strong&gt;类别(type)&lt;/strong&gt; 作为前缀， &lt;strong&gt;类别(type)&lt;/strong&gt; 后面可以跟一个可选的 &lt;strong&gt;范围描述词(scope)&lt;/strong&gt; ，
&lt;strong&gt;范围描述词(scope)&lt;/strong&gt; 需要放在英文的小括号内，之后可再跟一个可选的英文的 &lt;strong&gt;!&lt;/strong&gt; 表示有 &lt;strong&gt;BREAKING CHANGE&lt;/strong&gt; 发生；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类别(type)&lt;/strong&gt; 说明
&lt;ul&gt;
&lt;li&gt;feat: 新功能
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;新增 &lt;code&gt;:sparkles:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除 &lt;code&gt;:fire:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置相关 &lt;code&gt;:wrench:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;升级依赖 &lt;code&gt;:arrow_up:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增待改进的代码 &lt;code&gt;:poop:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增.o或.a文件 &lt;code&gt;:package:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fix: 修复BUG
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;修复重大BUG &lt;code&gt;:ambulance:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修复BUG &lt;code&gt;:bug:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修复警告 &lt;code&gt;:rotating_light:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修复安全问题 &lt;code&gt;:lock:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;perf: 性能优化
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;性能优化 &lt;code&gt;:zap:&lt;/code&gt; &lt;code&gt;:racehorse:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除死代码 &lt;code&gt;:coffin:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;refactor: 重构代码
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;重大重构 &lt;code&gt;:hammer:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增 &lt;code&gt;:sparkles:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重构 &lt;code&gt;:recycle:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除 &lt;code&gt;:fire:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置相关 &lt;code&gt;:wrench:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;破坏性修改 &lt;code&gt;:boom:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增加log &lt;code&gt;:loud_sound:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除log &lt;code&gt;:mute:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调整路径 &lt;code&gt;:truck:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;依赖的第三方软件更新导致的API更新 &lt;code&gt;:alien:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;style: 格式调整（删除行尾空格等）
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:art:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;revert: 回退提交
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;回退代码 &lt;code&gt;:rewind:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;降级依赖 &lt;code&gt;:arrow_down:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;docs: 文档
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;增加文档 &lt;code&gt;:memo:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改.md文档 &lt;code&gt;:book:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改源码中的注释 &lt;code&gt;:bulb:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;test: 测试
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;增加测试 &lt;code&gt;:white_check_mark:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增加反向测试（导致错误的测试） &lt;code&gt;:test_tube:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ci: 系统集成
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:construction_worker:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;chore: 其他未归类的零碎事务
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;配置相关 &lt;code&gt;:wrench:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分支合并 &lt;code&gt;:twisted_rightwards_arrows:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;milestone: 发布大版本
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;release: 发布小版本
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;revision: 发布修订版
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alpha: 发布alpha版本
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;beta: 发布beta版本
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rc: 发布rc版本
&lt;ul&gt;
&lt;li&gt;emoji
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:bookmark:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标题中的 &lt;strong&gt;主题(subject)&lt;/strong&gt; 与 &lt;strong&gt;类别(type)&lt;/strong&gt; 之间需要增加一个冒号 &lt;code&gt;:&lt;/code&gt; 与一个空格 &lt;code&gt; &lt;/code&gt; ，然后增加emoji符号，在间隔一个空格 &lt;code&gt; &lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;标题的最后不能有标点符号；&lt;/li&gt;
&lt;li&gt;标题只能占一行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BREAKING CHANGE&lt;/strong&gt; 是指
&lt;ul&gt;
&lt;li&gt;API原型修改&lt;/li&gt;
&lt;li&gt;API删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正文&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;正文与标题间需要空一行；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;脚注&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;脚注与正文间需要空一行；&lt;/li&gt;
&lt;li&gt;每一项脚注需要有一个单词作为 &lt;strong&gt;令牌(token)&lt;/strong&gt; ，
&lt;ul&gt;
&lt;li&gt;格式可以是 &lt;strong&gt;令牌(token)&lt;/strong&gt; 后面跟一个 &lt;code&gt;:&lt;/code&gt; 和一个空格 &lt;code&gt; &lt;/code&gt; 作为间隔，例如： &lt;code&gt;token: &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;格式也可以是 &lt;strong&gt;令牌(token)&lt;/strong&gt; 后面跟一个空格 &lt;code&gt; &lt;/code&gt; 和 &lt;code&gt;#&lt;/code&gt; 作为间隔，例如： &lt;code&gt;token: &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;脚注可以有多行内容，直到遇到新的**令牌(token)**为止；&lt;/li&gt;
&lt;li&gt;脚注的行与行之间无空行；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符集规则&#34;&gt;字符集规则&lt;/h2&gt;
&lt;p&gt;全部使用 &lt;strong&gt;utf-8&lt;/strong&gt; 字符集。&lt;/p&gt;
&lt;h3 id=&#34;设置方法&#34;&gt;设置方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增加环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#b8860b&#34;&gt;LESSHARESET&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;utf-8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;设置字符集&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config i18n.commitencoding utf-8    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 设置提交日志使用utf-8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config i18n.logoutputencoding utf-8 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 设置输出日志时使用utf-8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config core.quotepath &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 中文路径使用utf-8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config gui.encoding utf-8           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 图形界面使用utf-8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;行尾空格规则&#34;&gt;行尾空格规则&lt;/h2&gt;
&lt;p&gt;原则上，使用 &lt;code&gt;\n&lt;/code&gt;（LF）作为换行符，但自动生成的代码可不遵守这个规则。&lt;/p&gt;
&lt;h2 id=&#34;windows-ntfs文件系统的文件权限问题&#34;&gt;Windows NTFS文件系统的文件权限问题&lt;/h2&gt;
&lt;p&gt;NTFS文件系统下，会导致文件的mode变为100644，且chmod无法修改，
可修改git配置忽略文件模式的变更。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config core.filemode &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Libc</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/Libc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/Libc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;xwosxwos-内核对libc的依赖&#34;&gt;&lt;code&gt;XWOS/xwos&lt;/code&gt; 内核对libc的依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string.h&lt;/code&gt;：依赖 &lt;code&gt;memset()&lt;/code&gt; 、 &lt;code&gt;memcpy()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当配置了 &lt;code&gt;XWOSCFG_SKD_THD_STDC_MM&lt;/code&gt; 、 &lt;code&gt;XWOSCFG_SKD_SWT_STDC_MM&lt;/code&gt; 、
&lt;code&gt;XWOSCFG_SYNC_SEM_STDC_MM&lt;/code&gt; 、 &lt;code&gt;XWOSCFG_SYNC_COND_STDC_MM&lt;/code&gt; 、
&lt;code&gt;XWOSCFG_SYNC_EVT_STDC_MM&lt;/code&gt; 或 &lt;code&gt;XWOSCFG_LOCK_MTX_STDC_MM&lt;/code&gt; 时，
依赖 &lt;code&gt;malloc()&lt;/code&gt; 和 &lt;code&gt;free()&lt;/code&gt; 函数动态创建和删除对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inttypes.h&lt;/code&gt; 、 &lt;code&gt;stdint.h&lt;/code&gt; 、 &lt;code&gt;stddef.h&lt;/code&gt; ：XWOS的&lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt;基于标准C的基本类型进行定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdbool.h&lt;/code&gt;：依赖bool类型的定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdatomic.h&lt;/code&gt;：依赖原子操作内存屏障的定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdarg.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;code&gt;XWLIBCFG_SC&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;xwos/lib/sc.h&lt;/code&gt; 需要使用变参函数；&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt;， &lt;code&gt;xwos/lib/xwlog.c&lt;/code&gt; 需要使用变参函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdio.h&lt;/code&gt;：若 &lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt;， &lt;code&gt;xwos/lib/xwlog.c&lt;/code&gt; 中格式化日志依赖 &lt;code&gt;vsnprintf()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwosxwmd-提供的对libc的支持&#34;&gt;&lt;code&gt;XWOS/xwmd&lt;/code&gt; 提供的对libc的支持&lt;/h2&gt;
&lt;h3 id=&#34;动态内存管理&#34;&gt;动态内存管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;malloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;free()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;cfree()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;realloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;calloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;memalign()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;aligned_alloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;valloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;pvalloc()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/newlibac/mem.c&lt;/code&gt; 提供底层支持，
并覆盖了newlib中原有的实现。 &lt;code&gt;xwmd/libc/newlibac/mem.c&lt;/code&gt; 中的实现是对 &lt;a href=&#34;../../Mm/Mempool&#34;&gt;mempool&lt;/a&gt; 的封装，
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mempool&lt;/strong&gt; 需要在 &lt;code&gt;board_init()&lt;/code&gt; 中选择内存设备进行初始化后才可使用，并且需要提供 &lt;code&gt;newlibac_mempool&lt;/code&gt; 定义才可使用 &lt;code&gt;stdlib.h&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/picolibcac/mem.c&lt;/code&gt; 提供底层支持，
并覆盖了picolibc中原有的实现。 &lt;code&gt;xwmd/libc/picolibcac/mem.c&lt;/code&gt; 中的实现是对 &lt;a href=&#34;../../Mm/Mempool&#34;&gt;mempool&lt;/a&gt; 的封装，
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mempool&lt;/strong&gt; 需要在 &lt;code&gt;board_init()&lt;/code&gt; 中选择内存设备进行初始化后才可使用，并且需要提供 &lt;code&gt;picolibcac_mempool&lt;/code&gt; 定义才可使用 &lt;code&gt;stdlib.h&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;newlibac_mempool&lt;/code&gt; 或 &lt;code&gt;picolibcac_mempool&lt;/code&gt; 需要BSP中提供定义，不同的工程情况不一致，XWOS项目组提供几个示例工程，
可以参考工程的 &lt;code&gt;README.md&lt;/code&gt; 中的 &lt;code&gt;libc&lt;/code&gt; 章节获得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/ATKSTM32F407ZXWOS.git&#34;&gt;ATKSTM32F407ZXWOS&lt;/a&gt;：正点原子F407核心板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/EmbedFireStm32H743XWOS.git&#34;&gt;EmbedFireStm32H743XWOS&lt;/a&gt;：野火STM32H743-Pro开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/AtkApolloH743XWOS.git&#34;&gt;AtkApolloH743XWOS&lt;/a&gt;：正点原子阿波罗STM32H743开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/FK429M1XWOS.git&#34;&gt;FK429M1XWOS&lt;/a&gt;：反客STM32F429-M1开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/WeActMiniStm32H750XWOS.git&#34;&gt;WeActMiniStm32H750XWOS&lt;/a&gt;：微行电子MiniStm32H750开发板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;setjmplongjmp&#34;&gt;&lt;code&gt;setjmp()/longjmp()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 函数对可实现在不同函数间的 &lt;code&gt;goto&lt;/code&gt; 。
用户应该使用头文件 &lt;code&gt;xwos/lib/setjmp.h&lt;/code&gt; 中代替标准C的头文件 &lt;code&gt;setjmp.h&lt;/code&gt; ，
并且也应该使用 &lt;code&gt;xwlib_setjmp()&lt;/code&gt; 与 &lt;code&gt;xwlib_longjmp()&lt;/code&gt; 函数对代替 &lt;code&gt;setjmp()/longjmp()&lt;/code&gt; 函数 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 函数对。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;setjmp()/longjmp()&lt;/code&gt; 在 MISRA-C2012标准中被禁止使用。&lt;/p&gt;
&lt;h3 id=&#34;errno&#34;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;XWOS重构了 &lt;code&gt;errno&lt;/code&gt; 的实现，将 &lt;code&gt;errno&lt;/code&gt; 改为每个线程的私有变量，
线程访问 &lt;code&gt;errno&lt;/code&gt; 时，只会访问自己的 &lt;code&gt;errno&lt;/code&gt; 。
用户应该使用 &lt;code&gt;xwos/lib/errno.h&lt;/code&gt; 替代libc中的 &lt;code&gt;errno.h&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时， &lt;code&gt;errno&lt;/code&gt; 的实现位于 &lt;code&gt;xwmd/libc/newlibac/errno.c&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时， &lt;code&gt;errno&lt;/code&gt; 的实现位于 &lt;code&gt;xwmd/libc/picolibcac/errno.c&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 头文件 &lt;code&gt;stdio.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fopen()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fclose()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fread()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fwrite()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fseek()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;remove()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;rename()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/newlibac/fops.c&lt;/code&gt; 提供底层支持，
&lt;code&gt;xwmd/libc/newlibac/fops.c&lt;/code&gt; 又依赖第三方软件 &lt;a href=&#34;http://elm-chan.org/fsw/ff/00index_e.html&#34;&gt;&lt;code&gt;xwem/fs/fatfs&lt;/code&gt;&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/picolibcac/fops.c&lt;/code&gt; 提供底层支持，
&lt;code&gt;xwmd/libc/picolibcac/fops.c&lt;/code&gt; 又依赖第三方软件 &lt;a href=&#34;http://elm-chan.org/fsw/ff/00index_e.html&#34;&gt;&lt;code&gt;xwem/fs/fatfs&lt;/code&gt;&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FatFs需要BSP中提供对块设备操作的支持，不同的电路板对文件操作的支持情况不一致，XWOS项目组提供几个示例工程，
可以参考工程的 &lt;code&gt;README.md&lt;/code&gt; 中的 &lt;code&gt;FatFS&lt;/code&gt; 章节获得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/ATKSTM32F407ZXWOS.git&#34;&gt;ATKSTM32F407ZXWOS&lt;/a&gt;：正点原子F407核心板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/EmbedFireStm32H743XWOS.git&#34;&gt;EmbedFireStm32H743XWOS&lt;/a&gt;：野火STM32H743-Pro开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/AtkApolloH743XWOS.git&#34;&gt;AtkApolloH743XWOS&lt;/a&gt;：正点原子阿波罗STM32H743开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/FK429M1XWOS.git&#34;&gt;FK429M1XWOS&lt;/a&gt;：反客STM32F429-M1开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/WeActMiniStm32H750XWOS.git&#34;&gt;WeActMiniStm32H750XWOS&lt;/a&gt;：微行电子MiniStm32H750开发板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tls&#34;&gt;TLS&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;stdatomic&#34;&gt;stdatomic&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;数学库&#34;&gt;数学库&lt;/h3&gt;
&lt;p&gt;若SOC有FPU，并且配置 &lt;code&gt;ARCHCFG_FPU&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，则支持 &lt;code&gt;libm&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;其他libc的功能&#34;&gt;其他libc的功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; ctype: 字符类型&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; wchar: 多字节字符&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; iconv: 字符集转换&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; locale: 区域，暂时不支持&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; search: 查找&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; argz: 字符串数组&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; time: 时间，暂时不支持，需要底层提供RTC的驱动&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 多线程</title>
      <link>/docs/Note/Newlib/MultiThread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Newlib/MultiThread/</guid>
      <description>
        
        
        &lt;h2 id=&#34;编译配置&#34;&gt;编译配置&lt;/h2&gt;
&lt;p&gt;编译newlib时，需要增加配置 &lt;code&gt;--enable-newlib-multithread&lt;/code&gt; 开启多线程的支持，默认是开启的。&lt;/p&gt;
&lt;h2 id=&#34;_reent结构体&#34;&gt;_reent结构体&lt;/h2&gt;
&lt;p&gt;Newlib中的头文件 &lt;code&gt;reent.h&lt;/code&gt; 中，定义了结构体&lt;code&gt;struct _reent&lt;/code&gt; ，用于支持多线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，Newlib定义了一个全局的结构体变量 &lt;code&gt;impure_data&lt;/code&gt; ，
此结构体定义在 &lt;code&gt;newlib/libc/reent/impure.c&lt;/code&gt; ，并使用宏 &lt;code&gt;_REENT&lt;/code&gt; 表示它；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct _reent&lt;/code&gt; 定义了一些C标准的变量，例如 &lt;code&gt;errno&lt;/code&gt; 、 &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; 、 &lt;code&gt;stderr&lt;/code&gt; 等；&lt;/li&gt;
&lt;li&gt;为了支持多线程访问各自的 &lt;code&gt;errno&lt;/code&gt; 、 &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 等，需要在
线程对象结构体中增加结构体 &lt;code&gt;struct _reent&lt;/code&gt; 的成员；&lt;/li&gt;
&lt;li&gt;由于 &lt;code&gt;struct _reent&lt;/code&gt; 体积过大，玄武OS自己将实现 &lt;code&gt;struct _reent&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;Newlib中除了提供C标准中的函数，还定义带后缀 &lt;code&gt;_r&lt;/code&gt; 版本的函数，例如 &lt;code&gt;_read_r()&lt;/code&gt; ，
其中多一个参数 &lt;code&gt;struct _reent *&lt;/code&gt; 用于区分不同的线程。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: STM32移植说明</title>
      <link>/docs/Note/SOC/ARM-M/STM32/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/SOC/ARM-M/STM32/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;由于ST官方的STM32CubeMX能自动生成初始化芯片的代码，因此
XWOS中STM32的 &lt;strong&gt;架构描述层(ADL)&lt;/strong&gt; 、 &lt;strong&gt;CPU描述层(CDL)&lt;/strong&gt; 、 &lt;strong&gt;SOC描述层(SDL)&lt;/strong&gt; 的代码几乎
是一致的，唯一区别是 &lt;strong&gt;链接脚本&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;链接脚本&#34;&gt;链接脚本&lt;/h2&gt;
&lt;p&gt;STM32的链接脚本也是按照可复用的方式设计的，分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDL中的链接脚本：描述各个段如何分布在镜像文件中
&lt;ul&gt;
&lt;li&gt;STM32F0：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m0/stm32/f0.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32G0：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m0p/stm32/g0.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32F1：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m3/stm32/f1.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32L1：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m3/stm32/l1.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32F4：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m4/stm32/f4.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32L4：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m4/stm32/l4.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32F7：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m7/stm32/f7.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;STM32H7：&lt;code&gt;XWOS/xwcd/soc/arm/v7m/m7/stm32/h7.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他SOC还在持续增加中&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路板目录中的链接脚本：只描述内存区域&lt;/li&gt;
&lt;li&gt;WeActMiniStm32H750工程： &lt;code&gt;XWOS/xwbd/WeActMiniStm32H750/cfg/brd.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WeActMiniStm32H750Bootloader工程： &lt;code&gt;XWOS/xwbd/WeActMiniStm32H750Bootloader/cfg/brd.lds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他电路板还在持续增加中&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的电路板工程，只有Board中链接脚本中的Memory区域不同。&lt;/p&gt;
&lt;h3 id=&#34;lds的基本语法&#34;&gt;lds的基本语法&lt;/h3&gt;
&lt;h4 id=&#34;定义存储器区域&#34;&gt;定义存储器区域&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;名字&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;属性&lt;/span&gt;)&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; org &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; xxx, len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; xxx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; ,  &lt;code&gt;org&lt;/code&gt; ,  &lt;code&gt;ORIGIN&lt;/code&gt; : 表示定义存储器的起始地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; ,  &lt;code&gt;len&lt;/code&gt; ,  &lt;code&gt;LENGTH&lt;/code&gt; : 表示定义存储器长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORIGIN(x)&lt;/code&gt; : 表示取存储器x的起始地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LENGTH(x)&lt;/code&gt; : 表示取存储器x的长度&lt;/li&gt;
&lt;li&gt;属性:  &lt;code&gt;r&lt;/code&gt; 表示读， &lt;code&gt;w&lt;/code&gt; 表示写， &lt;code&gt;a&lt;/code&gt; 表示可申请， &lt;code&gt;x&lt;/code&gt; 表示可执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;xxx_ivt_lmr--xxx_ivt_vmr&#34;&gt;&lt;code&gt;xxx_ivt_lmr&lt;/code&gt; &amp;amp; &lt;code&gt;xxx_ivt_vmr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;XWOS的中断向量表区域，其中 &lt;strong&gt;LMR&lt;/strong&gt; 表示中断向量的加载地址区域，
也即是中断向量在Flash中的存储位置，VMR表示中断向量的运行地址区域，
也即是上电运行时的中断向量的地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;strong&gt;LMR&lt;/strong&gt; 与 &lt;strong&gt;VMR&lt;/strong&gt; 都指向Flash，且起始地址(org)与大小(len)完全一致，表示加载地址
就是运行地址，XWOS在初始化阶段不会对中断向量执行拷贝操作；&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;VMR&lt;/strong&gt; 指向RAM的某个地址，XWOS会在初始化阶段把Flash中的中断向量表拷贝到
&lt;strong&gt;VMR&lt;/strong&gt; 指定的RAM内，并设置ARM的VTOR寄存器；&lt;/li&gt;
&lt;li&gt;需要注意ARM的VTOR寄存器低7位(0~6)必须保持为0，因此VMR的起始地址也必须满足
此规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;firmware_info_mr&#34;&gt;&lt;code&gt;firmware_info_mr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;此段中包含镜像文件的一些基本信息，例如起始位置，结尾标志位置等，可用在升级固件功能中。&lt;/p&gt;
&lt;h4 id=&#34;code_mr&#34;&gt;&lt;code&gt;code_mr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;存放代码和常量的地方。&lt;/p&gt;
&lt;h4 id=&#34;xwos_data_mr&#34;&gt;&lt;code&gt;xwos_data_mr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;存放xwos全局数据的地方，这些变量在定义时带有修饰符： &lt;code&gt;__xwos_data&lt;/code&gt; ，此段可以
不存在，若不存在，需要在SDL中的链接脚本中将此段的数据放到 &lt;code&gt;data_mr&lt;/code&gt; 中。&lt;/p&gt;
&lt;h4 id=&#34;data_mr&#34;&gt;&lt;code&gt;data_mr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;存放全局变量的地方。当连接器ld安排完全局变量后，剩余的部分会交给XWOS
的&lt;strong&gt;默认的内核内存分配器&lt;/strong&gt;进行管理，用于为动态创建内核对象的API提供动态内存申请的接口。&lt;/p&gt;
&lt;h4 id=&#34;xwos_stk_mr&#34;&gt;&lt;code&gt;xwos_stk_mr&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;XWOS内核的栈内存，XWOS内核处理中断时会使用此内存作为函数的栈。&lt;/p&gt;
&lt;h2 id=&#34;soc的初始化&#34;&gt;SOC的初始化&lt;/h2&gt;
&lt;p&gt;STM32CubeMX生成的初始化代码，分别由 &lt;code&gt;stm32cube_lowlevel_init()&lt;/code&gt; 与 &lt;code&gt;stm32cube_init()&lt;/code&gt; 执行，
这两个函数在 &lt;a href=&#34;../../../../TechRefManual/BootFlow&#34;&gt;启动流程&lt;/a&gt;中分别
被 &lt;code&gt;xows_preinit&lt;/code&gt; 与 &lt;code&gt;xwos_postinit()&lt;/code&gt; 调用。&lt;/p&gt;
&lt;h2 id=&#34;stm32cubemx&#34;&gt;STM32CubeMX&lt;/h2&gt;
&lt;p&gt;STM32CubeMX工程是以 &lt;strong&gt;玄武模块&lt;/strong&gt; 中的 &lt;strong&gt;电路板模块&lt;/strong&gt; 的方式进行集成的，
详细可参考 &lt;a href=&#34;../../../../TechRefManual/BuildSystem&#34;&gt;构建系统&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;各个工程的STM32CubeMX工程如下（可在STM32CubeMX中打开）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WeActMiniStm32H750工程： &lt;code&gt;XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube/WeActMiniStm32H750.ioc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WeActMiniStm32H750Bootloader工程： &lt;code&gt;XWOS/xwbd/WeActMiniStm32H750Bootloader/bm/stm32cube/WeActMiniStm32H750Bootloader.ioc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断优先级&#34;&gt;中断优先级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XWOS对中断优先级的要求：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;切换上下文的中断为系统中最低优先级中断
切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;NVIC设置
&lt;ul&gt;
&lt;li&gt;设置 &lt;strong&gt;3&lt;/strong&gt; 个抢占优先级位和 &lt;strong&gt;1&lt;/strong&gt; 个子优先级位；&lt;/li&gt;
&lt;li&gt;SVC中断设置成 &lt;strong&gt;最高&lt;/strong&gt; 优先级，即 &lt;strong&gt;Preemption Priority&lt;/strong&gt; 为 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;PendSV中断设置成 &lt;strong&gt;最低&lt;/strong&gt; 优先级，即 &lt;strong&gt;Preemption Priority&lt;/strong&gt; 为 &lt;strong&gt;7&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;Systick中断设置成 &lt;strong&gt;最低&lt;/strong&gt; 优先级，即 &lt;strong&gt;Preemption Priority&lt;/strong&gt; 为 &lt;strong&gt;7&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;系统Fault的优先级设置为 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;其他中断的优先级只可在 &lt;strong&gt;1~6&lt;/strong&gt; 之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断向量表&#34;&gt;中断向量表&lt;/h3&gt;
&lt;p&gt;STM32CubeMX生成的代码中断向量表是放在 &lt;code&gt;startup.s&lt;/code&gt; 中，XWOS并不使用这个文件，因此需要
另外增加中断向量表。STM32型号太多，一个一个编辑工作量巨大，但观察STM32寄存器定义的
头文件（例如： &lt;code&gt;stm32h750xx.h&lt;/code&gt; ），可以发现 &lt;code&gt;IRQn_Type&lt;/code&gt; 这个枚举类型，其中列举了
所有的中断号，因此可使用脚本自动生成中断向量表的代码。&lt;/p&gt;
&lt;p&gt;本项目中提供了一个Emacs-Lisp脚本 &lt;code&gt;XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube/Tools/stm32ivt/stm32ivt.el&lt;/code&gt; 来完成这项工作，
用法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stm32ivt/stm32ivt.el
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;脚本执行完成后，会生成 &lt;code&gt;Core/Src/ivt.c&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwac&#34;&gt;xwac&lt;/h2&gt;
&lt;p&gt;电路板模块 &lt;code&gt;xwac&lt;/code&gt; 是适配性质的代码，是连接BSP与XWOS的纽带。
文件夹名中的 &lt;code&gt;ac&lt;/code&gt; 是 &lt;code&gt;Adaptation Code&lt;/code&gt; 的缩写。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fatfs&lt;/code&gt; ：fatfs底层设备驱动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lua&lt;/code&gt; ：lua的内存池&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newlib&lt;/code&gt; ：为标准C库newlib提供底层的支持
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem.c&lt;/code&gt; ： &lt;code&gt;malloc()&lt;/code&gt; 系列函数的内存池&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdio.c&lt;/code&gt; ：定义 &lt;code&gt;stdin&lt;/code&gt; 的输入设备， &lt;code&gt;stdout&lt;/code&gt; 、 &lt;code&gt;stderr&lt;/code&gt; 的输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;picolibc&lt;/code&gt; ：为标准C库picolibc提供底层的支持
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem.c&lt;/code&gt; ： &lt;code&gt;malloc()&lt;/code&gt; 系列函数的内存池&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdio.c&lt;/code&gt; ：定义 &lt;code&gt;stdin&lt;/code&gt; 的输入设备， &lt;code&gt;stdout&lt;/code&gt; 、 &lt;code&gt;stderr&lt;/code&gt; 的输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwds&lt;/code&gt; ：STM32的设备栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlib&lt;/code&gt; ：为XWOS通用库提供底层硬件支持，例如使用硬件CRC模块加速CRC运算、定义Log的输出设备等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos&lt;/code&gt; ：XWOS内核的Hook函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwrust&lt;/code&gt; ：Rust的内存池&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程本地存储</title>
      <link>/docs/Note/Picolibc/TLS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Picolibc/TLS/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;线程本地存储(TLS)是指线程私有的变量。&lt;/p&gt;
&lt;p&gt;C11标准开始支持线程本地存储，并引入 &lt;code&gt;_Thread_local&lt;/code&gt; 关键字，C2X标准引入 &lt;code&gt;thread_local&lt;/code&gt; 关键字。
gcc以及clang编译器还引入关键字 &lt;code&gt;__thread&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当用以上关键字定义全局变量时，每个线程都会拷贝一份此全局变量的副本，然后各自访问各自的副本。&lt;/p&gt;
&lt;h2 id=&#34;tls的模型&#34;&gt;TLS的模型&lt;/h2&gt;
&lt;p&gt;gcc以及clang对TLS的实现，有4种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=global-dynamic&lt;/code&gt; ：动态链接时使用，必须配合编译选项 &lt;code&gt;-fpic&lt;/code&gt; 才有效，要求给出 &lt;code&gt;__tls_get_addr()&lt;/code&gt; 的定义，
若不配合 &lt;code&gt;-fpic&lt;/code&gt; ，实际会变成 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=local-dynamic&lt;/code&gt; ：动态链接时使用，必须配合编译选项 &lt;code&gt;-fpic&lt;/code&gt; 才有效，要求给出 &lt;code&gt;__tls_get_addr()&lt;/code&gt; 的定义，
若不配合 &lt;code&gt;-fpic&lt;/code&gt; ，实际会变成 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ：静态链接时使用，要求给出 &lt;code&gt;__aeabi_read_tp()&lt;/code&gt; 的定义，此函数会返回线程 &lt;code&gt;.tdata&lt;/code&gt; 段的首地址。
然后从 &lt;code&gt;.got&lt;/code&gt; 段中获取TLS变量的 &lt;code&gt;OFFSET&lt;/code&gt; ， 即 &lt;code&gt;OFFSET = GOT[name]&lt;/code&gt; 。最终，变量的地址为 &lt;code&gt;__aeabi_read_tp() + OFFSET&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=local-exec&lt;/code&gt; ：静态链接时使用，要求给出 &lt;code&gt;__aeabi_read_tp()&lt;/code&gt; 的定义，此函数会返回线程 &lt;code&gt;.tdata&lt;/code&gt; 段的首地址。
然后TLS变量的 &lt;code&gt;OFFSET&lt;/code&gt; 是以立即数形式获取。最终，变量的地址为 &lt;code&gt;__aeabi_read_tp() + OFFSET&lt;/code&gt; 。
相对于 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; 少了一次内存访问的操作，效率是4种模型中最高的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwos-tls的实现&#34;&gt;XWOS TLS的实现&lt;/h2&gt;
&lt;p&gt;XWOS同时支持 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; 和 &lt;code&gt;-ftls-model=local-exec&lt;/code&gt;，因此，需要在链接脚本中将 &lt;code&gt;.got&lt;/code&gt; 段放入：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ld&#34; data-lang=&#34;ld&#34;&gt;        .got : {
                *(.got.plt) *(.igot.plt) *(.got) *(.igot)
        } &amp;gt; code_mr AT&amp;gt; code_mr
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: XWOS编译工具链安装指南</title>
      <link>/docs/UserManual/Env/XWTC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/Env/XWTC/</guid>
      <description>
        
        
        &lt;h2 id=&#34;xwtc&#34;&gt;XWTC&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xwtc&lt;/code&gt; 是XWOS编译的工具集合，可以从百度网盘下载，按照内部 &lt;strong&gt;说明.md&lt;/strong&gt; 安装就可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&#34;&gt;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;提取码：xwos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arm-none-eabi-gcc&lt;/li&gt;
&lt;li&gt;armllvm&lt;/li&gt;
&lt;li&gt;riscv-nuclei-elf-gcc&lt;/li&gt;
&lt;li&gt;nxp gcc toolchain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;windows版本还包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;windows-build-tools，包括一些工具，例如 &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;sed&lt;/code&gt; , &lt;code&gt;emacs&lt;/code&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ubuntu&#34;&gt;Ubuntu&lt;/h4&gt;
&lt;p&gt;若用户使用 &lt;strong&gt;Ubuntu&lt;/strong&gt; 作为开发环境，除了按照 &lt;strong&gt;说明.md&lt;/strong&gt; 安装之外，需要额外安装一些工具：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo dpkg-reconfigure dash &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 选择“否”&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install build-essential
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt-add-repository ppa:kelleyk/emacs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install emacs28 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 如果是无图形界面的服务器，改为emacs28-nox&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;windows&#34;&gt;windows&lt;/h4&gt;
&lt;p&gt;若用户使用 &lt;strong&gt;Windows&lt;/strong&gt; 作为开发环境，按照 &lt;strong&gt;说明.md&lt;/strong&gt; 设置环境变量即可。&lt;/p&gt;
&lt;h2 id=&#34;xwtc工具链的一些改动&#34;&gt;XWTC工具链的一些改动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;arm-none-eabi-gcc
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;增加了对TLS(Thread Loacl Storage)的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;armllvm
&lt;ul&gt;
&lt;li&gt;picolibc
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;使用正常的 &lt;code&gt;stdio&lt;/code&gt; 而非 &lt;code&gt;tinystdio&lt;/code&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;格式化字符串增加 &lt;code&gt;%b&lt;/code&gt;, &lt;code&gt;%lld&lt;/code&gt;, &lt;code&gt;%Lf&lt;/code&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将 &lt;code&gt;__errno&lt;/code&gt; 设置为函数 ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;支持多字节字符。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 集成与编译</title>
      <link>/docs/Note/Rust/Build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Rust/Build/</guid>
      <description>
        
        
        &lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;cargo&lt;/code&gt; 编译 &lt;strong&gt;staticlib&lt;/strong&gt; ，再与XWOS进行链接；&lt;/li&gt;
&lt;li&gt;由于XWOS支持ARM/PowerPC/RISC-V，因此需要通过 &lt;code&gt;--target=&lt;/code&gt; 选项来进行多平台的交叉编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS启动一个独立线程，调用RUST的主函数，由此进入RUST的世界；&lt;/li&gt;
&lt;li&gt;RUST的主函数与中间件是一个独立编译的玄武模块；&lt;/li&gt;
&lt;li&gt;由于RUST的编译依赖工具 &lt;code&gt;cargo&lt;/code&gt; ，可设计一个新的玄武模块编译规则调用 &lt;code&gt;cargo build&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;RUST玄武模块以 &lt;strong&gt;staticlib&lt;/strong&gt; 形式进行编译，最终与XWOS进行静态链接；&lt;/li&gt;
&lt;li&gt;因为会使用一些 &lt;strong&gt;unstable&lt;/strong&gt; 的特性，所以需安装nightly的RUST。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译方案&#34;&gt;编译方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应将 &lt;code&gt;cargo build&lt;/code&gt; 目标设定为 &lt;code&gt;PHONY&lt;/code&gt; ，即可每次 &lt;code&gt;make&lt;/code&gt; 时都调用 &lt;code&gt;cargo build&lt;/code&gt; ，
由 &lt;code&gt;cargo&lt;/code&gt; 来管理 &lt;code&gt;rust&lt;/code&gt; 源码的编译；&lt;/li&gt;
&lt;li&gt;环境变量 &lt;code&gt;$(RUST_TARGET)&lt;/code&gt; 在 &lt;code&gt;cpu.mk&lt;/code&gt; 中定义；&lt;/li&gt;
&lt;li&gt;其他编译选项，由 &lt;code&gt;.cargo/config&lt;/code&gt; 或 &lt;code&gt;build.rs&lt;/code&gt; 定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo build&lt;/code&gt; 编译结束后，再将输出的.a文件拷贝到输出目录；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装rust工具链&#34;&gt;安装rust工具链&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;官方指导&lt;/a&gt;安装Rust；&lt;/li&gt;
&lt;li&gt;切换镜像源
&lt;ul&gt;
&lt;li&gt;Ubuntu配置文件路径： &lt;code&gt;~/.cargo/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows配置文件路进： &lt;code&gt;C:\Users\用户名\.cargo\config&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.crates-io]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;https://github.com/rust-lang/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;replace-with = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;sjtu&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.ustc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;http://mirrors.ustc.edu.cn/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.sjtu]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;http://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Ubuntu安装unstable版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup install nightly
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.main-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.main-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.base-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7em-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7em-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv6m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add riscv32imac-unknown-none-elf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly component add rust-src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Windows安装unstable版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：Windows只支持使用 &lt;code&gt;gnu&lt;/code&gt; 版的工具链&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup install nightly-x86_64-pc-windows-gnu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.base-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv6m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add riscv32imac-unknown-none-elf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu component add rust-src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;rust中间件模板&#34;&gt;RUST中间件模板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目录结构：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;XWOS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── xwmd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └── rust
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        └── xwos
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ├── Cargo.lock
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ├── Cargo.toml
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ├── .cargo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            │   └── config
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ├── src
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            │   └── lib.rs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            └── xwmo.mk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[package]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;xwos&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;version = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;1.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;edition = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;2021&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[lib]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;xwos&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;crate-type = [&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;staticlib&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[dependencies]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.cargo/config.toml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[unstable]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;build-std = [&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;core&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;alloc&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;std&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;panic_abort&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src/lib.rs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#![feature(restricted_std)]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#[no_mangle]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;pub&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;unsafe&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwrust_main&lt;/span&gt;()&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmo.mk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.rust.mk&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;编译规则 &lt;code&gt;xwbs/xwmo.rust.mk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lua开发环境</title>
      <link>/docs/Note/Lua/env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Lua/env/</guid>
      <description>
        
        
        &lt;h2 id=&#34;安装环境&#34;&gt;安装环境&lt;/h2&gt;
&lt;h3 id=&#34;lua&#34;&gt;Lua&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://www.lua.org/ftp/&#34;&gt;lua&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#b8860b&#34;&gt;INSTALL_TOP&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;安装路径 install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;包管理器luarocks&#34;&gt;包管理器Luarocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://luarocks.github.io/luarocks/releases/&#34;&gt;luarocks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./configure --prefix&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;安装路径
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;文档生成工具&#34;&gt;文档生成工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://github.com/lunarmodules/LDoc.git&#34;&gt;LDoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;安装-1&#34;&gt;安装&lt;/h5&gt;
&lt;p&gt;修改 &lt;code&gt;Makefile&lt;/code&gt; 中的 &lt;code&gt;LUA_SHAREDIR&lt;/code&gt; 为 &lt;code&gt;$(LUA_PREFIX)/share/lua/5.4&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;luarocks install penlight
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 开发环境</title>
      <link>/docs/UserManual/Board/STM32/Env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/Board/STM32/Env/</guid>
      <description>
        
        
        &lt;h2 id=&#34;安装xwos的编译环境&#34;&gt;安装XWOS的编译环境&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&#34;../../../Env/XWTC&#34;&gt;XWTC安装指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;stm32cubeide&#34;&gt;STM32CubeIDE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;URL： &lt;a href=&#34;https://www.st.com/en/development-tools/stm32cubeide.html&#34;&gt;STM32CubeIDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu中需要安装JRE： &lt;code&gt;sudo apt install openjdk-11-jdk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装其他调试器插件
&lt;ul&gt;
&lt;li&gt;菜单： &lt;code&gt;&amp;quot;Help&amp;quot; -&amp;gt; &amp;quot;Install New Software...&amp;quot; -&amp;gt; &amp;quot;Add...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仓库： &lt;code&gt;http://mirrors.ustc.edu.cn/eclipse/embed-cdt/updates/v6/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J-Link Debugging&lt;/code&gt; ：JLink + Segger的JLinkGDBServer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OpenOCD Debugging&lt;/code&gt; ：DAPLink/JLink + OpenOCD&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PyOCD Debugging&lt;/code&gt; ：DAPLink/JLink/STLink + PyOCD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stm32cubemx&#34;&gt;STM32CubeMX&lt;/h2&gt;
&lt;p&gt;STM32工程的 &lt;code&gt;.ioc&lt;/code&gt; 文件需要使用 &lt;strong&gt;STM32CubeMX&lt;/strong&gt; 打开并进行配置。
&lt;strong&gt;STM32CubeIDE&lt;/strong&gt; 只作为编译调试的环境，不进行驱动的配置以及源码的生成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL：&lt;a href=&#34;https://www.st.com/en/development-tools/stm32cubemx.html&#34;&gt;STM32CubeMX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rust开发环境&#34;&gt;Rust开发环境&lt;/h2&gt;
&lt;p&gt;STM32支持使用Rust语言开发，参考 &lt;a href=&#34;../../../Env/Rust&#34;&gt;Rust开发环境指南&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;stm32cubeid的rust插件&#34;&gt;STM32CubeID的Rust插件&lt;/h3&gt;
&lt;p&gt;注意不要选择最新版本的插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;菜单： &lt;code&gt;&amp;quot;Help&amp;quot; -&amp;gt; &amp;quot;Install New Software...&amp;quot; -&amp;gt; &amp;quot;Add...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仓库： &lt;code&gt;http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插件： &lt;code&gt;Corrosion: Rust edition in Eclipse IDE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 位操作库</title>
      <link>/docs/TechRefManual/Xwlib/Xwbop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Xwbop/</guid>
      <description>
        
        
        &lt;h2 id=&#34;位操作&#34;&gt;位操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了位操作模板库， &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; 中定义的
各种 &lt;strong&gt;非函数指针类型&lt;/strong&gt; 都可使用位操作。位操作函数模板包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbop_s1m()&lt;/code&gt; ：将数据掩码部分的位全部置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_c0m()&lt;/code&gt; ：将数据掩码部分的位全部清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_x1m()&lt;/code&gt; ：将数据掩码部分的位全部翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_rbit()&lt;/code&gt; ：将数据的位镜面翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_re()&lt;/code&gt; ：将数据的大小端翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_ffs()&lt;/code&gt; ：在数据中从最低位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_fls()&lt;/code&gt; ：在数据中从最高位起查找第一个被置1的位1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_ffz()&lt;/code&gt; ：在数据中从最低位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_flz()&lt;/code&gt; ：在数据中从最高位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_weight()&lt;/code&gt; ：统计数据中1的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有位操作函数的第一个参数均为 &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; ，
第二个参数是数据或数据的指针，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwssq_t&lt;/span&gt; idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从最低位开始查找&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0&amp;#34;中第一个被置1的位，结果为-1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_ffs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从最低位开始查找&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0xF0&amp;#34;中第一个被置1的位，结果为4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_ffs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0xF0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 将&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0xAA&amp;#34;进行镜像翻转，结果为0x55 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt; rdata &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_rbit&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0xAA&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;位图操作&#34;&gt;位图操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了基本类型 &lt;code&gt;xwbmp_t&lt;/code&gt; ，用于定义位图，位图是 &lt;code&gt;xwbmp_t&lt;/code&gt; 的数组。
用户可以声明任意位数的位图，XWOS提供了函数集方便用户操作位图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_declare()&lt;/code&gt; ：声明位图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_assign()&lt;/code&gt; ：赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_cmp()&lt;/code&gt; ：比较两个位图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1all()&lt;/code&gt; ：所有位置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0all()&lt;/code&gt; ：所有位清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1i()&lt;/code&gt; ：将位图中某位置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1m()&lt;/code&gt; ：将位图中掩码部分置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0i()&lt;/code&gt; ：将位图中某位清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0m()&lt;/code&gt; ：将位图中掩码部分清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_x1i()&lt;/code&gt; ：将位图中某位翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_x1m()&lt;/code&gt; ：将位图中掩码部分翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1i()&lt;/code&gt; ：测试位图中的某位是否为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1ma()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1ma_then_c0m()&lt;/code&gt; ：测试位图中掩码部分是否全部为1，如果是，就将掩码部分全部清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1mo()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1mo_then_c0m()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为1，如果是，就将掩码部分全部清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0ma()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0ma_then_s1m()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;0&lt;/strong&gt; ，如果是，就将掩码部分全部置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0mo()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0mo_then_s1m()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;0&lt;/strong&gt; ，如果是，就将掩码部分全部置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_not()&lt;/code&gt; ：非运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_and()&lt;/code&gt; ：与运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_or()&lt;/code&gt; ：或运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_xor()&lt;/code&gt; ：异或运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_ffs()&lt;/code&gt; ：从最低位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_fls()&lt;/code&gt; ：从最高位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_ffz()&lt;/code&gt; ：从最低位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_flz()&lt;/code&gt; ：从最高位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_weight()&lt;/code&gt; ：统计 &lt;strong&gt;1&lt;/strong&gt; 的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwbop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwbop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 消息队列</title>
      <link>/docs/TechRefManual/Isc/Xwmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/Xwmq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的消息队列（xwmq）采用双循环链表实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart LR
    Head --&amp;gt; Msg1 --&amp;gt; Head
    Msg1 --&amp;gt; Msg2 --&amp;gt; Msg1
    Msg2 --&amp;gt; Msg3 --&amp;gt; Msg2
    Msg3 --&amp;gt; Msg4 --&amp;gt; Msg3
    Msg4 --&amp;gt; Msg5 --&amp;gt; Msg4
    Msg5 --&amp;gt; Msg6 --&amp;gt; Msg5
    Msg6 --&amp;gt; Msg7 --&amp;gt; Msg6
    Msg7 --&amp;gt; Head --&amp;gt; Msg7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息可发送到队列的头部，也可以发送到队列的尾部。
消息可以从队列的头部接收，也可以从队列的尾部接收。&lt;/p&gt;
&lt;h3 id=&#34;消息队列的消息&#34;&gt;消息队列的消息&lt;/h3&gt;
&lt;p&gt;消息队列的每个节点是 &lt;a href=&#34;../../../../api/structxwmq__msg.html&#34;&gt;&lt;code&gt;struct xwmq_msg&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq_msg {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; data;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; topic;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwlib_bclst_node node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; ：消息的数据，只能传递一个指针长度的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topic&lt;/code&gt; ：消息的主题，由用户自定义主题的含义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt; ：链表节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息槽&#34;&gt;消息槽&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;消息槽&lt;/strong&gt; 是消息队列初始化时，用户定义的消息数组。消息队列中的消息数量最多等于消息槽的数量。&lt;/p&gt;
&lt;h3 id=&#34;消息队列对象与对象描述符描述符&#34;&gt;消息队列对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;消息队列对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，消息队列对象也用 &lt;strong&gt;消息队列对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwmq__d.html&#34;&gt;&lt;code&gt;xwmq_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;消息队列对象描述符由 &lt;strong&gt;消息队列对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mq; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 消息队列对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwmq_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;消息队列的消息只能发送一个和指针长度一样的数据。
如果需要发送比较大的数据，只能将数据的缓冲区的首地址发送出去。
若数据缓冲区是通过向动态内存管理申请而来，用户需要特别小心，数据缓冲区不能被意外地释放掉。&lt;/p&gt;
&lt;h2 id=&#34;消息队列的静态初始化销毁&#34;&gt;消息队列的静态初始化、销毁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga51603f04fac6de40ea6726d69b264cc7&#34;&gt;&lt;code&gt;xwmq_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;初始化消息队列时，需要预先定义消息数组作为消息槽。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq brd_mq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq_msg brd_mq_txq[&lt;span style=&#34;color:#666&#34;&gt;16&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 最多16个消息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;brd_init_xwmq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwmq_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;brd_mq, brd_mq_txq, &lt;span style=&#34;color:#00a000&#34;&gt;xw_array_size&lt;/span&gt;(brd_mq_txq));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga57fec3e151fbf8044a2b7092ab2972b3&#34;&gt;&lt;code&gt;xwmq_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列的动态创建删除&#34;&gt;消息队列的动态创建、删除&lt;/h2&gt;
&lt;p&gt;XWOS并未提供基于动态内存管理的创建与删除CAPI。&lt;/p&gt;
&lt;h2 id=&#34;发送消息&#34;&gt;发送消息&lt;/h2&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt; 是指将消息发送到消息队列的 &lt;strong&gt;尾端&lt;/strong&gt; ，发送之前需要获取一个可用的消息槽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#gad8d2b0b29234d2959a05eeb67a23ff45&#34;&gt;&lt;code&gt;xwmq_eq()&lt;/code&gt;&lt;/a&gt; ：等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8359c9ba02c8fb2a74e6c4c6094d94cc&#34;&gt;&lt;code&gt;xwmq_eq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8a32f1b107baef4bc25957bca4d4bddd&#34;&gt;&lt;code&gt;xwmq_eq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga30b3fc4cf9323d3597eb8a383bdf611f&#34;&gt;&lt;code&gt;xwmq_tryeq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息槽，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插队&#34;&gt;插队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;插队&lt;/strong&gt; 是指将消息发送到消息队列的 &lt;strong&gt;首端&lt;/strong&gt; ，发送之前需要获取一个可用的消息槽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga18b4d97f9de46feb6eebd197738aabf6&#34;&gt;&lt;code&gt;xwmq_jq()&lt;/code&gt;&lt;/a&gt; ：等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga0eb1aa3f3e83b696612a7cd9cc90a6f2&#34;&gt;&lt;code&gt;xwmq_jq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga3c6e22dce3a927f790d95f1e294c5789&#34;&gt;&lt;code&gt;xwmq_jq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga706a753c885996d85ec7fbf6d7461385&#34;&gt;&lt;code&gt;xwmq_tryjq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息槽，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接收消息&#34;&gt;接收消息&lt;/h2&gt;
&lt;h3 id=&#34;首端离队&#34;&gt;首端离队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首端离队&lt;/strong&gt; 是指从消息队列的 &lt;strong&gt;首端&lt;/strong&gt; 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga6dac123dd10ceaf0f24181b66d49d39a&#34;&gt;&lt;code&gt;xwmq_dq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga9b11a75d7c8d792d305154b32c3dedee&#34;&gt;&lt;code&gt;xwmq_dq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga98fe6e199b379e49ed413db1435f5b3a&#34;&gt;&lt;code&gt;xwmq_dq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga113bc97ec8121f3eb884e8da900497eb&#34;&gt;&lt;code&gt;xwmq_trydq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端离队&#34;&gt;尾端离队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;尾端离队&lt;/strong&gt; 是指从消息队列的 &lt;strong&gt;尾端&lt;/strong&gt; 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga79b5a6769a655a4e5946f3d60729b342&#34;&gt;&lt;code&gt;xwmq_rq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#gaacdb3c6bfb639e6d2444f479e9557c38&#34;&gt;&lt;code&gt;xwmq_rq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga1ebf67fde973c23ec718d35258dd7ee1&#34;&gt;&lt;code&gt;xwmq_rq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga7c48b58030cf580f089d2cb42bc644fd&#34;&gt;&lt;code&gt;xwmq_tryrq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列对象的生命周期管理&#34;&gt;消息队列对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;消息队列对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
消息队列对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8b86e4a1725d0d9363ee8a31095222c9&#34;&gt;&lt;code&gt;xwmq_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga3a7d5f642c3629ebfcf03e7721efd4c2&#34;&gt;&lt;code&gt;xwmq_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga1357e7c300f83638ef7758e1395e423d&#34;&gt;&lt;code&gt;xwmq_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga57efc774777e38855532c6f6be1e4504&#34;&gt;&lt;code&gt;xwmq_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwmd__isc__xwmq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwmd/isc/xwmq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号量</title>
      <link>/docs/TechRefManual/Sync/Sem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Sem/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;信号量是操作系统比较底层的同步机制，是一个带有 &lt;strong&gt;等待队列&lt;/strong&gt; 的计数器。&lt;/p&gt;
&lt;p&gt;信号量中包含一个整数计数器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当信号量的值等于 &lt;strong&gt;0&lt;/strong&gt; 时，线程们就在 &lt;strong&gt;等待队列&lt;/strong&gt; 中等待信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; 时，可以唤醒一个正在等待的线程。线程被唤醒后会取走一个值，信号量的值减少 &lt;strong&gt;1&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当信号量的值小于 &lt;strong&gt;0&lt;/strong&gt; ，信号量处于 &lt;strong&gt;冻结&lt;/strong&gt; 状态，理论中的信号量不存在此状态，这是XWOS的扩张。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任意上下文都可增加信号量的值，这个操作被称为 &lt;strong&gt;发布&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;信号量常常用于在中断中唤醒一个线程，并将耗时较长的操作放在线程中执行。可减少中断上下文的执行时间，增加中断吞吐量，降低中断延迟。&lt;/p&gt;
&lt;p&gt;XWOS内核的信号量有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管道信号量(PipelineSemaphore)：对所有阻塞在其等待队列中的线程按照先进先出(FIFO)的策略调度，
即当信号量可用时，最先进入等待队列中的线程将优先获得信号量。&lt;/li&gt;
&lt;li&gt;实时信号量(ReltimeSemaphore)：对所有阻塞在其等待队列中的线程按照优先级进行调度，即高优先级
的线程总是最先获得信号量，同优先级的线程按先进先出(FIFO)的策略调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统抽象层(OSAL)的CAPI只封装了一种信号量，当系统配置文件中同时配置了管道信号量与实时信号量时， &lt;strong&gt;优先使用实时信号量&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;信号量对象与对象描述符描述符&#34;&gt;信号量对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;信号量对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，信号量对象也用 &lt;strong&gt;信号量对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__sem__d.html&#34;&gt;&lt;code&gt;xwos_sem_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;信号量对象描述符由 &lt;strong&gt;信号量对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sem &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sem; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 信号量对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_sem_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;信号量的初始化销毁与动态创建删除&#34;&gt;信号量的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;p&gt;信号量创建时需要指定两个参数： &lt;strong&gt;初始值&lt;/strong&gt; 和 &lt;strong&gt;最大值&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gaef37596ed9c49312579530b2218150ad&#34;&gt;&lt;code&gt;xwos_sem_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga91a3f44977a865f10e9a46f13e261d3a&#34;&gt;&lt;code&gt;xwos_sem_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gadebdd16a61933d67d2702355fcd543e2&#34;&gt;&lt;code&gt;xwos_sem_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的信号量： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga5bac50165dee16acce035f3a88d96d1b&#34;&gt;&lt;code&gt;xwos_sem_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;发布信号量&#34;&gt;发布信号量&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gaf6f291eaa8c268dccb6ebc675a24755b&#34;&gt;&lt;code&gt;xwos_sem_post()&lt;/code&gt;&lt;/a&gt; 在 &lt;strong&gt;任意&lt;/strong&gt; 上下文增加信号量的值。
当信号量的值大与 &lt;strong&gt;0&lt;/strong&gt; 时，会唤醒信号量等待队列中的一个线程。被唤醒的线程会取走一个值，使得信号量的计数器减1。&lt;/p&gt;
&lt;h2 id=&#34;等待信号量&#34;&gt;等待信号量&lt;/h2&gt;
&lt;p&gt;当信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; 时，可以直接取走一个，此时信号量的值减 &lt;strong&gt;1&lt;/strong&gt; ；
当信号量的值等于 &lt;strong&gt;0&lt;/strong&gt; 时，获取信号量的线程就只能阻塞等待，XWOS提供四种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga5a7b38f68e2fc5159909a1eb4b7db7a2&#34;&gt;&lt;code&gt;xwos_sem_wait()&lt;/code&gt;&lt;/a&gt; ：等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gab9fce6b4dc3add4c714dfa1c8041593f&#34;&gt;&lt;code&gt;xwos_sem_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga794e05587874027d02d0e4c87f9c2893&#34;&gt;&lt;code&gt;xwos_sem_wait_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga453bbb4747cdd5cc94ddb9b988ee0866&#34;&gt;&lt;code&gt;xwos_sem_trywait()&lt;/code&gt;&lt;/a&gt; ：尝试获取信号量，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读取信号量的状态&#34;&gt;读取信号量的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号量中计数器的最大值可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga31696885ee6e7bfe699273225f061a7e&#34;&gt;&lt;code&gt;xwos_sem_get_max()&lt;/code&gt;&lt;/a&gt; 读取。这个最大值是在信号量初始化或创建时设置的。&lt;/li&gt;
&lt;li&gt;信号量中计数器的值可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga25b85b8a30ba1f3f1453feecd7a71343&#34;&gt;&lt;code&gt;xwos_sem_get_value()&lt;/code&gt;&lt;/a&gt; 读取。此CAPI只读取，不会改变信号量的值，也不会等待信号量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;冻结与解冻&#34;&gt;冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;冻结&#34;&gt;冻结&lt;/h3&gt;
&lt;p&gt;信号量可以使用 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga9f215ee967e9f3dbd1d7e34402109849&#34;&gt;&lt;code&gt;xwos_sem_freeze()&lt;/code&gt;&lt;/a&gt; 进行 &lt;strong&gt;冻结&lt;/strong&gt;，
被冻结的信号量的值为负数，不影响对信号量的 &lt;strong&gt;等待&lt;/strong&gt; 操作。但不能 &lt;strong&gt;发布&lt;/strong&gt; 信号量。&lt;/p&gt;
&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gadbbb35963b95d865ddb392a97639ec87&#34;&gt;&lt;code&gt;xwos_sem_thaw()&lt;/code&gt;&lt;/a&gt; 可将已经冻结的信号量 &lt;strong&gt;解冻&lt;/strong&gt; 。
信号量 &lt;strong&gt;解冻&lt;/strong&gt; 后，值被重置为0，此时可重新开始发布信号量。&lt;/p&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4a04b2c6003ed59a0f82c7b8ed8c7f68&#34;&gt;&lt;code&gt;xwos_sem_bind()&lt;/code&gt;&lt;/a&gt; 将信号量绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当 &lt;strong&gt;发布&lt;/strong&gt; 信号量时，信号量会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的信号量可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4aab3913939aa6cfa040af1039e564d5&#34;&gt;&lt;code&gt;xwos_sem_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;信号量对象的生命周期管理&#34;&gt;信号量对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;信号量对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
信号量对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga70b16e65e7f3b8bbb87435804f1829d3&#34;&gt;&lt;code&gt;xwos_sem_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga83a3b567eb40632d954a35b98ecf1950&#34;&gt;&lt;code&gt;xwos_sem_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gabd6b221831f9154af4061281e4de3bbe&#34;&gt;&lt;code&gt;xwos_sem_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga2fd69e5ea645814fa3a52241167a9e1e&#34;&gt;&lt;code&gt;xwos_sem_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__sem.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sem.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号量</title>
      <link>/docs/UserManual/App/Sync/Sem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Sync/Sem/</guid>
      <description>
        
        
        &lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../../capi/group__xwos__sync__sem.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sem.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 自旋锁</title>
      <link>/docs/TechRefManual/Lock/Spinlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Spinlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;自旋锁是多核系统中为防止多个处理器同时访问公共的内存区域（称为临界区）而引入的一种锁。
当一个CPU获得自旋锁并访问临界区时，其他CPU只能 &lt;strong&gt;自旋&lt;/strong&gt; 等待锁。
所谓 &lt;strong&gt;自旋&lt;/strong&gt; ，是指不断循环测试 &lt;strong&gt;锁&lt;/strong&gt; 是否已经解开。&lt;/p&gt;
&lt;p&gt;自旋锁只是为SMP的场景设计的一种锁机制。在单核(UP)系统中，并不需要自旋锁。
但为了软件接口的统一，实现了虚假的自旋锁，只是对关闭抢占、中断底半部或中断的封装。&lt;/p&gt;
&lt;p&gt;自旋锁还伴随其他操作：内存屏障，关闭调度器的抢占，关闭中断底半部，关闭中断等。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自旋锁内包含内存内存屏障操作，内存屏障会降低CPU的性能；&lt;/li&gt;
&lt;li&gt;自旋锁不区分读和写的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用自旋锁&#34;&gt;使用自旋锁&lt;/h2&gt;
&lt;h3 id=&#34;自旋锁的初始化&#34;&gt;自旋锁的初始化&lt;/h3&gt;
&lt;p&gt;自旋锁是基于原子操作指令实现的，自旋锁结构体很小，核心数据是一个CPU指令能操作的基本数据类型，因此不提供动态创建和删除方法。
用户可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gac8bbb82a3177f919e10ef3c3d21c7608&#34;&gt;&lt;code&gt;xwos_splk_init()&lt;/code&gt;&lt;/a&gt; 初始化自旋锁。&lt;/p&gt;
&lt;h3 id=&#34;多锁&#34;&gt;多锁&lt;/h3&gt;
&lt;p&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁保护临界区时，上锁和解锁顺序必须 &lt;strong&gt;保持一致&lt;/strong&gt; ，否则会导致死锁。&lt;/p&gt;
&lt;h3 id=&#34;锁模式&#34;&gt;锁模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;临界区只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。临界区内，只会关闭抢占。
可以理解为在线程层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; 。临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
临界区内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga80e1248f482959ad664f367dd6a2123e&#34;&gt;&lt;code&gt;xwos_splk_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gad8cae0c2e4a9956f9df7b3118b6db534&#34;&gt;&lt;code&gt;xwos_splk_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga7c45ee96acf66e3ab1aba48a0f49f1c4&#34;&gt;&lt;code&gt;xwos_splk_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
临界区内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga3011217ec5d1cba45824484f507dce77&#34;&gt;&lt;code&gt;xwos_splk_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga5a37d2c7c27a7507392f15eeb03d2a02&#34;&gt;&lt;code&gt;xwos_splk_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gaba92901efc65f4e61a3e364b29d6e10c&#34;&gt;&lt;code&gt;xwos_splk_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁时，嵌套的临界区对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
临界区内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gad393963b449be923d8af40538b9befdf&#34;&gt;&lt;code&gt;xwos_splk_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga74fc2498076cc0f1b4810bd1ad9d4bff&#34;&gt;&lt;code&gt;xwos_splk_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gaa83b4a8f3340ddf35346dbedf9ce3979&#34;&gt;&lt;code&gt;xwos_splk_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
临界区内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga7e50b3ee8f605b1963bf7223c249da28&#34;&gt;&lt;code&gt;xwos_splk_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga1946f1240fb699cb9d6a252c76b0eb77&#34;&gt;&lt;code&gt;xwos_splk_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga94b35ab4ed1799807411bcfdcd1a3950&#34;&gt;&lt;code&gt;xwos_splk_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁时，嵌套的临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
临界区内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga92a795c788a274e6fb545b6d4226b01b&#34;&gt;&lt;code&gt;xwos_splk_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga17b92af6dfcf155366f46bb83f1b8ff5&#34;&gt;&lt;code&gt;xwos_splk_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga58441e6006fe5d402e06f5caaab42092&#34;&gt;&lt;code&gt;xwos_splk_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
临界区内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga3c50609a0c759cb526502a27937aab47&#34;&gt;&lt;code&gt;xwos_splk_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga6d6a918600518b0ed891937ec378087a&#34;&gt;&lt;code&gt;xwos_splk_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gafbf75863c2f6323d6de84e4b1ce6c18a&#34;&gt;&lt;code&gt;xwos_splk_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;为什么没有 &lt;strong&gt;保存与恢复抢占&lt;/strong&gt; 和 &lt;strong&gt;保存与恢复中断底半部&lt;/strong&gt; 形式的CAPI ？
因为 &lt;strong&gt;关闭与打开抢占&lt;/strong&gt; 和 &lt;strong&gt;保存与恢复中断底半部&lt;/strong&gt; 是一种可重入的的 &lt;strong&gt;锁&lt;/strong&gt; ， &lt;strong&gt;关闭&lt;/strong&gt; 了多少次，对应的就要 &lt;strong&gt;打开&lt;/strong&gt; 多少次。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/spinlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 自旋锁</title>
      <link>/docs/UserManual/App/Lock/Spinlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Lock/Spinlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__lock__spinlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/spinlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Rust方案初验证</title>
      <link>/docs/Note/Rust/Bringup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Rust/Bringup/</guid>
      <description>
        
        
        &lt;h2 id=&#34;rust的std库&#34;&gt;Rust的std库&lt;/h2&gt;
&lt;p&gt;RUST的标准库包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;std.svg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在嵌入式系统中，比较有用的是 &lt;code&gt;core&lt;/code&gt; 与 &lt;code&gt;alloc&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;虽然在嵌入式环境中，可以通过 &lt;code&gt;#![feature(restricted_std)]&lt;/code&gt; 强行使用Rust的std库，
但随着功能的增加，问题也会越来越多，故转向使用 &lt;code&gt;#![no_std]&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;.cargo/config.toml&lt;/code&gt; 增加编译：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[unstable]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;build-std = [&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;core&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;alloc&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;global_allocator&#34;&gt;global_allocator&lt;/h2&gt;
&lt;p&gt;可用来实现自己的内存分配函数的属性，可参考文档&lt;a href=&#34;https://doc.rust-lang.org/std/alloc/index.html&#34;&gt;std::alloc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://lib.rs/&#34;&gt;lib.rs&lt;/a&gt;上可以搜索到&lt;a href=&#34;https://lib.rs/crates/newlib-alloc&#34;&gt;newlib-alloc&lt;/a&gt;，可直接用。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Cargo.toml&lt;/code&gt; 中增加&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[dependencies]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libc = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;0.2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;newlib-alloc = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libc-print = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译libc时需要条件选择 &lt;code&gt;newlib&lt;/code&gt; ，在 &lt;code&gt;.cargo/config&lt;/code&gt; 增加：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[build]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustflags = [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;--cfg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;--cfg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;target_env=\&amp;#34;newlib\&amp;#34;&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编写测试代码&#34;&gt;编写测试代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#![no_std]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#![feature(alloc_error_handler)]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;use&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;core::panic::PanicInfo;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#[panic_handler]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;panic&lt;/span&gt;(_info: &lt;span style=&#34;color:#a2f&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#00f&#34;&gt;PanicInfo&lt;/span&gt;)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;loop&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;use&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;newlib_alloc;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#[global_allocator]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#800&#34;&gt;GLOBAL_ALLOCATOR&lt;/span&gt;: &lt;span style=&#34;color:#00f&#34;&gt;newlib_alloc&lt;/span&gt;::Alloc&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;newlib_alloc::Alloc;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#[alloc_error_handler]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;alloc_error_handler&lt;/span&gt;(_layout: &lt;span style=&#34;color:#00f&#34;&gt;core&lt;/span&gt;::alloc::Layout)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;loop&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;use&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;libc_print::std_name::println;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;crate&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;alloc;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;use&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;alloc::vec::&lt;span style=&#34;color:#a2f&#34;&gt;Vec&lt;/span&gt;;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#[no_mangle]&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;pub&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;unsafe&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;rust_main&lt;/span&gt;()&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;v&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;Vec&lt;/span&gt;::new();&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;v.push(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;v.push(&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;v.push(&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;v.push(&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;println!(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;RUST XWOS!&amp;#34;&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;x&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;in&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;v.iter()&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;        &lt;/span&gt;println!(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;x: &lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;x);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;串口终端输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;RustBringup.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调试过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;RustInEclipse.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;
&lt;h4 id=&#34;硬件环境&#34;&gt;硬件环境&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../quick-guide/STM32/WeActMiniStm32H750&#34;&gt;WeActMiniStm32H750&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MCU：STM32H750&lt;/li&gt;
&lt;li&gt;说明：此工程已对接好newlib(如 &lt;code&gt;malloc()&lt;/code&gt; 、 &lt;code&gt;printf()&lt;/code&gt; 等标准函数)，可为Rust的库提供底层支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调试环境&#34;&gt;调试环境&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;IDE：&lt;a href=&#34;https://www.st.com/en/development-tools/stm32cubeide.html&#34;&gt;STM32CubeIDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;需要增加Rust插件：Corrosion: Rust edition in Eclipse IDE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实验代码&#34;&gt;实验代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代码仓库： &lt;code&gt;git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; XWOS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git pull
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout -b rust-bringup f8fcad24daa4912e4de0886c30e02343b6045dab
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: C&#43;&#43;</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/C&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/C&#43;&#43;/</guid>
      <description>
        
        
        &lt;p&gt;XWOS内核是使用纯C语言开发的，不依赖C++的标准库。
用户可在线程中使用C++语言以及C++标准库，C++标准库由编译器提供，不完全功能清单如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; g++, libstdc++, libsupc++
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; new, delete, new[], delete[], placement new, aligned new (C++17)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 容器
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; array&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; vector&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; deque&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; map, multimap, unordered_map, unordered_multimap&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; set, multiset, unordered_set, unordered_multiset&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; list, forward_list&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; stack, queue, priority_queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; I/O stream&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; string&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; atomic&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; RTTI&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; exception&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; unwind&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; chrono&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; thread&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; mutex&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; condition_variable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm(clang++), libc++, libc++abi
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; new, delete, new[], delete[], placement new, aligned new (C++17)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 容器
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; array&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; vector&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; deque&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; map, multimap, unordered_map, unordered_multimap&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; set, multiset, unordered_set, unordered_multiset&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; list, forward_list&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; stack, queue, priority_queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; I/O stream&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; string&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; atomic&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; RTTI&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; exception&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; unwind&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; chrono&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; thread&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; mutex&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; condition_variable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 动态内存管理</title>
      <link>/docs/Note/Newlib/MM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Newlib/MM/</guid>
      <description>
        
        
        &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS不使用Newlib提供的动态内存管理的算法。使用的是内存池算法：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;移植方法&#34;&gt;移植方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重写Newlib的函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_malloc_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_realloc_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_calloc_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; elem_nr, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; elem_sz);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_memalign_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; alignment, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_valloc_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_pvalloc_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;_free_r&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; r, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; p);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;源码路径： &lt;code&gt;xwmd/libc/newlibac/mem.c&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还没实现的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mallopt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc_usable_size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc_stats&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mallinfo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 动态内存管理</title>
      <link>/docs/Note/Picolibc/MM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Picolibc/MM/</guid>
      <description>
        
        
        &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS不使用picolibc提供的动态内存管理的算法。使用的是内存池算法：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;移植方法&#34;&gt;移植方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;源码路径：&lt;code&gt;xwmd/libc/picolibcac/mem.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重写picolibc的函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;malloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;realloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;calloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; elem_nr, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; elem_sz);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;memalign&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; alignment, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;valloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;pvalloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;free&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;getpagesize&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;无需重写的函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;posix_memalign&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; memptr, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; align, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; size); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// picolibc提供基于memalign实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;aligned_alloc&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; alignment, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; size); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// picolibc提供基于memalign实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;还没实现的函数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mallopt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc_usable_size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;malloc_stats&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mallinfo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Rust开发环境指南</title>
      <link>/docs/UserManual/Env/Rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/Env/Rust/</guid>
      <description>
        
        
        &lt;h2 id=&#34;rust的开发工具&#34;&gt;Rust的开发工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;官方指导&lt;/a&gt;安装 &lt;strong&gt;RUST&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;切换镜像源
&lt;ul&gt;
&lt;li&gt;Ubuntu配置文件路径： &lt;code&gt;~/.cargo/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows配置文件路进： &lt;code&gt;C:\Users\用户名\.cargo\config&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.crates-io]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;https://github.com/rust-lang/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;replace-with = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;ustc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.ustc]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;http://mirrors.ustc.edu.cn/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.tuna]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[source.sjtu]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;registry = &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;http://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Ubuntu安装unstable版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup install nightly
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.main-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.main-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv8m.base-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7em-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv7em-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add thumbv6m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add riscv32imac-unknown-none-elf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly target add aarch64-unknown-none
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly component add rust-src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Windows安装unstable版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：Windows只支持使用 &lt;code&gt;gnu&lt;/code&gt; 版的工具链&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup install nightly-x86_64-pc-windows-gnu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.base-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabihf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add thumbv6m-none-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add riscv32imac-unknown-none-elf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu target add aarch64-unknown-none
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly-x86_64-pc-windows-gnu component add rust-src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;安装lsp&#34;&gt;安装LSP&lt;/h2&gt;
&lt;p&gt;LSP（Language Server Protocol，语言服务协议）是新一代查看源码的工具。
Rust语言的LSP推荐使用 &lt;code&gt;rust-analyzer&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;有两种安装方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过命令安装，可获得稳定版&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rustup +nightly component add rust-src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通过源码安装，可获得最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/rust-analyzer/rust-analyzer.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; rust-analyzer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cargo xtask install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 分支与版本号规范</title>
      <link>/docs/Standard/VersionBranch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Standard/VersionBranch/</guid>
      <description>
        
        
        &lt;h2 id=&#34;版本号&#34;&gt;版本号&lt;/h2&gt;
&lt;p&gt;XWOS从V3.0.0开始遵循 &lt;a href=&#34;https://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt; 规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本格式：主版本号.次版本号.修订号，版本号递增规则如下：
&lt;ul&gt;
&lt;li&gt;主版本号：当做了不兼容的API修改，也被称为里程碑版本；&lt;/li&gt;
&lt;li&gt;次版本号：当做了向下兼容的功能性新增，也被称为稳定版本；&lt;/li&gt;
&lt;li&gt;修订号：当做了向下兼容的问题修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分支&#34;&gt;分支&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;* 分支: 主分支；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本号&lt;/strong&gt; 分支: 稳定版本与里程碑版本的分支。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 顺序锁</title>
      <link>/docs/TechRefManual/Lock/Seqlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Seqlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序锁是对 &lt;a href=&#34;../Spinlock&#34;&gt;自旋锁&lt;/a&gt; 改良后的锁。主要是对读和写的情况进行区分。
顺序锁中包含一个自旋锁和一个顺序值。顺序锁将临界区分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占写：任何对顺序锁临界区的 &lt;strong&gt;写&lt;/strong&gt; 操作都是独占的，每次 &lt;strong&gt;写&lt;/strong&gt; 操作时，会先上锁自旋锁，
然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 &lt;strong&gt;偶数&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;非独占读：如果多个CPU进行的是 &lt;strong&gt;只读&lt;/strong&gt; 操作，它们可以同时进入 &lt;strong&gt;非独占读临界区&lt;/strong&gt; 。
CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 &lt;strong&gt;偶数&lt;/strong&gt; ，并记录此时的顺序值。
当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较：
&lt;ul&gt;
&lt;li&gt;如果相等，表示读的结果有效；&lt;/li&gt;
&lt;li&gt;如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独占读：如果希望读临界区不会被写操作无效掉，可以使用独占读的方式，
独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥非独占读，
其他CPU依然可以进入非独占读临界区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;顺序锁有个缺陷： &lt;strong&gt;写&lt;/strong&gt; 者将数据写为空指针时，有可能导致 &lt;strong&gt;非独占读&lt;/strong&gt; 者引用空指针而崩溃。&lt;/p&gt;
&lt;h2 id=&#34;使用顺序锁&#34;&gt;使用顺序锁&lt;/h2&gt;
&lt;h3 id=&#34;顺序锁的初始化&#34;&gt;顺序锁的初始化&lt;/h3&gt;
&lt;p&gt;同自旋锁一样，顺序锁结构体很小，不提供动态创建和删除方法。
用户可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga230119b86fd51047f83cbe1e74982892&#34;&gt;&lt;code&gt;xwos_sqlk_init()&lt;/code&gt;&lt;/a&gt; 初始化顺序锁。&lt;/p&gt;
&lt;h3 id=&#34;多锁&#34;&gt;多锁&lt;/h3&gt;
&lt;p&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁保护 &lt;strong&gt;写临界区&lt;/strong&gt; 或 &lt;strong&gt;独占读临界区&lt;/strong&gt; 时，上锁和解锁顺序必须 &lt;strong&gt;保持一致&lt;/strong&gt; ，否则会导致死锁。&lt;/p&gt;
&lt;h3 id=&#34;非独占读临界区&#34;&gt;非独占读临界区&lt;/h3&gt;
&lt;p&gt;如果多个CPU进行的是 &lt;strong&gt;只读&lt;/strong&gt; 操作，它们可以同时进入 &lt;strong&gt;非独占读临界区&lt;/strong&gt; 。
CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 &lt;strong&gt;偶数&lt;/strong&gt;，并记录此时的顺序值。
此操作可通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga7cd1c5a34e6c318d537e4780f3ae85f4&#34;&gt;&lt;code&gt;xwos_sqlk_rd_begin()&lt;/code&gt;&lt;/a&gt; 来完成。&lt;/p&gt;
&lt;p&gt;当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较。
此操作可通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gabcf1bae603513b049184fe2179d1301e&#34;&gt;&lt;code&gt;xwos_sqlk_rd_retry()&lt;/code&gt;&lt;/a&gt; 完成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果相等，表示读的结果有效；&lt;/li&gt;
&lt;li&gt;如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        seq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sqlk_rd_begin&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 进入临界区前先获取顺序值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 非独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;xwos_sqlk_rd_retry&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span style=&#34;&#34;&gt;，&lt;/span&gt; seq)); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 测试顺序值是否发生了变化 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户也可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga40da988fa2376c706f8cab79dc4dab7c&#34;&gt;&lt;code&gt;xwos_sqlk_get_seq()&lt;/code&gt;&lt;/a&gt; 读取顺序值，自行比较。&lt;/p&gt;
&lt;h3 id=&#34;写临界区&#34;&gt;写临界区&lt;/h3&gt;
&lt;p&gt;任何对顺序锁临界区的 &lt;strong&gt;写&lt;/strong&gt; 操作都是独占的，每次进入 &lt;strong&gt;写临界区&lt;/strong&gt; 时，会先上锁自旋锁，
然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 &lt;strong&gt;偶数&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只会关闭抢占。
可以理解为在线程层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga16274374f2eeac631149433d1cf3491a&#34;&gt;&lt;code&gt;xwos_splk_wr_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga5cc1e68a7d23ca6b7210de17b950e64b&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga1320e69104e26e1a79b5459e7607584c&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga61fbffa6ca444335dbf3a4c2d2fd79b5&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaa46493b921777da3bc92fd5e91cf2388&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga694c4ac137e605fd951a3e3c1d37c855&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gabc138d69277ba1017ade0f27c6c282cb&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga065396cb9c428d0e6234ade20506ff2a&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gadcb38d5d6dad7969e1231c47c131f3c8&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。&lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaac8a682117d914620347320e9f560152&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3eb1f6f9a6a1feda5569757540b01df6&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga2e5a2faac19775d37f6f5ccde32a7313&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3f5f4b0151aa7b01887270f15a13818c&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga21e971d6ca670922416042f7ecc4d063&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga0fe331dfdb5fa645618cc74a90278d03&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaffbc56b927fa504cad49f737a8be68d1&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga4771dca2b7e1f58df3fea5dc0278bd0a&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3e2867fefe9d28031957e563ffc76ff5&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;独占读临界区&#34;&gt;独占读临界区&lt;/h3&gt;
&lt;p&gt;如果希望读临界区不会被写操作无效掉，可以使用独占读的方式，
独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥 &lt;strong&gt;非独占读&lt;/strong&gt; ，
其他CPU依然可以进入非独占读临界区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只会关闭抢占。
可以理解为在线程层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga0bc2e7584ad91b0c250ff029b25d70bd&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaa870ff02e389c6f9d61ee4119fc38204&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga390316c0f4e02e92669a87fefe0a0bb4&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga24cf158c1835abd6bacdcd846b1ba787&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga5cd525a876d961a541876ba9a217e77e&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gadd1ae7af48feae2d216dc588d2789490&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga9c906f30b85d221d21be57fe2ff79410&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga7466ec4b9fede25fce836c3e0f718661&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga6eb881e1a1c6e73879053a45e7af20cc&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。&lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gad67dfd2f001aab35f69cf99d9831ba8c&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga2fb086d3289975531800d2633542c7a8&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga868886500d9e33300b0fbccd032ff449&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga8f7f5fa7a0103fb2bc89d69a6afbcdab&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaf80962b3c0731f34615604c6dbe30839&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga62dff199b6143032fe9bd5a03f51067c&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gad649d232c24bbbf43fb9d9f163381692&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gab71ec7bec664746455b4f5c3ffaf5505&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga56e9f3261d8966ac1dfc51619cd5f48d&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/seqlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 顺序锁</title>
      <link>/docs/UserManual/App/Lock/Seqlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Lock/Seqlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__lock__seqlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/seqlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 条件量</title>
      <link>/docs/TechRefManual/Sync/Cond/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Cond/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;条件量是操作系统比较底层的同步机制，可以同时阻塞多个线程。当条件成立，条件量可以唤醒一个或所有正在等待的线程。&lt;/p&gt;
&lt;p&gt;操作系统或语言库都提供了条件量的功能，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX的 &lt;code&gt;pthread_cond_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C++的 &lt;code&gt;std::condition_variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Java的 &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Python的 &lt;code&gt;threading.Condition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rust的 &lt;code&gt;std::sync::condvar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程需要在持有 &lt;strong&gt;互斥锁&lt;/strong&gt; 的情况下去等待条件量，
条件量阻塞线程时会同步释放 &lt;strong&gt;互斥锁&lt;/strong&gt; 。当条件成立，线程被唤醒时，条件量会自动上锁 &lt;strong&gt;互斥锁&lt;/strong&gt; 。
等待条件量发生错误时，条件量也会自动上锁 &lt;strong&gt;互斥锁&lt;/strong&gt; 后再返回。&lt;/p&gt;
&lt;p&gt;XWOS的条件量的功能类似，主要包括以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 等待条件量的 &lt;strong&gt;条件成立&lt;/strong&gt; 而阻塞；&lt;/li&gt;
&lt;li&gt;另一个线程 &lt;strong&gt;B&lt;/strong&gt; 或中断上下文或其他上下文通过 &lt;strong&gt;单播&lt;/strong&gt; 或 &lt;strong&gt;广播&lt;/strong&gt; 使 &lt;strong&gt;条件成立&lt;/strong&gt; ，并唤醒条件量上阻塞的线程 &lt;strong&gt;A&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，会自动解锁；&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，当等到 &lt;strong&gt;条件成立&lt;/strong&gt; 时，会自动上锁；&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，当发生错误返回时， &lt;strong&gt;不会&lt;/strong&gt; 自动上锁；&lt;/li&gt;
&lt;li&gt;支持多种锁类型：
&lt;ul&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;顺序锁&lt;/li&gt;
&lt;li&gt;自定义的加锁与解锁函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持没有伴生锁的情况下操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;条件量对象与对象描述符描述符&#34;&gt;条件量对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;条件量对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，条件量对象也用 &lt;strong&gt;条件量对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__cond__d.html&#34;&gt;&lt;code&gt;xwos_cond_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;条件量对象描述符由 &lt;strong&gt;条件量对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_cond &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cond; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 条件量对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_cond_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;条件量的初始化销毁与动态创建删除&#34;&gt;条件量的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga02154ceda2ebb3198e0f452d05e84fe8&#34;&gt;&lt;code&gt;xwos_cond_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的条件量： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga2007c32a3bc08294a77ab09ac17e2e20&#34;&gt;&lt;code&gt;xwos_cond_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga8d6ff09dee39723571220a7f25d04eb3&#34;&gt;&lt;code&gt;xwos_cond_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的条件量： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6921e0eb38b073d68cb4af77ecc71c85&#34;&gt;&lt;code&gt;xwos_cond_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单播&#34;&gt;单播&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafe8a5951b17d91fe378756815abc8b9b&#34;&gt;&lt;code&gt;xwos_cond_unicast()&lt;/code&gt;&lt;/a&gt; 可用来在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使得条件量的条件成立，但只唤醒一个线程。
单播不会产生 &lt;strong&gt;选者信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;广播&#34;&gt;广播&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6a85c4b4f0a48d8f7af6d1eb9edf5828&#34;&gt;&lt;code&gt;xwos_cond_broadcast()&lt;/code&gt;&lt;/a&gt; 可用来在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使得条件量的条件成立，唤醒全部线程。
&lt;strong&gt;广播&lt;/strong&gt; 还会使得条件量向绑定的 &lt;a href=&#34;../sel&#34;&gt;信号选择器&lt;/a&gt; 发送 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;等待条件量&#34;&gt;等待条件量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga5e036562855a7585904903a707f19ca7&#34;&gt;&lt;code&gt;xwos_cond_wait()&lt;/code&gt;&lt;/a&gt; ：等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gad8c1310da94bd715059fef8521264cfa&#34;&gt;&lt;code&gt;xwos_cond_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga176a4bfcec1f402e0e8e127354e58911&#34;&gt;&lt;code&gt;xwos_cond_wait_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用了带附作用的上锁函数时，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;等待条件量&lt;/strong&gt; 不会管理调度器开关、中断开关以及中断底半部开关。
等待之前是什么状态，无论返回值是 &lt;code&gt;XWOK&lt;/code&gt; 还是错误码，等待之后还是什么状态。&lt;/p&gt;
&lt;p&gt;XWOS的条件量与 &lt;code&gt;pthread_cond_t&lt;/code&gt; 不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XWOS的条件量， &lt;strong&gt;等待条件量&lt;/strong&gt; 返回值为 &lt;code&gt;XWOK&lt;/code&gt; 时才会对锁进行上锁，如果返回错误码，是否上锁不确定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_wait()&lt;/code&gt; 无论如何都会等待互斥锁被上锁时才返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;冻结与解冻&#34;&gt;冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;冻结&#34;&gt;冻结&lt;/h3&gt;
&lt;p&gt;条件量可以使用 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae28d45933a9a1cd5fbb282533f3a96d5&#34;&gt;&lt;code&gt;xwos_cond_freeze()&lt;/code&gt;&lt;/a&gt; 进行 &lt;strong&gt;冻结&lt;/strong&gt;，
被冻结的条件量不能被 &lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt; ，但不影响 &lt;strong&gt;等待&lt;/strong&gt; 操作。&lt;/p&gt;
&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gab932d4d14e734f2f413783512b0b10ac&#34;&gt;&lt;code&gt;xwos_cond_thaw()&lt;/code&gt;&lt;/a&gt; 可将已经冻结的条件量 &lt;strong&gt;解冻&lt;/strong&gt; 。
条件量 &lt;strong&gt;解冻&lt;/strong&gt; 后，可重新 &lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_cond_bind()&lt;/code&gt;&lt;/a&gt; 将条件量绑定到 &lt;a href=&#34;../sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当 &lt;strong&gt;广播&lt;/strong&gt; 条件量时，条件量会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。此外， &lt;strong&gt;单播&lt;/strong&gt; 不会产生 &lt;strong&gt;选者信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;绑定后的条件量可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_cond_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;条件量对象的生命周期管理&#34;&gt;条件量对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;条件量对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
条件量对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gab8acb77604393deba20d8511707bd820&#34;&gt;&lt;code&gt;xwos_cond_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae52e6bcefc86df3fd676534010c3d2b2&#34;&gt;&lt;code&gt;xwos_cond_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga0b954974711ff4689398312f2861e578&#34;&gt;&lt;code&gt;xwos_cond_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gad2319939fb53002f58ac0cd1d32bc2b2&#34;&gt;&lt;code&gt;xwos_cond_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__cond.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/cond.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 条件量</title>
      <link>/docs/UserManual/App/Sync/Cond/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Sync/Cond/</guid>
      <description>
        
        
        &lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../../capi/group__xwos__sync__cond.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/cond.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 循环队列</title>
      <link>/docs/TechRefManual/Isc/Xwcq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/Xwcq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的循环队列（xwcq）是由 &lt;strong&gt;NUM&lt;/strong&gt; 个大小为 &lt;strong&gt;SIZE&lt;/strong&gt; 的数据缓冲区组成的队列。
这些缓冲区首尾相连，形成一个环。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;pie
    title 循环队列
    &amp;#34;数据缓冲区0&amp;#34; : 1
    &amp;#34;数据缓冲区1&amp;#34; : 1
    &amp;#34;数据缓冲区2&amp;#34; : 1
    &amp;#34;数据缓冲区3&amp;#34; : 1
    &amp;#34;数据缓冲区4&amp;#34; : 1
    &amp;#34;数据缓冲区5&amp;#34; : 1
    &amp;#34;数据缓冲区6&amp;#34; : 1
    &amp;#34;数据缓冲区7&amp;#34; : 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息可发送到队列的头部，也可以发送到队列的尾部。
消息可以从队列的头部接收，也可以从队列的尾部接收。&lt;/p&gt;
&lt;h3 id=&#34;循环队列对象与对象描述符描述符&#34;&gt;循环队列对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;循环队列对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，循环队列对象也用 &lt;strong&gt;循环队列对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwcq__d.html&#34;&gt;&lt;code&gt;xwcq_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;循环队列对象描述符由 &lt;strong&gt;循环队列对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwcq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cq; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 循环队列对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwcq_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;循环队列有自己数据缓冲区，用户的消息会被拷贝到数据缓冲区内，用户不必额外申请动态内存。
但循环队列缓冲区大小是固定的，用户只能发送小于等于缓冲区大小的数据。&lt;/p&gt;
&lt;h2 id=&#34;循环队列的静态初始化销毁&#34;&gt;循环队列的静态初始化、销毁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga0c3766b13d0b48e0c99fab1d814c7b57&#34;&gt;&lt;code&gt;xwcq_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;初始化循环队列时，需要预先定义数据缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define BRDCQ_SIZE 64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define BRDCQ_NUM  8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;XWCQ_DEF_MEMPOOL&lt;/span&gt;(brdcq_mempool, BRDCQ_SIZE, BRDCQ_NUM);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwcq brdcq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;brd_init_xwcq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwcq_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;brdcq, BRDCQ_SIZE, BRDCQ_NUM, brdcq_mempool);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gad2cc23153007095e7eb3420412ad4083&#34;&gt;&lt;code&gt;xwcq_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环队列的动态创建删除&#34;&gt;循环队列的动态创建、删除&lt;/h2&gt;
&lt;p&gt;XWOS并未提供基于动态内存管理的创建与删除CAPI。&lt;/p&gt;
&lt;h2 id=&#34;发送消息&#34;&gt;发送消息&lt;/h2&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt; 是指将消息发送到循环队列的 &lt;strong&gt;尾端&lt;/strong&gt; 。
如果循环队列数据已被填满，循环队列会循环回队列 &lt;strong&gt;首端&lt;/strong&gt; 的位置，覆盖掉原数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gacc14c7eb323b5968c30d42371bced34b&#34;&gt;&lt;code&gt;xwcq_eq()&lt;/code&gt;&lt;/a&gt; ：可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插队&#34;&gt;插队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;插队&lt;/strong&gt; 是指将消息发送到循环队列的 &lt;strong&gt;首端&lt;/strong&gt; 。
如果循环队列数据已被填满，循环队列会循环回队列 &lt;strong&gt;尾端&lt;/strong&gt; 的位置，覆盖掉原数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga99aaf9a7ad5acc2dde16642e3c76644f&#34;&gt;&lt;code&gt;xwcq_jq()&lt;/code&gt;&lt;/a&gt; ：可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接收消息&#34;&gt;接收消息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;接收消息&lt;/strong&gt; 是指从循环队列中 &lt;strong&gt;取走&lt;/strong&gt; 消息，消息取走后不再存在于循环队列。&lt;/p&gt;
&lt;h3 id=&#34;首端接收&#34;&gt;首端接收&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gac9f65a59cd4c07212e4515d81466edab&#34;&gt;&lt;code&gt;xwcq_dq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga1751e4a7d470159426dfc0b28f30c426&#34;&gt;&lt;code&gt;xwcq_dq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga9268a23f62386b705f358da0690719d7&#34;&gt;&lt;code&gt;xwcq_dq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga7b6a39511984b0701595df93d4f07072&#34;&gt;&lt;code&gt;xwcq_trydq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端离队&#34;&gt;尾端离队&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga9aaa9a95186c3bd701b31dc05d1f051b&#34;&gt;&lt;code&gt;xwcq_rq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf4c60c0ca895ff95a7f636871a83592b&#34;&gt;&lt;code&gt;xwcq_rq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gadc32b77f21a0faec18ce917f4cae6b46&#34;&gt;&lt;code&gt;xwcq_rq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga4ee21be691d89289330a6b775eaa2122&#34;&gt;&lt;code&gt;xwcq_tryrq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拷贝消息&#34;&gt;拷贝消息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;拷贝消息&lt;/strong&gt; 是指从循环队列中 &lt;strong&gt;拷贝&lt;/strong&gt; 消息，不会从循环队列中删除消息。&lt;/p&gt;
&lt;h3 id=&#34;首端拷贝&#34;&gt;首端拷贝&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf743e9140c73b57f82592e612e5f0310&#34;&gt;&lt;code&gt;xwcq_pfq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga8ee1e6f6ccb52d2ad7ff983299e457f8&#34;&gt;&lt;code&gt;xwcq_pfq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga47c4c89b9ae21ff278bb0911982a9178&#34;&gt;&lt;code&gt;xwcq_pfq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf6e49bfc7b9b04d1c0162fba5fa19752&#34;&gt;&lt;code&gt;xwcq_trypfq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端拷贝&#34;&gt;尾端拷贝&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga446e314e4d1bf1e91a6f17a4e57b5fc4&#34;&gt;&lt;code&gt;xwcq_prq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga927902d5c0f3137e42dc3040b8186c1e&#34;&gt;&lt;code&gt;xwcq_prq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gab7a4f7dad6f65d876840a5e1279cdab6&#34;&gt;&lt;code&gt;xwcq_prq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaa0cca193c18e50f3357ec81431f591da&#34;&gt;&lt;code&gt;xwcq_tryprq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;清空循环队列&#34;&gt;清空循环队列&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gae3abbdc3ed1a692d76a37d01de02f4b8&#34;&gt;&lt;code&gt;xwcq_flush()&lt;/code&gt;&lt;/a&gt; 将循环队列恢复到初始化状态。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列容量&#34;&gt;获取循环队列容量&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga1c85e05558f075453bfa3c7cd3fc02a5&#34;&gt;&lt;code&gt;xwcq_get_capacity()&lt;/code&gt;&lt;/a&gt; 获取循环队列的容量。
循环队列的容量是指数据缓冲区中数据槽的数量，也即是 &lt;code&gt;xwcq_init()&lt;/code&gt; 的第三个参数。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列单个数据槽的大小&#34;&gt;获取循环队列单个数据槽的大小&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaa51ad59ea6039a0e7f0086e019361a65&#34;&gt;&lt;code&gt;xwcq_get_size()&lt;/code&gt;&lt;/a&gt; 获取单个数据槽的大小。
也即是 &lt;code&gt;xwcq_init()&lt;/code&gt; 的第二个参数。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列中有效数据槽的数量&#34;&gt;获取循环队列中有效数据槽的数量&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga00c6353fe858d19a09198cf3adfd20fb&#34;&gt;&lt;code&gt;xwcq_get_availability()&lt;/code&gt;&lt;/a&gt; 获取循环队列中有效数据槽的数量。
有效数据槽是指包含了可被接收数据的数据槽。&lt;/p&gt;
&lt;h2 id=&#34;循环队列对象的生命周期管理&#34;&gt;循环队列对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;循环队列对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
循环队列对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gad5deec2a2c4c219ff7e4e5e562711936&#34;&gt;&lt;code&gt;xwcq_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga830514ae992ff57a790a427f98ee2802&#34;&gt;&lt;code&gt;xwcq_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaeb13f10158bb8bcc962c9d4b70304e83&#34;&gt;&lt;code&gt;xwcq_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga51d97bf4e9311f1ca7aec6f99b557587&#34;&gt;&lt;code&gt;xwcq_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwmd__isc__xwcq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwmd/isc/xwcq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 原子操作库</title>
      <link>/docs/TechRefManual/Xwlib/Xwaop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Xwaop/</guid>
      <description>
        
        
        &lt;h2 id=&#34;内存模型&#34;&gt;内存模型&lt;/h2&gt;
&lt;p&gt;与标准库一样，XWOS的原子操作分为6种内存模型：&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_relaxed&#34;&gt;&lt;code&gt;xwaop_mo_relaxed&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;松散序，不作任何内存屏障操作。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_consume&#34;&gt;&lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;消费序，会在读操作之间增加 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 。
这个屏障并不常见，对于常见的x86/ARM都是自动处理 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 的。
据作者所知，目前只有Alpha架构的CPU需要程序员关注 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 。
Rust语言干脆连这个内存序都不提供。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_acquire&#34;&gt;&lt;code&gt;xwaop_mo_acquire&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;获得序，常常与配合读一起使用，形成 &lt;strong&gt;load-acquire&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_release&#34;&gt;&lt;code&gt;xwaop_mo_release&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;释放序，常常与配合写一起使用，形成 &lt;strong&gt;store-release&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_acq_rel&#34;&gt;&lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;获得释放序，加载时是 &lt;strong&gt;acquire&lt;/strong&gt; 的，回写时是 &lt;strong&gt;release&lt;/strong&gt; 的。通常用于 &lt;strong&gt;读-改-回写&lt;/strong&gt; 这种原子操作。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_seq_cst&#34;&gt;&lt;code&gt;xwaop_mo_seq_cst&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一致序，表明CPU对内存的访问顺序是严格按照程序代码（编译后的）的顺序所进行的。这在期刊文献中被称为 &lt;strong&gt;Sequential Consistency&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;原子操作&#34;&gt;原子操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了原子操作模板库， &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; 中定义的各种 &lt;strong&gt;基本类型&lt;/strong&gt; 都可使用原子操作。
XWOS的原子操作库，可以与标准库 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 中的原子操作混合使用。&lt;/p&gt;
&lt;p&gt;原子操作函数模板包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_load()&lt;/code&gt; ：加载
&lt;ul&gt;
&lt;li&gt;可以指定6种内存序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_read()&lt;/code&gt; ：读
&lt;ul&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acquire&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_store()&lt;/code&gt; ：存储
&lt;ul&gt;
&lt;li&gt;可以指定6种内存序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_write()&lt;/code&gt; ：写
&lt;ul&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_release&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-改-写
&lt;ul&gt;
&lt;li&gt;基本运算
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_add()&lt;/code&gt; ：加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_sub()&lt;/code&gt; ：减&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_rsb()&lt;/code&gt; ：反向减法&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位运算
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_and()&lt;/code&gt; ：与&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_or()&lt;/code&gt; ：或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_xor()&lt;/code&gt; ：异或&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_s1m()&lt;/code&gt; ：将数据掩码部分的位全部置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_c0m()&lt;/code&gt; ：将数据掩码部分的位全部清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_x1m()&lt;/code&gt; ：将数据掩码部分的位全部翻转&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-测试-改-写
&lt;ul&gt;
&lt;li&gt;所有名称匹配正则表达式 &lt;code&gt;xwaop_t.+_then_.+&lt;/code&gt; 的函数
&lt;ul&gt;
&lt;li&gt;分为两种情况
&lt;ul&gt;
&lt;li&gt;测试成功，继续执行“改-写”操作，此时内存序为 &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试失败，相当于读操作，此时内存序为 &lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有原子操作函数的第一个参数均为 &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; ，第二个参数是原子数据的指针，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwsq_a refcnt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; nv, ov;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * 测试refcnt是否为0：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * + ture: refcnt增加1，nv返回refcnt增加以后的新值，ov返回refcnt增加以前的旧值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; *         内存序：acq_rel，rc为返回值XWOK；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * + false: nv与ov都返回refcnt的值，内存序：consume，rc为返回值-EACCES；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwaop_teq_then_add&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;refcnt, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;nv, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ov);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;位图原子操作&#34;&gt;位图原子操作&lt;/h2&gt;
&lt;p&gt;位图（ &lt;code&gt;xwbmp_t&lt;/code&gt; 数组）可进行原子操作，XWOS提供了基本函数库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_define()&lt;/code&gt; ：声明原子位图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t1i()&lt;/code&gt; ：测试位图中的某位是否被置1&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_s1all()&lt;/code&gt; ：将位图所有位置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_c0all()&lt;/code&gt; ：将位图所有位清0&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-改-写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_s1i()&lt;/code&gt; ：将位图中某位置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_c1i()&lt;/code&gt; ：将位图中某位清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_x1i()&lt;/code&gt; ：将位图中某位翻转&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-测试-改-写
&lt;ul&gt;
&lt;li&gt;所有名字匹配正则表达式 &lt;code&gt;xwbmpaop_.+_then_.+&lt;/code&gt; 的函数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t0i_then_s1i()&lt;/code&gt; ：测试位图中某位是否为0，如果是，就将它置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t1i_then_c0i()&lt;/code&gt; ：测试位图中某位是否为1，如果是，就将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_fls_then_c0i()&lt;/code&gt; ：从最高位起查找位图中第一个为1的位并将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_flz_then_s1i()&lt;/code&gt; ：从最高位起查找位图中第一个为0的位并将它置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_ffs_then_c0i()&lt;/code&gt; ：从最低位起查找位图中第一个为1的位并将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_ffz_then_s1i()&lt;/code&gt; ：从最低位起查找位图中第一个为0的位并将它置1&lt;/li&gt;
&lt;li&gt;分为两种情况
&lt;ul&gt;
&lt;li&gt;测试成功，继续执行“改-写”操作，此时内存序为 &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试失败，相当于读操作，此时内存序为 &lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwaop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwaop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;位图原子操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwbmpaop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwbmpaop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 基于Eclipse的IDE设置指南</title>
      <link>/docs/UserManual/Env/Eclipse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/Env/Eclipse/</guid>
      <description>
        
        
        &lt;p&gt;基于Eclipse的IDE（例如：STM32CubeIDE、S32DS、NucleiStudio等）的设置方法相似。&lt;/p&gt;
&lt;h2 id=&#34;编译设置&#34;&gt;编译设置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;菜单： &lt;strong&gt;Project &amp;ndash;&amp;gt; Properties&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择卡： &lt;strong&gt;C/C++ Build&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Build Settings&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭Eclipse自动生成 &lt;code&gt;Makefile&lt;/code&gt; 的功能；&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;buid directory&lt;/code&gt; 为 &lt;strong&gt;电路板目录&lt;/strong&gt; ，使用XWOS自带的编译系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;Properties-C_C++_Build-Settings.png&#34; alt=&#34;img&#34; title=&#34;编译设置&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Build Behavior&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设置 &lt;code&gt;build&lt;/code&gt; 的目标为 &lt;code&gt;all&lt;/code&gt; 或置空；&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;clean&lt;/code&gt; 的目标为 &lt;code&gt;d&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;Properties-C_C++_Build-Behavior.png&#34; alt=&#34;img&#34; title=&#34;编译行为&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;环境变量设置&#34;&gt;环境变量设置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;菜单 &lt;strong&gt;Project &amp;ndash;&amp;gt; Properties&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择卡 &lt;strong&gt;C/C++ Build &amp;ndash;&amp;gt; Environment&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;设置
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WKSPC&lt;/code&gt; ：编译时输出文件的路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; : 设置为 &lt;code&gt;1&lt;/code&gt; 可在编译时显示指令；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;设置为 &lt;code&gt;1&lt;/code&gt; 时，编译器的优化不会影响调试；&lt;/li&gt;
&lt;li&gt;设置为 &lt;code&gt;0&lt;/code&gt; 时，编译器的优化会影响调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;Properties-C_C++_Build-Environment.png&#34; alt=&#34;img&#34; title=&#34;环境变量&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rust插件&#34;&gt;Rust插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;菜单： &lt;code&gt;&amp;quot;Help&amp;quot; -&amp;gt; &amp;quot;Install New Software...&amp;quot; -&amp;gt; &amp;quot;Add...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仓库： &lt;code&gt;http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插件： &lt;code&gt;Corrosion: Rust edition in Eclipse IDE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同版本的Eclipse与插件存在兼容性问题，需要尝试不同版本的插件。
一般选择 &lt;code&gt;1.2.3&lt;/code&gt; 版本的插件即可，不要选择最新的 &lt;code&gt;1.2.4&lt;/code&gt; 版本的插件。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Rust开发环境安装笔记</title>
      <link>/docs/Note/Rust/Env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Rust/Env/</guid>
      <description>
        
        
        &lt;h2 id=&#34;安装lsp&#34;&gt;安装LSP&lt;/h2&gt;
&lt;p&gt;LSP(Language Server Protocol，语言服务协议)是新一代查看源码的神器。
Rust语言的LSP推荐使用rust-analyzer。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/rust-analyzer/rust-analyzer.git
cd rust-analyzer
cargo xtask install
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;vscode&#34;&gt;VScode&lt;/h2&gt;
&lt;p&gt;VSCode需要在安装完成VSCode之后再安装 &lt;code&gt;rust-analyzer&lt;/code&gt; 。安装完成后，VSCode是开箱即用的。&lt;/p&gt;
&lt;h2 id=&#34;stm32cubeide&#34;&gt;STM32CubeIDE&lt;/h2&gt;
&lt;p&gt;STM32CubeIDE是基于Eclipse的，因此只需要安装Rust插件。&lt;/p&gt;
&lt;h3 id=&#34;rust插件&#34;&gt;Rust插件&lt;/h3&gt;
&lt;p&gt;需要安装版本较新的Rust插件，否则无法支持rust-analyzer。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;菜单： &lt;code&gt;&amp;quot;Help&amp;quot; -&amp;gt; &amp;quot;Install New Software...&amp;quot; -&amp;gt; &amp;quot;Add...&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仓库： &lt;code&gt;http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插件： &lt;code&gt;Corrosion: Rust edition in Eclipse IDE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rust设置&#34;&gt;Rust设置&lt;/h3&gt;
&lt;p&gt;点击 &lt;code&gt;Window&lt;/code&gt; -&amp;gt; &lt;code&gt;Rust&lt;/code&gt; 检查一下 &lt;code&gt;rustup&lt;/code&gt; ， &lt;code&gt;cargo&lt;/code&gt; ， &lt;code&gt;rust-analyzer&lt;/code&gt; 等的路径是否正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;RustPluginSetting.png&#34; alt=&#34;RustPluginSetting.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;调试&#34;&gt;调试&lt;/h3&gt;
&lt;p&gt;和调试C的代码一样，使用&lt;code&gt;STLink&lt;/code&gt;可在STM32CubeIDE中给Rust的代码设置断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../Bringup/RustInEclipse.png&#34; alt=&#34;RustInEclipse&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;已知问题&#34;&gt;已知问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[2023-04-25] 高版本的STM32CubeIDE(&amp;gt;=1.9.0)安装成功后无法启动插件。
&lt;ul&gt;
&lt;li&gt;解决方法：不要安装最新(1.2.4)版本的Rust插件，安装1.2.3的插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: errno</title>
      <link>/docs/Note/Newlib/errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Newlib/errno/</guid>
      <description>
        
        
        &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Newlib中，标准头文件 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 的 &lt;code&gt;errno&lt;/code&gt; 是一个宏：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* &amp;lt;errno.h&amp;gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define errno (*__errno())
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;__errno&lt;/span&gt; (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;__errno&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;_REENT&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;_errno;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Newlib的底层代码对errno的处理非常奇怪，会将errno undef掉，然后重新定义成一个 &lt;strong&gt;变量&lt;/strong&gt; ，
并要求libgloss中提供 &lt;strong&gt;变量&lt;/strong&gt; 定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* &amp;lt;newlib/libc/reent/readr.c&amp;gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#undef errno
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; errno;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_ssize_t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_read_r&lt;/span&gt; (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; _reent &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ptr,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; fd,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;buf,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;size_t&lt;/span&gt; cnt)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _ssize_t ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  errno &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; ((ret &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (_ssize_t)&lt;span style=&#34;color:#00a000&#34;&gt;_read&lt;/span&gt; (fd, buf, cnt)) &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; errno &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ptr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;_errno &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; errno;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* &amp;lt;libgloss/libnosys/read.c&amp;gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#undef errno
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; errno;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;_read&lt;/span&gt; (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;   file,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ptr,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;   len)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  errno &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ENOSYS;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;libgloss提供与平台相关的启动代码、I/O支持、系统函数等，其中libnosys是一个空实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;移植方法&#34;&gt;移植方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS在每个线程对象结构体中定义了一个 &lt;code&gt;__errno&lt;/code&gt; 变量，并重新覆盖实现了 &lt;code&gt;int * __errno(void)&lt;/code&gt; 函数，
返回 &lt;strong&gt;当前&lt;/strong&gt; 线程对象的 &lt;code&gt;__errno&lt;/code&gt; 的地址：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;__errno&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        xwos_thd_d thdd &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_self&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;thdd.thd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;osthd.libc.error_number;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;errno&lt;/code&gt; 宏时，就可获取线程自身的 &lt;code&gt;__errno&lt;/code&gt; ，不再依赖libgloss。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: errno</title>
      <link>/docs/Note/Picolibc/errno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Picolibc/errno/</guid>
      <description>
        
        
        &lt;h2 id=&#34;移植方法&#34;&gt;移植方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设置Picolibc的配置 &lt;code&gt;newlib-global-errno&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，不使用 &lt;code&gt;TLS&lt;/code&gt; 机制来实现 &lt;code&gt;errno&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;设置Picolibc的配置 &lt;code&gt;errno-function&lt;/code&gt; 为 &lt;code&gt;&#39;__errno&#39;&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;XWOS在每个线程对象结构体中定义了一个 &lt;code&gt;__errno&lt;/code&gt; 变量，并重新覆盖实现了 &lt;code&gt;int * __errno(void)&lt;/code&gt; 函数，
返回 &lt;strong&gt;当前&lt;/strong&gt; 线程对象的 &lt;code&gt;__errno&lt;/code&gt; 的地址：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;__errno&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        xwos_thd_d thdd &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_self&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;thdd.thd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;osthd.libc.error_number;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;errno&lt;/code&gt; 宏时，就可获取线程自身的 &lt;code&gt;__errno&lt;/code&gt; ，不再依赖libgloss。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 互斥锁</title>
      <link>/docs/TechRefManual/Lock/Mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Mutex/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;互斥锁是用来保证不同线程正确访问共享数据的机制。访问共享数据的代码片段被称为临界区。
互斥锁 &lt;strong&gt;不可&lt;/strong&gt; 用在 &lt;strong&gt;除线程以外&lt;/strong&gt; 的其他上下文(Context)。&lt;/p&gt;
&lt;p&gt;当线程等待互斥锁时，线程会被阻塞，并让出CPU的使用权。
互斥锁存在优先级反转问题：&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Lock/Mutex/priority-inversion_hu06d113db6caaf8381d16863409fb983c_97009_800x800_fill_catmullrom_smart1_3.png&#34; width=&#34;800&#34; height=&#34;800&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS互斥锁的优先级反转问题
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;优先级策略&#34;&gt;优先级策略&lt;/h3&gt;
&lt;p&gt;XWOS内核采取优先级天花板和优先级继承的混会策略解决此问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程和互斥锁都拥有优先级，它们在创建时需要指定一个 &lt;strong&gt;静态优先级&lt;/strong&gt; ，
当线程持有互斥锁时，线程可以获取互斥锁的优先级作为 &lt;strong&gt;动态优先级&lt;/strong&gt; ，
当互斥锁被线程等待时，互斥锁可以获取线程的优先级作为 &lt;strong&gt;动态优先级&lt;/strong&gt; ，
最终的优先级取 &lt;strong&gt;静态优先级&lt;/strong&gt; 和 &lt;strong&gt;动态优先级&lt;/strong&gt; 较大的一个；&lt;/li&gt;
&lt;li&gt;假设线程A优先级低，线程B的优先级中，线程C的优先级高。
线程A已经获得锁的情况下，线程C等待锁。线程C的优先级会传递给锁，
锁的优先级再传递给线程A。线程A的优先级被临时提高至和线程C的优先级一样，线程A不会被线程B抢占。&lt;/li&gt;
&lt;li&gt;优先级可以无限继承：假设线程A的优先级最低，线程 &lt;strong&gt;&lt;code&gt;T1、T2、...、Tn&lt;/code&gt;&lt;/strong&gt; 的优先级依次递增。
系统中有互斥锁 &lt;strong&gt;&lt;code&gt;L、M1、M2、...、Mn&lt;/code&gt;&lt;/strong&gt; 。
假设A持有L，T1持有M1去等待L，T2持有M2去等待M1，T3持有M3去等待M2，以此类推，Tn持有Mn去等待Mn-1。
由此形成优先级传递链： &lt;strong&gt;&lt;code&gt;Tn-&amp;gt;Mn-1-&amp;gt;Tn-1-&amp;gt;...-&amp;gt;M3-&amp;gt;T3-&amp;gt;M2-&amp;gt;T2-&amp;gt;M1-&amp;gt;T1-&amp;gt;L-&amp;gt;A&lt;/code&gt;&lt;/strong&gt; ，
Tn的优先级将会依次传递到 &lt;strong&gt;&lt;code&gt;Mn-1、Tn-1、... 、M3、T3、M2、T2、M1、T1、L、A&lt;/code&gt;&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁树与实时等待队列&#34;&gt;互斥锁树与实时等待队列&lt;/h3&gt;
&lt;p&gt;如何寻找互斥锁与线程的 &lt;strong&gt;动态优先级&lt;/strong&gt; ，是寻找最大值的问题，因此可以采用与 &lt;a href=&#34;../../Skd#%E6%97%B6%E9%97%B4%E6%A0%91&#34;&gt;时间树&lt;/a&gt; 类似的方法，使用红黑树解决此问题。
节点为互斥锁并查找最大优先级算法被称为 &lt;strong&gt;互斥锁树&lt;/strong&gt; ；节点为线程并查找最大优先级算法被称为 &lt;strong&gt;实时等待队列&lt;/strong&gt; 。&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Lock/Mutex/rightmost-rbtree_hu6bb0500ec3a7cabe3ed4a4195feadcf6_94587_680x491_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;491&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
带有最大值指针的红黑树
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;使用一个 &lt;strong&gt;rightmost&lt;/strong&gt; 指针指向最大值，可直接从 &lt;strong&gt;rightmost&lt;/strong&gt; 快速获取最大值，时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rightmost&lt;/strong&gt; 从红黑树中删除时，按照二叉树的性质，下一任 &lt;strong&gt;rightmost&lt;/strong&gt; 是前任的左孩子（即前驱）。
如果前任的前驱为叶子，下一任 &lt;strong&gt;rightmost&lt;/strong&gt; 一定是前任的父节点，算法时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;删除 &lt;strong&gt;rightmost&lt;/strong&gt; 在系统中是一个高频次的操作，但由于 &lt;strong&gt;rightmost&lt;/strong&gt; 缺少右子树，根据红黑树性质，左子树也不可能太复杂，
意味着删除 &lt;strong&gt;rightmost&lt;/strong&gt; 后，调整红黑树的代价不会太大；&lt;/li&gt;
&lt;li&gt;插入操作需要遍历树，时间复杂度为 &lt;strong&gt;O(logn)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;红黑树中不允许存在关键字相等的节点，因此拥有相同优先级的节点相互连接成链表；&lt;/li&gt;
&lt;li&gt;互斥锁解锁时，从等待队列中选择最高优先级的线程获取互斥锁，若最高优先级的线程不止一个，按照先进先出的方法选取线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁对象与对象描述符描述符&#34;&gt;互斥锁对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;互斥锁对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，互斥锁对象也用 &lt;strong&gt;互斥锁对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__mtx__d.html&#34;&gt;&lt;code&gt;xwos_mtx_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;互斥锁对象描述符由 &lt;strong&gt;互斥锁对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_mtx &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mtx; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 互斥锁对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_mtx_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;使用互斥锁&#34;&gt;使用互斥锁&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化和销毁互斥锁&#34;&gt;静态初始化和销毁互斥锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga05ea2a9762a817291b0ae6d76586e022&#34;&gt;&lt;code&gt;xwos_mtx_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的互斥锁： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga7b2464babb829bdc7fd0e433ff54bdca&#34;&gt;&lt;code&gt;xwos_mtx_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建和删除互斥锁&#34;&gt;动态创建和删除互斥锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga815282818f9a5ed5c1cd580e097a868b&#34;&gt;&lt;code&gt;xwos_mtx_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的互斥锁： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga8f76d838298d8b5e1ae06889c7a5c3e0&#34;&gt;&lt;code&gt;xwos_mtx_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上锁&#34;&gt;上锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gabd23c15c16510525e6a91fc3fcfa20f3&#34;&gt;&lt;code&gt;xwos_mtx_lock()&lt;/code&gt;&lt;/a&gt; 等待并上锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga5fd796bb80d4d1dfa65bf60741f05241&#34;&gt;&lt;code&gt;xwos_mtx_trylock()&lt;/code&gt;&lt;/a&gt; 尝试上锁互斥锁，不会阻塞调用线程，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga37eb46fa1271ff0ecebd4e0ceb0f4420&#34;&gt;&lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt;&lt;/a&gt; 限时等待上锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gac72f69bffd93d6d8fa7dcc6bf0302574&#34;&gt;&lt;code&gt;xwos_mtx_lock_unintr()&lt;/code&gt;&lt;/a&gt; 等待并上锁互斥锁，且等待不可被中断，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解锁&#34;&gt;解锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gaa6b3a2ce561acc043d826e47a9470919&#34;&gt;&lt;code&gt;xwos_mtx_unlock()&lt;/code&gt;&lt;/a&gt; 解锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;获取锁的状态&#34;&gt;获取锁的状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#group__xwos__lock__mtx.html#ga3cddd729ac8dad2a6e9657ae72532354&#34;&gt;&lt;code&gt;xwos_mtx_get_lkst()&lt;/code&gt;&lt;/a&gt; 获取锁的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁对象的生命周期管理&#34;&gt;互斥锁对象的生命周期管理&lt;/h3&gt;
&lt;p&gt;互斥锁对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
互斥锁对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga2a560b50a5329f098f2a4cdd4331fef6&#34;&gt;&lt;code&gt;xwos_mtx_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gafaef1dadab1c11783c1aab9a7ffff589&#34;&gt;&lt;code&gt;xwos_mtx_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga84e1bbb7833198a00678b9a3e5f83941&#34;&gt;&lt;code&gt;xwos_mtx_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga698748b62131af5a434bfa5dae6dcda2&#34;&gt;&lt;code&gt;xwos_mtx_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/mtx.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 互斥锁</title>
      <link>/docs/UserManual/App/Lock/Mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Lock/Mutex/</guid>
      <description>
        
        
        &lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__lock__mtx.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/mtx.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 日志</title>
      <link>/docs/TechRefManual/Xwlib/Log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Log/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS提供了日志框架，用户可以输出带有等级的日志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VERBOSE，等级1，冗长&lt;/li&gt;
&lt;li&gt;DEBUG，等级2，调试&lt;/li&gt;
&lt;li&gt;INFO，等级3，信息&lt;/li&gt;
&lt;li&gt;NOTICE，等级4，提醒&lt;/li&gt;
&lt;li&gt;WARNING，等级5，警告&lt;/li&gt;
&lt;li&gt;ERR，等级6，错误&lt;/li&gt;
&lt;li&gt;CRIT，等级7，危险&lt;/li&gt;
&lt;li&gt;EMERG，等级8，紧急&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户可以通过配置 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 来控制各种等级的日志是否输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当等级大于等于 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 的日志才会输出，&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 配置为 &lt;code&gt;0&lt;/code&gt; 将关闭所有日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS的日志框架需要用户在BSP中提供后端驱动接口，以决定日志最终输出到串口、SD卡、还是别的设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当配置 &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，BSP中需要提供函数 &lt;code&gt;soc_log_write()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当配置 &lt;code&gt;BRDCFG_LOG&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，BSP中需要提供函数&lt;code&gt; board_log_write()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当配置 &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 与配置 &lt;code&gt;BRDCFG_LOG&lt;/code&gt; 同时为 &lt;code&gt;1&lt;/code&gt; 时， &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 具有更高优先级；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwlog.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwlog.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 事件标志</title>
      <link>/docs/TechRefManual/Sync/Flg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Flg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当系统需要处理很多事件，如果每个事件都绑定一个特定的条件量，
每个条件量又由一个线程进行等待处理，会导致系统需要大量内存来创建条件量和线程。&lt;/p&gt;
&lt;p&gt;事件标志使用位图来管理一组事件，位图中的每个位代表一个事件，
当一个或多个事件状态发生变化时，事件对应的位也会发生变化，并唤醒正在等待的线程。
线程唤醒后，就可从事件位图中获取事件的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程可以等待位图中的事件位被置 &lt;strong&gt;1&lt;/strong&gt; ，也可以等待事件位被清 &lt;strong&gt;0&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;线程可以等待位图中的事件位同时被置 &lt;strong&gt;1&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;与&lt;/strong&gt; 的关系），也可以等待其中任意一个位被置 &lt;strong&gt;1&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;或&lt;/strong&gt; 的关系）。&lt;/li&gt;
&lt;li&gt;线程可以等待位图中的事件位同时被清 &lt;strong&gt;0&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;与&lt;/strong&gt; 的关系），也可以等待其中任意一个位被清 &lt;strong&gt;0&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;或&lt;/strong&gt; 的关系）。&lt;/li&gt;
&lt;li&gt;线程可以选择是否 &lt;strong&gt;消费&lt;/strong&gt; 事件。 &lt;strong&gt;消费&lt;/strong&gt; 事件是指，当事件到来，线程被唤醒时，可以选择是否 &lt;strong&gt;清除&lt;/strong&gt; 事件。&lt;/li&gt;
&lt;li&gt;线程可以等待事件标志位发生 &lt;strong&gt;翻转&lt;/strong&gt; ， &lt;strong&gt;翻转&lt;/strong&gt; 是指事件标志位由 &lt;strong&gt;1&lt;/strong&gt; 变为 &lt;strong&gt;0&lt;/strong&gt; ，或由 &lt;strong&gt;0&lt;/strong&gt; 变为 &lt;strong&gt;1&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事件标志对象与对象描述符描述符&#34;&gt;事件标志对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;事件标志对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，事件标志对象也用 &lt;strong&gt;事件标志对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__flg__d.html&#34;&gt;&lt;code&gt;xwos_flg_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;事件标志对象描述符由 &lt;strong&gt;事件标志对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_flg &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; flg; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 事件标志对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_flg_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;事件标志的初始化销毁与动态创建删除&#34;&gt;事件标志的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gab4131ef9b03a02111a64c57801259ab9&#34;&gt;&lt;code&gt;xwos_flg_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的事件标志 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga27de7560274252b37eef3e99c450342c&#34;&gt;&lt;code&gt;xwos_flg_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaf47e42024bad241bc993108f79bc5676&#34;&gt;&lt;code&gt;xwos_flg_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的事件标志 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gafb29743a2107ec5829a372546fe8478d&#34;&gt;&lt;code&gt;xwos_flg_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;产生事件&#34;&gt;产生事件&lt;/h2&gt;
&lt;p&gt;XWOS提供6个CAPI产生触发事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga4bbbb700f8945d8a477ecdf8f48e1be3&#34;&gt;&lt;code&gt;xwos_flg_s1m()&lt;/code&gt;&lt;/a&gt; ：同时设置多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaa512cf8063cc538dbb431dbc680b1d78&#34;&gt;&lt;code&gt;xwos_flg_s1i()&lt;/code&gt;&lt;/a&gt; ：设置单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gad9d0bd13e3b0c853597b982d348fd6dd&#34;&gt;&lt;code&gt;xwos_flg_c0m()&lt;/code&gt;&lt;/a&gt; ：同时清除多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga48c1627edd80a59ad4f88c3a91fb8bf0&#34;&gt;&lt;code&gt;xwos_flg_c0i()&lt;/code&gt;&lt;/a&gt; ：清除单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga422b4ec657c8baf31cf35a141ae0bff1&#34;&gt;&lt;code&gt;xwos_flg_x1m()&lt;/code&gt;&lt;/a&gt; ：同时翻转多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga42d2e3e4536d53490ba1590aefdcaac2&#34;&gt;&lt;code&gt;xwos_flg_x1i()&lt;/code&gt;&lt;/a&gt; ：翻转单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些CAPI除了会修改事件标志位图的状态，还会通过 &lt;strong&gt;广播&lt;/strong&gt; 唤醒所有正在等待的线程。
然后，线程通过比对位图状态，确定事件是否已经满足触发条件。
若满足触发条件，就退出等待；若未满足触发条件，重新进入阻塞等待状态。&lt;/p&gt;
&lt;h2 id=&#34;获取事件的状态&#34;&gt;获取事件的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaae27fd46b8558b5e820e8bc5ffcddcdd&#34;&gt;&lt;code&gt;xwos_flg_get_num()&lt;/code&gt;&lt;/a&gt; 获取事件标志中总共有多少个事件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gac47087827b24b63dc82d2998713c61be&#34;&gt;&lt;code&gt;xwos_flg_read()&lt;/code&gt;&lt;/a&gt; 直接读取事件的位图状态。此函数立即返回，不会阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待事件&#34;&gt;等待事件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaf64305d0e0c927adb6344e1f3c144c13&#34;&gt;&lt;code&gt;xwos_flg_wait()&lt;/code&gt;&lt;/a&gt; ：等待事件，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga560ad75ecf3593fbd5a947adcdf4d9da&#34;&gt;&lt;code&gt;xwos_flg_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待事件，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga3c65f8d4b4dc03c97881a07dfdeb33dc&#34;&gt;&lt;code&gt;xwos_flg_trywait()&lt;/code&gt;&lt;/a&gt; ：检查事件，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;触发条件&#34;&gt;触发条件&lt;/h3&gt;
&lt;p&gt;当调用等待事件的CAPI时，需要指定触发条件（参数： &lt;code&gt;trigger&lt;/code&gt; ）。触发条件分为 &lt;strong&gt;电平触发&lt;/strong&gt; 和 &lt;strong&gt;边沿触发&lt;/strong&gt; 。&lt;/p&gt;
&lt;h5 id=&#34;电平触发&#34;&gt;电平触发&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;电平触发&lt;/strong&gt; 源于数字电路，是一种类比概念，是指事件位的特定的状态（ &lt;strong&gt;1&lt;/strong&gt; 或 &lt;strong&gt;0&lt;/strong&gt; ）所产生的触发信号，下面的触发条件均为电平触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gac1bba82f45d1fb1796550b88b646c93b&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_SET_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位被置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gaaf92bdb3000f9b8c8981153560c126f7&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_SET_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位被置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga2ac150517b9920b96d30085dab3c0385&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_CLR_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位被清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga7d1b859f2f363c78e413255244b0b023&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_CLR_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位被清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;边沿触发&#34;&gt;边沿触发&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;边沿触发&lt;/strong&gt; 源于数字电路，是一种类比概念，是指事件状态发生改变（ &lt;strong&gt;1&lt;/strong&gt; 变 &lt;strong&gt;0&lt;/strong&gt; 或 &lt;strong&gt;0&lt;/strong&gt; 变 &lt;strong&gt;1&lt;/strong&gt; ）时产生的唤醒信号，下面的触发条件为边沿触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga790d7ae9a4ce53ffe53db0be8e1395a3&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_TGL_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位发生翻转&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gad3ddf23fa1fa775bf577bf1c69184ead&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_TGL_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位发生翻转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边沿触发时，必须要有一个初始状态，就像数字电路一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当位的初始值为 &lt;strong&gt;0&lt;/strong&gt; (低电平)，然后跳变到 &lt;strong&gt;1&lt;/strong&gt; (高电平)的瞬间被称为上升沿。此时触发的事件被称为上升沿触发。&lt;/li&gt;
&lt;li&gt;当位的初始值为 &lt;strong&gt;1&lt;/strong&gt; (高电平)，然后跳变到 &lt;strong&gt;0&lt;/strong&gt; (低电平)的瞬间被称为下降沿。此时触发的事件被称为下降沿触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;清除事件&#34;&gt;清除事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当采用 &lt;strong&gt;电平触发&lt;/strong&gt; 时，需要在读取事件位图后 &lt;strong&gt;清除&lt;/strong&gt; 事件标志位，否则事件会一直处于触发状态。
可以在调用CAPI时，指定参数 &lt;code&gt;action&lt;/code&gt; 为 &lt;a href=&#34;../../../../capi/group__xwos__flg__action__em.html#gad5dda65f6fb9b3c9ef0586356569039a&#34;&gt;&lt;code&gt;XWOS_FLG_ACTION_CONSUMPTION&lt;/code&gt;&lt;/a&gt; 。 &lt;strong&gt;清除&lt;/strong&gt; 的含义是：
&lt;ul&gt;
&lt;li&gt;当线程等待的是位图中的事件位被置 &lt;strong&gt;1&lt;/strong&gt; ， &lt;strong&gt;清除&lt;/strong&gt; 是指将这些位清 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当线程等待的是位图中的事件位被清 &lt;strong&gt;0&lt;/strong&gt; ， &lt;strong&gt;清除&lt;/strong&gt; 是指将这些位置 &lt;strong&gt;1&lt;/strong&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当采用 &lt;strong&gt;边沿触发&lt;/strong&gt; 时，不需要 &lt;strong&gt;清除&lt;/strong&gt; 事件的触发条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga534a3b72742f053a82aa431765bdf63b&#34;&gt;&lt;code&gt;xwos_flg_bind()&lt;/code&gt;&lt;/a&gt; 将事件标志绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当等待的事件发生时，事件标志会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的事件标志可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga7f2340c7a08c61f3ae440b66675543aa&#34;&gt;&lt;code&gt;xwos_flg_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;事件标志对象的生命周期管理&#34;&gt;事件标志对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;事件标志对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
事件标志对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga6f4e9f7fc6eedef1b768d630793b24ce&#34;&gt;&lt;code&gt;xwos_flg_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga59586743a7e9812eb867adb21f9f93d6&#34;&gt;&lt;code&gt;xwos_flg_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gab5e8cd7ee6255280140a8b3375baf85f&#34;&gt;&lt;code&gt;xwos_flg_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga2d62426ddce0d88a8a3e495319d64df1&#34;&gt;&lt;code&gt;xwos_flg_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/flg.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 事件标志</title>
      <link>/docs/UserManual/App/Sync/Flg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Sync/Flg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__flg.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/flg.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: CRC</title>
      <link>/docs/TechRefManual/Xwlib/Crc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Crc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRC8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__crc8.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/crc8.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRC32&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__crc32.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/crc32.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 支持多个单元包</title>
      <link>/docs/Note/Rust/MultiCrates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Rust/MultiCrates/</guid>
      <description>
        
        
        &lt;h2 id=&#34;局限性&#34;&gt;局限性&lt;/h2&gt;
&lt;p&gt;开发XWOS RUST的过程中，需要将库与应用的代码分离在不同的crate中，在实践过程中，
发现RUST有如下局限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能将两个crate都编译成staticlib，staticlib的crate不可列举在 &lt;code&gt;[dependencies]&lt;/code&gt; ，
说明staticlib是用来给C/C++调用的；&lt;/li&gt;
&lt;li&gt;只有rlib的crate列举在 &lt;code&gt;[dependencies]&lt;/code&gt; ，编译staticlib时，
所有 &lt;code&gt;[dependencies]&lt;/code&gt; 内的crates都会打包在staticlib内；&lt;/li&gt;
&lt;li&gt;与C/C++代码链接时，不可存在两个以上的staticlib，除非这些staticlib的依赖完全
无关系（事实上这很难实现），否则会出现重复定义的链接错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;通过实践，研究出解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;xwrust_main()&lt;/code&gt; 移动到一个电路板模块 &lt;code&gt;bm/rustapp&lt;/code&gt; 中，此模块编译成staticlib；&lt;/li&gt;
&lt;li&gt;所有RUST的应用只能集中在rustapp内；&lt;/li&gt;
&lt;li&gt;其他crates只作为 rustapp的 &lt;code&gt;[dependencies]&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;其他crate设置为 &lt;code&gt;crate-type = [&amp;quot;rlib&amp;quot;]&lt;/code&gt; ，并删除 &lt;code&gt;xwmo.mk&lt;/code&gt; ，不再使用XWOS的编译系统进行编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实验代码&#34;&gt;实验代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代码仓库：&lt;code&gt;git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; XWOS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git pull
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout -b rust-multicrates 4d0837bfe227a6316288e4f1fa60a15276504159
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 线程本地存储</title>
      <link>/docs/Note/Newlib/TLS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/Note/Newlib/TLS/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;线程本地存储(TLS)是指线程私有的变量。&lt;/p&gt;
&lt;p&gt;C11标准开始支持线程本地存储，并引入 &lt;code&gt;_Thread_local&lt;/code&gt; 关键字，C2X标准引入 &lt;code&gt;thread_local&lt;/code&gt; 关键字。
gcc以及clang编译器还引入关键字 &lt;code&gt;__thread&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当用以上关键字定义全局变量时，每个线程都会拷贝一份此全局变量的副本，然后各自访问各自的副本。&lt;/p&gt;
&lt;h2 id=&#34;tls的模型&#34;&gt;TLS的模型&lt;/h2&gt;
&lt;p&gt;gcc以及clang对TLS的实现，有4种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=global-dynamic&lt;/code&gt; ：动态链接时使用，必须配合编译选项 &lt;code&gt;-fpic&lt;/code&gt; 才有效，要求给出 &lt;code&gt;__tls_get_addr()&lt;/code&gt; 的定义，
若不配合 &lt;code&gt;-fpic&lt;/code&gt; ，实际会变成 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=local-dynamic&lt;/code&gt; ：动态链接时使用，必须配合编译选项 &lt;code&gt;-fpic&lt;/code&gt; 才有效，要求给出 &lt;code&gt;__tls_get_addr()&lt;/code&gt; 的定义，
若不配合 &lt;code&gt;-fpic&lt;/code&gt; ，实际会变成 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; ：静态链接时使用，要求给出 &lt;code&gt;__aeabi_read_tp()&lt;/code&gt; 的定义，此函数会返回线程 &lt;code&gt;.tdata&lt;/code&gt; 段的首地址。
然后从 &lt;code&gt;.got&lt;/code&gt; 段中获取TLS变量的 &lt;code&gt;OFFSET&lt;/code&gt; ， 即 &lt;code&gt;OFFSET = GOT[name]&lt;/code&gt; 。最终，变量的地址为 &lt;code&gt;__aeabi_read_tp() + OFFSET&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ftls-model=local-exec&lt;/code&gt; ：静态链接时使用，要求给出 &lt;code&gt;__aeabi_read_tp()&lt;/code&gt; 的定义，此函数会返回线程 &lt;code&gt;.tdata&lt;/code&gt; 段的首地址。
然后TLS变量的 &lt;code&gt;OFFSET&lt;/code&gt; 是以立即数形式获取。最终，变量的地址为 &lt;code&gt;__aeabi_read_tp() + OFFSET&lt;/code&gt; 。
相对于 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; 少了一次内存访问的操作，效率是4种模型中最高的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwos-tls的实现&#34;&gt;XWOS TLS的实现&lt;/h2&gt;
&lt;p&gt;XWOS同时支持 &lt;code&gt;-ftls-model=initial-exec&lt;/code&gt; 和 &lt;code&gt;-ftls-model=local-exec&lt;/code&gt;，因此，需要在链接脚本中将 &lt;code&gt;.got&lt;/code&gt; 段放入：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ld&#34; data-lang=&#34;ld&#34;&gt;        .got : {
                *(.got.plt) *(.igot.plt) *(.got) *(.igot)
        } &amp;gt; code_mr AT&amp;gt; code_mr
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 线程栅栏</title>
      <link>/docs/TechRefManual/Sync/Br/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Br/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的线程栅栏是用于协调多个线程并行工作的同步机制。&lt;/p&gt;
&lt;p&gt;线程栅栏在创建时，会指明有多少个线程槽。
当线程到达线程栅栏时会阻塞并等待，直到指定数量的线程都达到线程栅栏，所有线程被同时唤醒。&lt;/p&gt;
&lt;h3 id=&#34;线程栅栏对象与对象描述符描述符&#34;&gt;线程栅栏对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;线程栅栏对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，线程栅栏对象也用 &lt;strong&gt;线程栅栏对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__br__d.html&#34;&gt;&lt;code&gt;xwos_br_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;线程栅栏对象描述符由 &lt;strong&gt;线程栅栏对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_br &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; br; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 线程栅栏对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_br_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;线程栅栏的初始化销毁与动态创建删除&#34;&gt;线程栅栏的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga14263f3e94d189d110eb62bdceca51b5&#34;&gt;&lt;code&gt;xwos_br_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的线程栅栏： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gadf0ab06127734021e54209b8fb9b8cf1&#34;&gt;&lt;code&gt;xwos_br_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga01340bc335a510cde0aea244ae6e55b0&#34;&gt;&lt;code&gt;xwos_br_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的线程栅栏： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga0562246ab3c7f893323c9103b93bdaba&#34;&gt;&lt;code&gt;xwos_br_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通过线程栅栏同步线程&#34;&gt;通过线程栅栏同步线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga6b28c7fe0cb6e0569f5bdc93fa7f0afe&#34;&gt;&lt;code&gt;xwos_br_wait()&lt;/code&gt;&lt;/a&gt; ：等待所有线程到达栅栏，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga22bb233fcefa640a3d3e196eac1c5753&#34;&gt;&lt;code&gt;xwos_br_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待所有线程到达栅栏，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_br_bind()&lt;/code&gt;&lt;/a&gt; 将线程栅栏绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当指定数量的线程抵达线程栅栏时，线程栅栏会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的线程栅栏可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_br_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;线程栅栏对象的生命周期管理&#34;&gt;线程栅栏对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;线程栅栏对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
线程栅栏对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga7402fda20860499d41f347a0b69ded8b&#34;&gt;&lt;code&gt;xwos_br_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae9d7efa29affa54491a5bc59e12f5691&#34;&gt;&lt;code&gt;xwos_br_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga5ad53ec7b82b801714b872f580896db4&#34;&gt;&lt;code&gt;xwos_br_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafd544bdd7b0b78a883ecb7eb66b7ea31&#34;&gt;&lt;code&gt;xwos_br_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/br.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程栅栏</title>
      <link>/docs/UserManual/App/Sync/Br/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Sync/Br/</guid>
      <description>
        
        
        &lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__br.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/br.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号选择器</title>
      <link>/docs/TechRefManual/Sync/Sel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Sel/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;信号选择器类似于事件标志，使用位图来管理一组 &lt;strong&gt;同步对象&lt;/strong&gt; 。使得单一线程可以同时等待多个 &lt;strong&gt;同步对象&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 &lt;strong&gt;同步对象&lt;/strong&gt; 在信号选择器位图中都绑定一个特定的 &lt;strong&gt;位&lt;/strong&gt; ，&lt;/p&gt;
&lt;p&gt;当这些 &lt;strong&gt;同步对象&lt;/strong&gt; 发送 &lt;strong&gt;选择信号&lt;/strong&gt; 时，信号选择器位图中特定的 &lt;strong&gt;位&lt;/strong&gt; 被置 &lt;strong&gt;1&lt;/strong&gt; ，同时唤醒正在等待信号选择器的线程。
线程唤醒后可以通过检测哪些 &lt;strong&gt;位&lt;/strong&gt; 被置 &lt;strong&gt;1&lt;/strong&gt; 来判断哪些 &lt;strong&gt;同步对象&lt;/strong&gt; 发送了 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;信号选择器对象与对象描述符描述符&#34;&gt;信号选择器对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;信号选择器对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，信号选择器对象也用 &lt;strong&gt;信号选择器对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__sel__d.html&#34;&gt;&lt;code&gt;xwos_sel_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;信号选择器对象描述符由 &lt;strong&gt;信号选择器对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sel &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sel; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 信号选择器对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_sel_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;同步对象的绑定与解绑&#34;&gt;同步对象的绑定与解绑&lt;/h2&gt;
&lt;p&gt;XWOS中所有 &lt;strong&gt;同步对象&lt;/strong&gt; 都带有两个相似的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绑定
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4a04b2c6003ed59a0f82c7b8ed8c7f68&#34;&gt;&lt;code&gt;xwos_sem_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_cond_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga534a3b72742f053a82aa431765bdf63b&#34;&gt;&lt;code&gt;xwos_flg_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_br_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga55059a1edf93b0554bf89112a884acb3&#34;&gt;&lt;code&gt;xwos_sel_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解绑
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4aab3913939aa6cfa040af1039e564d5&#34;&gt;&lt;code&gt;xwos_sem_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_cond_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga7f2340c7a08c61f3ae440b66675543aa&#34;&gt;&lt;code&gt;xwos_flg_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_br_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga5adbc4dcb319feccd63056cbf3d76e0c&#34;&gt;&lt;code&gt;xwos_sel_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同步对象&lt;/strong&gt; 绑定操作又分为 &lt;strong&gt;独占绑定&lt;/strong&gt; 与 &lt;strong&gt;非独占绑定&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占绑定：是指 &lt;strong&gt;同步对象&lt;/strong&gt; 一旦绑定了信号选择器位图中的某一位后，其他 &lt;strong&gt;同步对象&lt;/strong&gt; 不可再绑定此位，发送的 &lt;strong&gt;选择信号&lt;/strong&gt; 也被称为 &lt;strong&gt;独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;非独占绑定：是指 &lt;strong&gt;同步对象&lt;/strong&gt; 一旦绑定了信号选择器位图中的某一位后，其他 &lt;strong&gt;同步对象&lt;/strong&gt; 还可继续再绑定此位，发送的 &lt;strong&gt;选择信号&lt;/strong&gt; 也被称为 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同步对象&lt;/strong&gt; 采用的绑定方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量：独占绑定&lt;/li&gt;
&lt;li&gt;条件量：非独占绑定&lt;/li&gt;
&lt;li&gt;事件标志：非独占绑定&lt;/li&gt;
&lt;li&gt;线程栅栏：非独占绑定&lt;/li&gt;
&lt;li&gt;信号选择器：非独占绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;选择信号&#34;&gt;选择信号&lt;/h2&gt;
&lt;h3 id=&#34;选择信号的设置&#34;&gt;选择信号的设置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选择信号&lt;/strong&gt; 的设置，对于不同的 &lt;strong&gt;同步对象&lt;/strong&gt; 有不同解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量
&lt;ul&gt;
&lt;li&gt;计数器的值大于 &lt;strong&gt;0&lt;/strong&gt; 时就会被设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;条件量
&lt;ul&gt;
&lt;li&gt;广播操作： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6a85c4b4f0a48d8f7af6d1eb9edf5828&#34;&gt;&lt;code&gt;xwos_cond_broadcast()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件标志
&lt;ul&gt;
&lt;li&gt;事件标志位图中任何一位发生改变的操作：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga4bbbb700f8945d8a477ecdf8f48e1be3&#34;&gt;&lt;code&gt;xwos_flg_s1m()&lt;/code&gt;&lt;/a&gt; ：同时设置多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaa512cf8063cc538dbb431dbc680b1d78&#34;&gt;&lt;code&gt;xwos_flg_s1i()&lt;/code&gt;&lt;/a&gt; ：设置单个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gad9d0bd13e3b0c853597b982d348fd6dd&#34;&gt;&lt;code&gt;xwos_flg_c0m()&lt;/code&gt;&lt;/a&gt; ：同时清除多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga48c1627edd80a59ad4f88c3a91fb8bf0&#34;&gt;&lt;code&gt;xwos_flg_c0i()&lt;/code&gt;&lt;/a&gt; ：清除单个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga422b4ec657c8baf31cf35a141ae0bff1&#34;&gt;&lt;code&gt;xwos_flg_x1m()&lt;/code&gt;&lt;/a&gt; ：同时翻转多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga42d2e3e4536d53490ba1590aefdcaac2&#34;&gt;&lt;code&gt;xwos_flg_x1i()&lt;/code&gt;&lt;/a&gt; ：翻转单个事件标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程栅栏
&lt;ul&gt;
&lt;li&gt;所有线程抵达栅栏处，并同时被唤醒；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号选择器
&lt;ul&gt;
&lt;li&gt;信号选择器本身也是 &lt;strong&gt;同步对象&lt;/strong&gt; ，也可绑定在另一个信号选择器上。当源信号选择器收到了 &lt;strong&gt;选择信号&lt;/strong&gt; ，会将其传递到绑定的另一个目的信号选择器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Sync/Sel/xwos-sel_hudcf9cb7156ebc4dfb2218a5a4fe7da02_94248_800x600_fill_catmullrom_smart1_3.png&#34; width=&#34;800&#34; height=&#34;600&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS信号选择器示意图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;选择信号的清除&#34;&gt;选择信号的清除&lt;/h3&gt;
&lt;h4 id=&#34;独占-方式的-选择信号&#34;&gt;&lt;strong&gt;独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;信号量：当信号量中的计数器的值小于等于 &lt;strong&gt;0&lt;/strong&gt; 时， &lt;strong&gt;选择信号&lt;/strong&gt; 才会被清除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;非独占-方式的-选择信号&#34;&gt;&lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;非独占&lt;/strong&gt; 方式绑定的 &lt;strong&gt;同步对象&lt;/strong&gt; 向信号选择器发送 &lt;strong&gt;选择信号&lt;/strong&gt; 后，其位图中的位置会被置 &lt;strong&gt;1&lt;/strong&gt; 。
同时会唤醒所有等待的线程，此时线程们会竞争进入信号选择器的临界区。&lt;/p&gt;
&lt;p&gt;最先进入的线程会读取信号选择器的 &lt;strong&gt;选择信号&lt;/strong&gt; 位图，并与调用函数时传递的 &lt;strong&gt;掩码&lt;/strong&gt; 进行比较，判断是否有 &lt;strong&gt;掩码&lt;/strong&gt; 中的 &lt;strong&gt;选择信号&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有，会清除信号选择器位图中 &lt;strong&gt;所有&lt;/strong&gt; 的 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ，包括 &lt;strong&gt;掩码&lt;/strong&gt; 中没有设置的 &lt;strong&gt;选择信号&lt;/strong&gt; 。
因此后续线程将无法再检测到任何 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ，会重新阻塞等待。
XWOS不推荐在信号选择器上，多于一个线程等待。&lt;/li&gt;
&lt;li&gt;如果没有，线程会重新阻塞等待，然后下一个线程进入临界区检测。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;信号选择器的初始化销毁与动态创建删除&#34;&gt;信号选择器的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gaae37e3a4348e0dbee6118df0a0e91b64&#34;&gt;&lt;code&gt;xwos_sel_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的信号选择器： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga3a847008f0f8c6ced37e20de38ab8a1b&#34;&gt;&lt;code&gt;xwos_sel_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga42a5404828d0a9185276be474f9b9e46&#34;&gt;&lt;code&gt;xwos_sel_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的信号选择器： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga6c9034f4c09265ed282c8039e665f23d&#34;&gt;&lt;code&gt;xwos_sel_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待选择信号&#34;&gt;等待选择信号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gac2107de7d97466c5f6fde732b86fe0c0&#34;&gt;&lt;code&gt;xwos_sel_select()&lt;/code&gt;&lt;/a&gt; ：等待信号选择器中的 &lt;strong&gt;选择信号&lt;/strong&gt; ，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga070fb02f1220d6257b1e98a54990e2f7&#34;&gt;&lt;code&gt;xwos_sel_select_to()&lt;/code&gt;&lt;/a&gt; ：限时等待信号选择器中的 &lt;strong&gt;选择信号&lt;/strong&gt; ，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga9c635b47293e77b2d1012d6e66b3053d&#34;&gt;&lt;code&gt;xwos_sel_tryselect()&lt;/code&gt;&lt;/a&gt; ：检测信号选择器中是否有 &lt;strong&gt;选择信号&lt;/strong&gt; ，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑其他信号选择器&#34;&gt;绑定与解绑其他信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga55059a1edf93b0554bf89112a884acb3&#34;&gt;&lt;code&gt;xwos_sel_bind()&lt;/code&gt;&lt;/a&gt; 将信号选择器绑定到另一个 &lt;strong&gt;信号选择器&lt;/strong&gt; 上，形成传递链。
但信号选择器不可相互绑定形成循环链，否则会造成无限传递。&lt;/p&gt;
&lt;p&gt;绑定后的信号选择器可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga5adbc4dcb319feccd63056cbf3d76e0c&#34;&gt;&lt;code&gt;xwos_sel_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;信号选择器对象的生命周期管理&#34;&gt;信号选择器对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;信号选择器对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
信号选择器对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga3b26f1ae6f050c2251b81ad992b7edc3&#34;&gt;&lt;code&gt;xwos_sel_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gad4f2be2d1f0e894957b2491b540c44d2&#34;&gt;&lt;code&gt;xwos_sel_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga73d231bc26cb34ce5cda1d39c33f6dfc&#34;&gt;&lt;code&gt;xwos_sel_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga8bb0a86f605e1dd71cfcd7b18afb0c4c&#34;&gt;&lt;code&gt;xwos_sel_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sel.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号选择器</title>
      <link>/docs/UserManual/App/Sync/Sel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/UserManual/App/Sync/Sel/</guid>
      <description>
        
        
        &lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__sel.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sel.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 开源协议</title>
      <link>/docs/License/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/License/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;XWOS核心代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;XWOS核心代码采用&lt;a href=&#34;http://mozilla.org/MPL/2.0/&#34;&gt; &lt;strong&gt;MPL-2.0&lt;/strong&gt; &lt;/a&gt;发布；&lt;/li&gt;
&lt;li&gt;适用范围： &lt;code&gt;xwos&lt;/code&gt; 、 &lt;code&gt;xwmd&lt;/code&gt; 文件夹下的源码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XWOS的外围代码&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;XWOS的外围代码采用&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt; &lt;strong&gt;Apache-2.0&lt;/strong&gt; &lt;/a&gt;发布；&lt;/li&gt;
&lt;li&gt;适用范围： &lt;code&gt;xwcd&lt;/code&gt; 、 &lt;code&gt;xwbd&lt;/code&gt; 、 &lt;code&gt;xwam&lt;/code&gt; 、 &lt;code&gt;xwbs&lt;/code&gt; 、 &lt;code&gt;xwxr&lt;/code&gt; 文件夹下的源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三方软件&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;适用范围： &lt;code&gt;xwem&lt;/code&gt; 文件夹下的源码以及 &lt;code&gt;xwbd&lt;/code&gt; 中第三方提供的驱动源码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;免责声明&lt;/strong&gt; ： XWOS项目中集成的第三方开源软件仅供参考，用户需自行检查这些软件的缺陷以及 &lt;strong&gt;LICENSE&lt;/strong&gt; ，
并 &lt;strong&gt;自行承担相关的缺陷风险及法律风险&lt;/strong&gt; 。XWOS开发团队 &lt;strong&gt;不承担任何法律责任&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
