<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XWOS – XWOS</title>
    <link>/categories/XWOS/</link>
    <description>Recent content on XWOS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="/categories/XWOS/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Libc</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/Libc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/Libc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;xwosxwos-内核对libc的依赖&#34;&gt;&lt;code&gt;XWOS/xwos&lt;/code&gt; 内核对libc的依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string.h&lt;/code&gt;：依赖 &lt;code&gt;memset()&lt;/code&gt; 、 &lt;code&gt;memcpy()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当配置了 &lt;code&gt;XWOSCFG_SKD_THD_STDC_MM&lt;/code&gt; 、 &lt;code&gt;XWOSCFG_SKD_SWT_STDC_MM&lt;/code&gt; 、
&lt;code&gt;XWOSCFG_SYNC_SEM_STDC_MM&lt;/code&gt; 、 &lt;code&gt;XWOSCFG_SYNC_COND_STDC_MM&lt;/code&gt; 、
&lt;code&gt;XWOSCFG_SYNC_EVT_STDC_MM&lt;/code&gt; 或 &lt;code&gt;XWOSCFG_LOCK_MTX_STDC_MM&lt;/code&gt; 时，
依赖 &lt;code&gt;malloc()&lt;/code&gt; 和 &lt;code&gt;free()&lt;/code&gt; 函数动态创建和删除对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inttypes.h&lt;/code&gt; 、 &lt;code&gt;stdint.h&lt;/code&gt; 、 &lt;code&gt;stddef.h&lt;/code&gt; ：XWOS的&lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt;基于标准C的基本类型进行定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdbool.h&lt;/code&gt;：依赖bool类型的定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdatomic.h&lt;/code&gt;：依赖原子操作内存屏障的定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdarg.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;code&gt;XWLIBCFG_SC&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;xwos/lib/sc.h&lt;/code&gt; 需要使用变参函数；&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt;， &lt;code&gt;xwos/lib/xwlog.c&lt;/code&gt; 需要使用变参函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdio.h&lt;/code&gt;：若 &lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; 配置为 &lt;code&gt;1&lt;/code&gt;， &lt;code&gt;xwos/lib/xwlog.c&lt;/code&gt; 中格式化日志依赖 &lt;code&gt;vsnprintf()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xwosxwmd-提供的对libc的支持&#34;&gt;&lt;code&gt;XWOS/xwmd&lt;/code&gt; 提供的对libc的支持&lt;/h2&gt;
&lt;h3 id=&#34;动态内存管理&#34;&gt;动态内存管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;stdlib.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;malloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;free()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;cfree()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;realloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;calloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;memalign()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;aligned_alloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;valloc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;pvalloc()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/newlibac/mem.c&lt;/code&gt; 提供底层支持，
并覆盖了newlib中原有的实现。 &lt;code&gt;xwmd/libc/newlibac/mem.c&lt;/code&gt; 中的实现是对 &lt;a href=&#34;../../Mm/Mempool&#34;&gt;mempool&lt;/a&gt; 的封装，
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mempool&lt;/strong&gt; 需要在 &lt;code&gt;board_init()&lt;/code&gt; 中选择内存设备进行初始化后才可使用，并且需要提供 &lt;code&gt;newlibac_mempool&lt;/code&gt; 定义才可使用 &lt;code&gt;stdlib.h&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/picolibcac/mem.c&lt;/code&gt; 提供底层支持，
并覆盖了picolibc中原有的实现。 &lt;code&gt;xwmd/libc/picolibcac/mem.c&lt;/code&gt; 中的实现是对 &lt;a href=&#34;../../Mm/Mempool&#34;&gt;mempool&lt;/a&gt; 的封装，
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mempool&lt;/strong&gt; 需要在 &lt;code&gt;board_init()&lt;/code&gt; 中选择内存设备进行初始化后才可使用，并且需要提供 &lt;code&gt;picolibcac_mempool&lt;/code&gt; 定义才可使用 &lt;code&gt;stdlib.h&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;newlibac_mempool&lt;/code&gt; 或 &lt;code&gt;picolibcac_mempool&lt;/code&gt; 需要BSP中提供定义，不同的工程情况不一致，XWOS项目组提供几个示例工程，
可以参考工程的 &lt;code&gt;README.md&lt;/code&gt; 中的 &lt;code&gt;libc&lt;/code&gt; 章节获得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/ATKSTM32F407ZXWOS.git&#34;&gt;ATKSTM32F407ZXWOS&lt;/a&gt;：正点原子F407核心板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/EmbedFireStm32H743XWOS.git&#34;&gt;EmbedFireStm32H743XWOS&lt;/a&gt;：野火STM32H743-Pro开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/AtkApolloH743XWOS.git&#34;&gt;AtkApolloH743XWOS&lt;/a&gt;：正点原子阿波罗STM32H743开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/FK429M1XWOS.git&#34;&gt;FK429M1XWOS&lt;/a&gt;：反客STM32F429-M1开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/WeActMiniStm32H750XWOS.git&#34;&gt;WeActMiniStm32H750XWOS&lt;/a&gt;：微行电子MiniStm32H750开发板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;setjmplongjmp&#34;&gt;&lt;code&gt;setjmp()/longjmp()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 函数对可实现在不同函数间的 &lt;code&gt;goto&lt;/code&gt; 。
用户应该使用头文件 &lt;code&gt;xwos/lib/setjmp.h&lt;/code&gt; 中代替标准C的头文件 &lt;code&gt;setjmp.h&lt;/code&gt; ，
并且也应该使用 &lt;code&gt;xwlib_setjmp()&lt;/code&gt; 与 &lt;code&gt;xwlib_longjmp()&lt;/code&gt; 函数对代替 &lt;code&gt;setjmp()/longjmp()&lt;/code&gt; 函数 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 函数对。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;setjmp()/longjmp()&lt;/code&gt; 在 MISRA-C2012标准中被禁止使用。&lt;/p&gt;
&lt;h3 id=&#34;errno&#34;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;XWOS重构了 &lt;code&gt;errno&lt;/code&gt; 的实现，将 &lt;code&gt;errno&lt;/code&gt; 改为每个线程的私有变量，
线程访问 &lt;code&gt;errno&lt;/code&gt; 时，只会访问自己的 &lt;code&gt;errno&lt;/code&gt; 。
用户应该使用 &lt;code&gt;xwos/lib/errno.h&lt;/code&gt; 替代libc中的 &lt;code&gt;errno.h&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时， &lt;code&gt;errno&lt;/code&gt; 的实现位于 &lt;code&gt;xwmd/libc/newlibac/errno.c&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时， &lt;code&gt;errno&lt;/code&gt; 的实现位于 &lt;code&gt;xwmd/libc/picolibcac/errno.c&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 头文件 &lt;code&gt;stdio.h&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fopen()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fclose()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fread()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fwrite()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;fseek()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;remove()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;rename()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据配置中选择的libc：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;newlib&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/newlibac/fops.c&lt;/code&gt; 提供底层支持，
&lt;code&gt;xwmd/libc/newlibac/fops.c&lt;/code&gt; 又依赖第三方软件 &lt;a href=&#34;http://elm-chan.org/fsw/ff/00index_e.html&#34;&gt;&lt;code&gt;xwem/fs/fatfs&lt;/code&gt;&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 配置为 &lt;code&gt;picolibc&lt;/code&gt; 时，这些函数由 &lt;code&gt;xwmd/libc/picolibcac/fops.c&lt;/code&gt; 提供底层支持，
&lt;code&gt;xwmd/libc/picolibcac/fops.c&lt;/code&gt; 又依赖第三方软件 &lt;a href=&#34;http://elm-chan.org/fsw/ff/00index_e.html&#34;&gt;&lt;code&gt;xwem/fs/fatfs&lt;/code&gt;&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FatFs需要BSP中提供对块设备操作的支持，不同的电路板对文件操作的支持情况不一致，XWOS项目组提供几个示例工程，
可以参考工程的 &lt;code&gt;README.md&lt;/code&gt; 中的 &lt;code&gt;FatFS&lt;/code&gt; 章节获得说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/ATKSTM32F407ZXWOS.git&#34;&gt;ATKSTM32F407ZXWOS&lt;/a&gt;：正点原子F407核心板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/EmbedFireStm32H743XWOS.git&#34;&gt;EmbedFireStm32H743XWOS&lt;/a&gt;：野火STM32H743-Pro开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/AtkApolloH743XWOS.git&#34;&gt;AtkApolloH743XWOS&lt;/a&gt;：正点原子阿波罗STM32H743开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/FK429M1XWOS.git&#34;&gt;FK429M1XWOS&lt;/a&gt;：反客STM32F429-M1开发板&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitee.com/xwos/WeActMiniStm32H750XWOS.git&#34;&gt;WeActMiniStm32H750XWOS&lt;/a&gt;：微行电子MiniStm32H750开发板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tls&#34;&gt;TLS&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;stdatomic&#34;&gt;stdatomic&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;数学库&#34;&gt;数学库&lt;/h3&gt;
&lt;p&gt;若SOC有FPU，并且配置 &lt;code&gt;ARCHCFG_FPU&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，则支持 &lt;code&gt;libm&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;其他libc的功能&#34;&gt;其他libc的功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; ctype: 字符类型&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; wchar: 多字节字符&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; iconv: 字符集转换&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; locale: 区域，暂时不支持&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; search: 查找&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; argz: 字符串数组&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; time: 时间，暂时不支持，需要底层提供RTC的驱动&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 软件架构</title>
      <link>/docs/TechRefManual/Architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Architecture/</guid>
      <description>
        
        
        &lt;p&gt;XWOS在设计时就充分考虑了代码的复用性、移植性以及与第三方软件的兼容性，
代码被架构成多层结构：构建系统、BSP、操作系统内核、中间件和应用。&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 913px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Architecture/xwos-arch_hud68e8e8565694c7eb1f134c79006dda4_264347_903x688_fill_catmullrom_smart1_3.png&#34; width=&#34;903&#34; height=&#34;688&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS架构图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h2 id=&#34;构建系统&#34;&gt;构建系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbs&lt;/code&gt; : 构建系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bsp&#34;&gt;BSP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd&lt;/code&gt; : 编译器、CPU、SOC、外设驱动相关的代码
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd/ds&lt;/code&gt; : 玄武设备栈，XWOS的驱动框架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/perpheral&lt;/code&gt; : 基于玄武设备栈，实现的各种外设驱动，代码可被不同SOC共享&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/soc&lt;/code&gt; : 不同SOC的XWOS移植实现层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbd&lt;/code&gt; : 不同电路板的工程配置、调试脚本、链接脚本、驱动与应用。电路板目录还可以放在其他位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统内核&#34;&gt;操作系统内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos&lt;/code&gt; : 内核
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos/osal&lt;/code&gt; : 操作系统抽象层，统一的内核API，不区分操作系统的具体实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/ospl&lt;/code&gt; : 操作系统移植层，其中定义了内核提供给BSP的回调函数以及BSP需要提供给内核的函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/lib&lt;/code&gt; : 基本C函数库，包括原子操作库、位操作库、数据结构等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mm&lt;/code&gt; : 内存管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mp&lt;/code&gt; : 多核(mp)内核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/up&lt;/code&gt; : 单核(up)内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中间件&#34;&gt;中间件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd&lt;/code&gt; : 中间件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc&lt;/code&gt; : 系统间的通讯机制
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwcq&lt;/code&gt; : 线程间的循环队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwmq&lt;/code&gt; : 线程间的消息队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwssc&lt;/code&gt; : SOC与SOC间的点对点通讯协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/libc&lt;/code&gt; : 标准C库的适配代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/xwrust&lt;/code&gt; : XWOS RUST框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem&lt;/code&gt; : 第三方开源软件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/fs&lt;/code&gt; : 各种开源的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing&lt;/code&gt; : 序列化与反序列化
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing/nanopb&lt;/code&gt; : protocol-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/vm&lt;/code&gt; : 虚拟机
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/vm/lua&lt;/code&gt; : Lua语言虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwam&lt;/code&gt; : 参考代码以及应用代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwxr&lt;/code&gt; : API文档生成配置&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 位操作库</title>
      <link>/docs/TechRefManual/Xwlib/Xwbop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Xwbop/</guid>
      <description>
        
        
        &lt;h2 id=&#34;位操作&#34;&gt;位操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了位操作模板库， &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; 中定义的
各种 &lt;strong&gt;非函数指针类型&lt;/strong&gt; 都可使用位操作。位操作函数模板包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbop_s1m()&lt;/code&gt; ：将数据掩码部分的位全部置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_c0m()&lt;/code&gt; ：将数据掩码部分的位全部清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_x1m()&lt;/code&gt; ：将数据掩码部分的位全部翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_rbit()&lt;/code&gt; ：将数据的位镜面翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_re()&lt;/code&gt; ：将数据的大小端翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_ffs()&lt;/code&gt; ：在数据中从最低位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_fls()&lt;/code&gt; ：在数据中从最高位起查找第一个被置1的位1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_ffz()&lt;/code&gt; ：在数据中从最低位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_flz()&lt;/code&gt; ：在数据中从最高位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbop_weight()&lt;/code&gt; ：统计数据中1的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有位操作函数的第一个参数均为 &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; ，
第二个参数是数据或数据的指针，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwssq_t&lt;/span&gt; idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从最低位开始查找&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0&amp;#34;中第一个被置1的位，结果为-1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_ffs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从最低位开始查找&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0xF0&amp;#34;中第一个被置1的位，结果为4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_ffs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0xF0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 将&amp;#34;xwu32_t&amp;#34;类型的数据&amp;#34;0xAA&amp;#34;进行镜像翻转，结果为0x55 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt; rdata &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwbop_rbit&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwu32_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0xAA&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;位图操作&#34;&gt;位图操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了基本类型 &lt;code&gt;xwbmp_t&lt;/code&gt; ，用于定义位图，位图是 &lt;code&gt;xwbmp_t&lt;/code&gt; 的数组。
用户可以声明任意位数的位图，XWOS提供了函数集方便用户操作位图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_declare()&lt;/code&gt; ：声明位图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_assign()&lt;/code&gt; ：赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_cmp()&lt;/code&gt; ：比较两个位图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1all()&lt;/code&gt; ：所有位置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0all()&lt;/code&gt; ：所有位清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1i()&lt;/code&gt; ：将位图中某位置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_s1m()&lt;/code&gt; ：将位图中掩码部分置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0i()&lt;/code&gt; ：将位图中某位清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_c0m()&lt;/code&gt; ：将位图中掩码部分清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_x1i()&lt;/code&gt; ：将位图中某位翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_x1m()&lt;/code&gt; ：将位图中掩码部分翻转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1i()&lt;/code&gt; ：测试位图中的某位是否为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1ma()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1ma_then_c0m()&lt;/code&gt; ：测试位图中掩码部分是否全部为1，如果是，就将掩码部分全部清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1mo()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t1mo_then_c0m()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为1，如果是，就将掩码部分全部清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0ma()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0ma_then_s1m()&lt;/code&gt; ：测试位图中掩码部分是否全部为 &lt;strong&gt;0&lt;/strong&gt; ，如果是，就将掩码部分全部置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0mo()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_t0mo_then_s1m()&lt;/code&gt; ：测试位图中掩码部分是否至少有一位为 &lt;strong&gt;0&lt;/strong&gt; ，如果是，就将掩码部分全部置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_not()&lt;/code&gt; ：非运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_and()&lt;/code&gt; ：与运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_or()&lt;/code&gt; ：或运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_xor()&lt;/code&gt; ：异或运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_ffs()&lt;/code&gt; ：从最低位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_fls()&lt;/code&gt; ：从最高位起查找第一个被置1的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_ffz()&lt;/code&gt; ：从最低位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_flz()&lt;/code&gt; ：从最高位起查找第一个被清0的位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpop_weight()&lt;/code&gt; ：统计 &lt;strong&gt;1&lt;/strong&gt; 的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwbop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwbop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 消息队列</title>
      <link>/docs/TechRefManual/Isc/Xwmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/Xwmq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的消息队列（xwmq）采用双循环链表实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart LR
    Head --&amp;gt; Msg1 --&amp;gt; Head
    Msg1 --&amp;gt; Msg2 --&amp;gt; Msg1
    Msg2 --&amp;gt; Msg3 --&amp;gt; Msg2
    Msg3 --&amp;gt; Msg4 --&amp;gt; Msg3
    Msg4 --&amp;gt; Msg5 --&amp;gt; Msg4
    Msg5 --&amp;gt; Msg6 --&amp;gt; Msg5
    Msg6 --&amp;gt; Msg7 --&amp;gt; Msg6
    Msg7 --&amp;gt; Head --&amp;gt; Msg7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息可发送到队列的头部，也可以发送到队列的尾部。
消息可以从队列的头部接收，也可以从队列的尾部接收。&lt;/p&gt;
&lt;h3 id=&#34;消息队列的消息&#34;&gt;消息队列的消息&lt;/h3&gt;
&lt;p&gt;消息队列的每个节点是 &lt;a href=&#34;../../../../api/structxwmq__msg.html&#34;&gt;&lt;code&gt;struct xwmq_msg&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq_msg {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; data;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; topic;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwlib_bclst_node node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; ：消息的数据，只能传递一个指针长度的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topic&lt;/code&gt; ：消息的主题，由用户自定义主题的含义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt; ：链表节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息槽&#34;&gt;消息槽&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;消息槽&lt;/strong&gt; 是消息队列初始化时，用户定义的消息数组。消息队列中的消息数量最多等于消息槽的数量。&lt;/p&gt;
&lt;h3 id=&#34;消息队列对象与对象描述符描述符&#34;&gt;消息队列对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;消息队列对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，消息队列对象也用 &lt;strong&gt;消息队列对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwmq__d.html&#34;&gt;&lt;code&gt;xwmq_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;消息队列对象描述符由 &lt;strong&gt;消息队列对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mq; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 消息队列对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwmq_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;消息队列的消息只能发送一个和指针长度一样的数据。
如果需要发送比较大的数据，只能将数据的缓冲区的首地址发送出去。
若数据缓冲区是通过向动态内存管理申请而来，用户需要特别小心，数据缓冲区不能被意外地释放掉。&lt;/p&gt;
&lt;h2 id=&#34;消息队列的静态初始化销毁&#34;&gt;消息队列的静态初始化、销毁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga51603f04fac6de40ea6726d69b264cc7&#34;&gt;&lt;code&gt;xwmq_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;初始化消息队列时，需要预先定义消息数组作为消息槽。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq brd_mq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwmq_msg brd_mq_txq[&lt;span style=&#34;color:#666&#34;&gt;16&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 最多16个消息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;brd_init_xwmq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwmq_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;brd_mq, brd_mq_txq, &lt;span style=&#34;color:#00a000&#34;&gt;xw_array_size&lt;/span&gt;(brd_mq_txq));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga57fec3e151fbf8044a2b7092ab2972b3&#34;&gt;&lt;code&gt;xwmq_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列的动态创建删除&#34;&gt;消息队列的动态创建、删除&lt;/h2&gt;
&lt;p&gt;XWOS并未提供基于动态内存管理的创建与删除CAPI。&lt;/p&gt;
&lt;h2 id=&#34;发送消息&#34;&gt;发送消息&lt;/h2&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt; 是指将消息发送到消息队列的 &lt;strong&gt;尾端&lt;/strong&gt; ，发送之前需要获取一个可用的消息槽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#gad8d2b0b29234d2959a05eeb67a23ff45&#34;&gt;&lt;code&gt;xwmq_eq()&lt;/code&gt;&lt;/a&gt; ：等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8359c9ba02c8fb2a74e6c4c6094d94cc&#34;&gt;&lt;code&gt;xwmq_eq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8a32f1b107baef4bc25957bca4d4bddd&#34;&gt;&lt;code&gt;xwmq_eq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga30b3fc4cf9323d3597eb8a383bdf611f&#34;&gt;&lt;code&gt;xwmq_tryeq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息槽，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插队&#34;&gt;插队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;插队&lt;/strong&gt; 是指将消息发送到消息队列的 &lt;strong&gt;首端&lt;/strong&gt; ，发送之前需要获取一个可用的消息槽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga18b4d97f9de46feb6eebd197738aabf6&#34;&gt;&lt;code&gt;xwmq_jq()&lt;/code&gt;&lt;/a&gt; ：等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga0eb1aa3f3e83b696612a7cd9cc90a6f2&#34;&gt;&lt;code&gt;xwmq_jq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga3c6e22dce3a927f790d95f1e294c5789&#34;&gt;&lt;code&gt;xwmq_jq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息槽，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga706a753c885996d85ec7fbf6d7461385&#34;&gt;&lt;code&gt;xwmq_tryjq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息槽，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接收消息&#34;&gt;接收消息&lt;/h2&gt;
&lt;h3 id=&#34;首端离队&#34;&gt;首端离队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首端离队&lt;/strong&gt; 是指从消息队列的 &lt;strong&gt;首端&lt;/strong&gt; 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga6dac123dd10ceaf0f24181b66d49d39a&#34;&gt;&lt;code&gt;xwmq_dq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga9b11a75d7c8d792d305154b32c3dedee&#34;&gt;&lt;code&gt;xwmq_dq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga98fe6e199b379e49ed413db1435f5b3a&#34;&gt;&lt;code&gt;xwmq_dq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga113bc97ec8121f3eb884e8da900497eb&#34;&gt;&lt;code&gt;xwmq_trydq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端离队&#34;&gt;尾端离队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;尾端离队&lt;/strong&gt; 是指从消息队列的 &lt;strong&gt;尾端&lt;/strong&gt; 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga79b5a6769a655a4e5946f3d60729b342&#34;&gt;&lt;code&gt;xwmq_rq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#gaacdb3c6bfb639e6d2444f479e9557c38&#34;&gt;&lt;code&gt;xwmq_rq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga1ebf67fde973c23ec718d35258dd7ee1&#34;&gt;&lt;code&gt;xwmq_rq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga7c48b58030cf580f089d2cb42bc644fd&#34;&gt;&lt;code&gt;xwmq_tryrq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列对象的生命周期管理&#34;&gt;消息队列对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;消息队列对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
消息队列对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga8b86e4a1725d0d9363ee8a31095222c9&#34;&gt;&lt;code&gt;xwmq_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga3a7d5f642c3629ebfcf03e7721efd4c2&#34;&gt;&lt;code&gt;xwmq_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga1357e7c300f83638ef7758e1395e423d&#34;&gt;&lt;code&gt;xwmq_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwmq.html#ga57efc774777e38855532c6f6be1e4504&#34;&gt;&lt;code&gt;xwmq_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwmd__isc__xwmq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwmd/isc/xwmq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号量</title>
      <link>/docs/TechRefManual/Sync/Sem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Sem/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;信号量是操作系统比较底层的同步机制，是一个带有 &lt;strong&gt;等待队列&lt;/strong&gt; 的计数器。&lt;/p&gt;
&lt;p&gt;信号量中包含一个整数计数器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当信号量的值等于 &lt;strong&gt;0&lt;/strong&gt; 时，线程们就在 &lt;strong&gt;等待队列&lt;/strong&gt; 中等待信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; 时，可以唤醒一个正在等待的线程。线程被唤醒后会取走一个值，信号量的值减少 &lt;strong&gt;1&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当信号量的值小于 &lt;strong&gt;0&lt;/strong&gt; ，信号量处于 &lt;strong&gt;冻结&lt;/strong&gt; 状态，理论中的信号量不存在此状态，这是XWOS的扩张。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任意上下文都可增加信号量的值，这个操作被称为 &lt;strong&gt;发布&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;信号量常常用于在中断中唤醒一个线程，并将耗时较长的操作放在线程中执行。可减少中断上下文的执行时间，增加中断吞吐量，降低中断延迟。&lt;/p&gt;
&lt;p&gt;XWOS内核的信号量有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管道信号量(PipelineSemaphore)：对所有阻塞在其等待队列中的线程按照先进先出(FIFO)的策略调度，
即当信号量可用时，最先进入等待队列中的线程将优先获得信号量。&lt;/li&gt;
&lt;li&gt;实时信号量(ReltimeSemaphore)：对所有阻塞在其等待队列中的线程按照优先级进行调度，即高优先级
的线程总是最先获得信号量，同优先级的线程按先进先出(FIFO)的策略调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作系统抽象层(OSAL)的CAPI只封装了一种信号量，当系统配置文件中同时配置了管道信号量与实时信号量时， &lt;strong&gt;优先使用实时信号量&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;信号量对象与对象描述符描述符&#34;&gt;信号量对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;信号量对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，信号量对象也用 &lt;strong&gt;信号量对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__sem__d.html&#34;&gt;&lt;code&gt;xwos_sem_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;信号量对象描述符由 &lt;strong&gt;信号量对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sem &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sem; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 信号量对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_sem_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;信号量的初始化销毁与动态创建删除&#34;&gt;信号量的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;p&gt;信号量创建时需要指定两个参数： &lt;strong&gt;初始值&lt;/strong&gt; 和 &lt;strong&gt;最大值&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gaef37596ed9c49312579530b2218150ad&#34;&gt;&lt;code&gt;xwos_sem_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga91a3f44977a865f10e9a46f13e261d3a&#34;&gt;&lt;code&gt;xwos_sem_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gadebdd16a61933d67d2702355fcd543e2&#34;&gt;&lt;code&gt;xwos_sem_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的信号量： &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga5bac50165dee16acce035f3a88d96d1b&#34;&gt;&lt;code&gt;xwos_sem_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;发布信号量&#34;&gt;发布信号量&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gaf6f291eaa8c268dccb6ebc675a24755b&#34;&gt;&lt;code&gt;xwos_sem_post()&lt;/code&gt;&lt;/a&gt; 在 &lt;strong&gt;任意&lt;/strong&gt; 上下文增加信号量的值。
当信号量的值大与 &lt;strong&gt;0&lt;/strong&gt; 时，会唤醒信号量等待队列中的一个线程。被唤醒的线程会取走一个值，使得信号量的计数器减1。&lt;/p&gt;
&lt;h2 id=&#34;等待信号量&#34;&gt;等待信号量&lt;/h2&gt;
&lt;p&gt;当信号量的值大于 &lt;strong&gt;0&lt;/strong&gt; 时，可以直接取走一个，此时信号量的值减 &lt;strong&gt;1&lt;/strong&gt; ；
当信号量的值等于 &lt;strong&gt;0&lt;/strong&gt; 时，获取信号量的线程就只能阻塞等待，XWOS提供四种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga5a7b38f68e2fc5159909a1eb4b7db7a2&#34;&gt;&lt;code&gt;xwos_sem_wait()&lt;/code&gt;&lt;/a&gt; ：等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gab9fce6b4dc3add4c714dfa1c8041593f&#34;&gt;&lt;code&gt;xwos_sem_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga794e05587874027d02d0e4c87f9c2893&#34;&gt;&lt;code&gt;xwos_sem_wait_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断等待并获取信号量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga453bbb4747cdd5cc94ddb9b988ee0866&#34;&gt;&lt;code&gt;xwos_sem_trywait()&lt;/code&gt;&lt;/a&gt; ：尝试获取信号量，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读取信号量的状态&#34;&gt;读取信号量的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号量中计数器的最大值可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga31696885ee6e7bfe699273225f061a7e&#34;&gt;&lt;code&gt;xwos_sem_get_max()&lt;/code&gt;&lt;/a&gt; 读取。这个最大值是在信号量初始化或创建时设置的。&lt;/li&gt;
&lt;li&gt;信号量中计数器的值可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga25b85b8a30ba1f3f1453feecd7a71343&#34;&gt;&lt;code&gt;xwos_sem_get_value()&lt;/code&gt;&lt;/a&gt; 读取。此CAPI只读取，不会改变信号量的值，也不会等待信号量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;冻结与解冻&#34;&gt;冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;冻结&#34;&gt;冻结&lt;/h3&gt;
&lt;p&gt;信号量可以使用 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga9f215ee967e9f3dbd1d7e34402109849&#34;&gt;&lt;code&gt;xwos_sem_freeze()&lt;/code&gt;&lt;/a&gt; 进行 &lt;strong&gt;冻结&lt;/strong&gt;，
被冻结的信号量的值为负数，不影响对信号量的 &lt;strong&gt;等待&lt;/strong&gt; 操作。但不能 &lt;strong&gt;发布&lt;/strong&gt; 信号量。&lt;/p&gt;
&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gadbbb35963b95d865ddb392a97639ec87&#34;&gt;&lt;code&gt;xwos_sem_thaw()&lt;/code&gt;&lt;/a&gt; 可将已经冻结的信号量 &lt;strong&gt;解冻&lt;/strong&gt; 。
信号量 &lt;strong&gt;解冻&lt;/strong&gt; 后，值被重置为0，此时可重新开始发布信号量。&lt;/p&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4a04b2c6003ed59a0f82c7b8ed8c7f68&#34;&gt;&lt;code&gt;xwos_sem_bind()&lt;/code&gt;&lt;/a&gt; 将信号量绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当 &lt;strong&gt;发布&lt;/strong&gt; 信号量时，信号量会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的信号量可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4aab3913939aa6cfa040af1039e564d5&#34;&gt;&lt;code&gt;xwos_sem_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;信号量对象的生命周期管理&#34;&gt;信号量对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;信号量对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
信号量对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga70b16e65e7f3b8bbb87435804f1829d3&#34;&gt;&lt;code&gt;xwos_sem_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga83a3b567eb40632d954a35b98ecf1950&#34;&gt;&lt;code&gt;xwos_sem_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#gabd6b221831f9154af4061281e4de3bbe&#34;&gt;&lt;code&gt;xwos_sem_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga2fd69e5ea645814fa3a52241167a9e1e&#34;&gt;&lt;code&gt;xwos_sem_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__sem.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sem.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 自旋锁</title>
      <link>/docs/TechRefManual/Lock/Spinlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Spinlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;自旋锁是多核系统中为防止多个处理器同时访问公共的内存区域（称为临界区）而引入的一种锁。
当一个CPU获得自旋锁并访问临界区时，其他CPU只能 &lt;strong&gt;自旋&lt;/strong&gt; 等待锁。
所谓 &lt;strong&gt;自旋&lt;/strong&gt; ，是指不断循环测试 &lt;strong&gt;锁&lt;/strong&gt; 是否已经解开。&lt;/p&gt;
&lt;p&gt;自旋锁只是为SMP的场景设计的一种锁机制。在单核(UP)系统中，并不需要自旋锁。
但为了软件接口的统一，实现了虚假的自旋锁，只是对关闭抢占、中断底半部或中断的封装。&lt;/p&gt;
&lt;p&gt;自旋锁还伴随其他操作：内存屏障，关闭调度器的抢占，关闭中断底半部，关闭中断等。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自旋锁内包含内存内存屏障操作，内存屏障会降低CPU的性能；&lt;/li&gt;
&lt;li&gt;自旋锁不区分读和写的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用自旋锁&#34;&gt;使用自旋锁&lt;/h2&gt;
&lt;h3 id=&#34;自旋锁的初始化&#34;&gt;自旋锁的初始化&lt;/h3&gt;
&lt;p&gt;自旋锁是基于原子操作指令实现的，自旋锁结构体很小，核心数据是一个CPU指令能操作的基本数据类型，因此不提供动态创建和删除方法。
用户可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gac8bbb82a3177f919e10ef3c3d21c7608&#34;&gt;&lt;code&gt;xwos_splk_init()&lt;/code&gt;&lt;/a&gt; 初始化自旋锁。&lt;/p&gt;
&lt;h3 id=&#34;多锁&#34;&gt;多锁&lt;/h3&gt;
&lt;p&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁保护临界区时，上锁和解锁顺序必须 &lt;strong&gt;保持一致&lt;/strong&gt; ，否则会导致死锁。&lt;/p&gt;
&lt;h3 id=&#34;锁模式&#34;&gt;锁模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;临界区只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。临界区内，只会关闭抢占。
可以理解为在线程层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; 。临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
临界区内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga80e1248f482959ad664f367dd6a2123e&#34;&gt;&lt;code&gt;xwos_splk_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gad8cae0c2e4a9956f9df7b3118b6db534&#34;&gt;&lt;code&gt;xwos_splk_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga7c45ee96acf66e3ab1aba48a0f49f1c4&#34;&gt;&lt;code&gt;xwos_splk_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
临界区内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga3011217ec5d1cba45824484f507dce77&#34;&gt;&lt;code&gt;xwos_splk_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga5a37d2c7c27a7507392f15eeb03d2a02&#34;&gt;&lt;code&gt;xwos_splk_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gaba92901efc65f4e61a3e364b29d6e10c&#34;&gt;&lt;code&gt;xwos_splk_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁时，嵌套的临界区对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
临界区内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gad393963b449be923d8af40538b9befdf&#34;&gt;&lt;code&gt;xwos_splk_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga74fc2498076cc0f1b4810bd1ad9d4bff&#34;&gt;&lt;code&gt;xwos_splk_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gaa83b4a8f3340ddf35346dbedf9ce3979&#34;&gt;&lt;code&gt;xwos_splk_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
临界区内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga7e50b3ee8f605b1963bf7223c249da28&#34;&gt;&lt;code&gt;xwos_splk_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga1946f1240fb699cb9d6a252c76b0eb77&#34;&gt;&lt;code&gt;xwos_splk_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga94b35ab4ed1799807411bcfdcd1a3950&#34;&gt;&lt;code&gt;xwos_splk_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁时，嵌套的临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
临界区内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga92a795c788a274e6fb545b6d4226b01b&#34;&gt;&lt;code&gt;xwos_splk_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga17b92af6dfcf155366f46bb83f1b8ff5&#34;&gt;&lt;code&gt;xwos_splk_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga58441e6006fe5d402e06f5caaab42092&#34;&gt;&lt;code&gt;xwos_splk_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;临界区对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。临界区内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面，临界区内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ，临界区内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
临界区内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在临界区内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga3c50609a0c759cb526502a27937aab47&#34;&gt;&lt;code&gt;xwos_splk_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部，进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#ga6d6a918600518b0ed891937ec378087a&#34;&gt;&lt;code&gt;xwos_splk_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部，尝试进入临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html#gafbf75863c2f6323d6de84e4b1ce6c18a&#34;&gt;&lt;code&gt;xwos_splk_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部，退出临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;为什么没有 &lt;strong&gt;保存与恢复抢占&lt;/strong&gt; 和 &lt;strong&gt;保存与恢复中断底半部&lt;/strong&gt; 形式的CAPI ？
因为 &lt;strong&gt;关闭与打开抢占&lt;/strong&gt; 和 &lt;strong&gt;保存与恢复中断底半部&lt;/strong&gt; 是一种可重入的的 &lt;strong&gt;锁&lt;/strong&gt; ， &lt;strong&gt;关闭&lt;/strong&gt; 了多少次，对应的就要 &lt;strong&gt;打开&lt;/strong&gt; 多少次。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__spinlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/spinlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: C&#43;&#43;</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/C&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/C&#43;&#43;/</guid>
      <description>
        
        
        &lt;p&gt;XWOS内核是使用纯C语言开发的，不依赖C++的标准库。
用户可在线程中使用C++语言以及C++标准库，C++标准库由编译器提供，不完全功能清单如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; g++, libstdc++, libsupc++
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; new, delete, new[], delete[], placement new, aligned new (C++17)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 容器
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; array&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; vector&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; deque&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; map, multimap, unordered_map, unordered_multimap&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; set, multiset, unordered_set, unordered_multiset&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; list, forward_list&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; stack, queue, priority_queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; I/O stream&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; string&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; atomic&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; RTTI&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; exception&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; unwind&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; chrono&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; thread&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; mutex&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; condition_variable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm(clang++), libc++, libc++abi
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; new, delete, new[], delete[], placement new, aligned new (C++17)&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 容器
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; array&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; vector&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; deque&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; map, multimap, unordered_map, unordered_multimap&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; set, multiset, unordered_set, unordered_multiset&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; list, forward_list&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; stack, queue, priority_queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; I/O stream&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; string&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; atomic&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; RTTI&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; exception&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; unwind&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; chrono&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; thread&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; mutex&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; condition_variable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: XWOS标准</title>
      <link>/docs/TechRefManual/XwosStd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/XwosStd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;
&lt;p&gt;XWOS的所有可以确定位宽的数据类型被称为 &lt;a href=&#34;../../../capi/group__xwos__lib__type.html&#34;&gt;基本数据类型&lt;/a&gt; ，定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwu8_t&lt;/code&gt; 8位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws8_t&lt;/code&gt; 8位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu16_t&lt;/code&gt; 16位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws16_t&lt;/code&gt; 16位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu32_t&lt;/code&gt; 32位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws32_t&lt;/code&gt; 32位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu64_t&lt;/code&gt; 64位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws64_t&lt;/code&gt; 64位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsz_t&lt;/code&gt; 大小值（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssz_t&lt;/code&gt; 大小值（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwstk_t&lt;/code&gt; 栈帧（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwptr_t&lt;/code&gt; 指针的整数值（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwreg_t&lt;/code&gt; 寄存器（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsreg_t&lt;/code&gt; 寄存器（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwer_t&lt;/code&gt; 错误码（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsq_t&lt;/code&gt; 序列值/位置/偏移（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssq_t&lt;/code&gt; 序列值/位置/偏移（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsid_t&lt;/code&gt; ID（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwid_t&lt;/code&gt; ID（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* xwisr_f)(void)&lt;/code&gt; 中断向量（函数指针）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwirq_t&lt;/code&gt; 中断号（有符号），负的中断号表示系统异常，正的中断号表示外部中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwpr_t&lt;/code&gt; 优先级（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmp_t&lt;/code&gt; 位图（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwtm_t&lt;/code&gt; 时间（64位有符号整数，单位：纳秒）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlfq_t&lt;/code&gt; 无锁队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* ctor_f)(void * /*obj*/)&lt;/code&gt; 构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* dtor_f)(void * /*obj*/)&lt;/code&gt; 析构函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef xws64_t (* xwsc_f)(void * /*arg*/, ...)&lt;/code&gt; 系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据类型命名习惯&#34;&gt;数据类型命名习惯&lt;/h2&gt;
&lt;p&gt;用户在阅读XWOS源码时，要注意以下几个命名习惯的隐含意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于比较小的数据结构，XWOS会通过 &lt;code&gt;typedef&lt;/code&gt; 定义成一种类型。这种类型就像基本数据类型一样，
在函数间传递参数时是直接传递，不会使用 &lt;code&gt;type *&lt;/code&gt; 去传递指针，除非是返回数据。
&lt;ul&gt;
&lt;li&gt;命名通常是 &lt;code&gt;type_t&lt;/code&gt; 的形式，函数指针则为 &lt;code&gt;type_f&lt;/code&gt; 的形式，&lt;a href=&#34;../Xwobj##%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;对象描述符&lt;/a&gt; 则为 &lt;code&gt;xwobj_d&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于比较大的结构体，XWOS使用关键字 &lt;code&gt;struct&lt;/code&gt; 定义。XWOS代码中不会省略关键字 &lt;code&gt;struct&lt;/code&gt; 。
目的是提醒读者这是一个结构体，将它作为参数传递时是通过传递指针来引用数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原子类型&#34;&gt;原子类型&lt;/h2&gt;
&lt;p&gt;所有基本数据类型增加前缀 &lt;code&gt;atomic_&lt;/code&gt; 表示此类型的原子类型。例如： &lt;code&gt;_Atomic xwsq_t&lt;/code&gt; 等价于 &lt;code&gt;__xwcc_atomic xwsq_t&lt;/code&gt; 等价于 &lt;code&gt;atomic_xwsq_t&lt;/code&gt;。
原子类型的变量可以使用XWOS的 &lt;a href=&#34;../Xwlib/xwaop&#34;&gt;原子操作库&lt;/a&gt; 来操作，也可以使用标准C头文件 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 中定义的函数来操作。&lt;/p&gt;
&lt;h2 id=&#34;系统位数&#34;&gt;系统位数&lt;/h2&gt;
&lt;p&gt;XWOS内核支持32位与64位两种CPU。&lt;/p&gt;
&lt;h2 id=&#34;时间&#34;&gt;时间&lt;/h2&gt;
&lt;p&gt;XWOS内核使用64位有符号整数 &lt;code&gt;xwtm_t&lt;/code&gt; 表示时间，单位为纳秒。并提供一系列操作函数。&lt;/p&gt;
&lt;p&gt;详细参考头文件 &lt;a href=&#34;../../../capi/group__xwos__time.html&#34;&gt;&lt;strong&gt;xwos/osal/time.h&lt;/strong&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../Xwobj&#34;&gt;&lt;code&gt;xwos_object&lt;/code&gt;&lt;/a&gt; 是XWOS所有对象的父类。&lt;/p&gt;
&lt;h2 id=&#34;对象描述符&#34;&gt;对象描述符&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../Xwobj##%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;对象描述符&lt;/a&gt; 是XWOS为了解决对象野指针问题而引入的机制。&lt;/p&gt;
&lt;h2 id=&#34;调度器&#34;&gt;调度器&lt;/h2&gt;
&lt;p&gt;XWOS会为每个CPU创建独立的 &lt;a href=&#34;../Skd&#34;&gt;调度器&lt;/a&gt;，每个&lt;a href=&#34;../Skd&#34;&gt;调度器&lt;/a&gt; 独立调度线程，且都有一个私有的滴答定时器。&lt;/p&gt;
&lt;h2 id=&#34;滴答定时器&#34;&gt;滴答定时器&lt;/h2&gt;
&lt;p&gt;为调度器产生固定频率中断的硬件定时器。&lt;/p&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;p&gt;调度器内的基本调度单位为 &lt;a href=&#34;../Thd&#34;&gt;线程&lt;/a&gt; ，因此线程是与调度器绑定的。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器&#34;&gt;软件定时器&lt;/h2&gt;
&lt;p&gt;基于调度器的滴答定时器实现的 &lt;a href=&#34;../Swt&#34;&gt;软件定时器&lt;/a&gt; 也是与调度器绑定的。&lt;/p&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;p&gt;XWOS的锁机制有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Mutex&#34;&gt;互斥锁&lt;/a&gt; ：防止两个 &lt;strong&gt;线程&lt;/strong&gt; 竞争内存数据的锁。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Spinlock&#34;&gt;自选锁&lt;/a&gt; ：可防止任意上下文竞争内存数据的锁。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Lock/Seqlock&#34;&gt;顺序锁&lt;/a&gt; ：自选锁的改良锁，可分为读锁和写锁，读锁可共享，写锁独占。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步机制&#34;&gt;同步机制&lt;/h2&gt;
&lt;p&gt;XWOS的 &lt;strong&gt;基本同步机制&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Sem&#34;&gt;信号量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Cond&#34;&gt;条件量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Flg&#34;&gt;事件标志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Br&#34;&gt;线程栅栏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Sync/Sel&#34;&gt;信号选择器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通讯机制&#34;&gt;通讯机制&lt;/h2&gt;
&lt;p&gt;基于 &lt;strong&gt;基本同步机制&lt;/strong&gt; ，XWOS的中间件XWMD提供了线程间的通讯机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../Isc/Xwmq&#34;&gt;消息队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../Isc/Xwcq&#34;&gt;循环队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;p&gt;XWOS的内核提供了多种动态 &lt;a href=&#34;../Mm&#34;&gt;内存管理&lt;/a&gt; 的方法。&lt;/p&gt;
&lt;h2 id=&#34;电源管理&#34;&gt;电源管理&lt;/h2&gt;
&lt;p&gt;XWOS的内核为 &lt;a href=&#34;../Pm&#34;&gt;电源管理&lt;/a&gt; ，提供了一套基本的流程。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 技术参考手册</title>
      <link>/docs/TechRefManual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: 顺序锁</title>
      <link>/docs/TechRefManual/Lock/Seqlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Seqlock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;顺序锁是对 &lt;a href=&#34;../Spinlock&#34;&gt;自旋锁&lt;/a&gt; 改良后的锁。主要是对读和写的情况进行区分。
顺序锁中包含一个自旋锁和一个顺序值。顺序锁将临界区分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占写：任何对顺序锁临界区的 &lt;strong&gt;写&lt;/strong&gt; 操作都是独占的，每次 &lt;strong&gt;写&lt;/strong&gt; 操作时，会先上锁自旋锁，
然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 &lt;strong&gt;偶数&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;非独占读：如果多个CPU进行的是 &lt;strong&gt;只读&lt;/strong&gt; 操作，它们可以同时进入 &lt;strong&gt;非独占读临界区&lt;/strong&gt; 。
CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 &lt;strong&gt;偶数&lt;/strong&gt; ，并记录此时的顺序值。
当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较：
&lt;ul&gt;
&lt;li&gt;如果相等，表示读的结果有效；&lt;/li&gt;
&lt;li&gt;如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独占读：如果希望读临界区不会被写操作无效掉，可以使用独占读的方式，
独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥非独占读，
其他CPU依然可以进入非独占读临界区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;顺序锁有个缺陷： &lt;strong&gt;写&lt;/strong&gt; 者将数据写为空指针时，有可能导致 &lt;strong&gt;非独占读&lt;/strong&gt; 者引用空指针而崩溃。&lt;/p&gt;
&lt;h2 id=&#34;使用顺序锁&#34;&gt;使用顺序锁&lt;/h2&gt;
&lt;h3 id=&#34;顺序锁的初始化&#34;&gt;顺序锁的初始化&lt;/h3&gt;
&lt;p&gt;同自旋锁一样，顺序锁结构体很小，不提供动态创建和删除方法。
用户可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga230119b86fd51047f83cbe1e74982892&#34;&gt;&lt;code&gt;xwos_sqlk_init()&lt;/code&gt;&lt;/a&gt; 初始化顺序锁。&lt;/p&gt;
&lt;h3 id=&#34;多锁&#34;&gt;多锁&lt;/h3&gt;
&lt;p&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 自旋锁保护 &lt;strong&gt;写临界区&lt;/strong&gt; 或 &lt;strong&gt;独占读临界区&lt;/strong&gt; 时，上锁和解锁顺序必须 &lt;strong&gt;保持一致&lt;/strong&gt; ，否则会导致死锁。&lt;/p&gt;
&lt;h3 id=&#34;非独占读临界区&#34;&gt;非独占读临界区&lt;/h3&gt;
&lt;p&gt;如果多个CPU进行的是 &lt;strong&gt;只读&lt;/strong&gt; 操作，它们可以同时进入 &lt;strong&gt;非独占读临界区&lt;/strong&gt; 。
CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 &lt;strong&gt;偶数&lt;/strong&gt;，并记录此时的顺序值。
此操作可通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga7cd1c5a34e6c318d537e4780f3ae85f4&#34;&gt;&lt;code&gt;xwos_sqlk_rd_begin()&lt;/code&gt;&lt;/a&gt; 来完成。&lt;/p&gt;
&lt;p&gt;当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较。
此操作可通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gabcf1bae603513b049184fe2179d1301e&#34;&gt;&lt;code&gt;xwos_sqlk_rd_retry()&lt;/code&gt;&lt;/a&gt; 完成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果相等，表示读的结果有效；&lt;/li&gt;
&lt;li&gt;如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        seq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sqlk_rd_begin&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 进入临界区前先获取顺序值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 非独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;xwos_sqlk_rd_retry&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span style=&#34;&#34;&gt;，&lt;/span&gt; seq)); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 测试顺序值是否发生了变化 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户也可以通过 &lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga40da988fa2376c706f8cab79dc4dab7c&#34;&gt;&lt;code&gt;xwos_sqlk_get_seq()&lt;/code&gt;&lt;/a&gt; 读取顺序值，自行比较。&lt;/p&gt;
&lt;h3 id=&#34;写临界区&#34;&gt;写临界区&lt;/h3&gt;
&lt;p&gt;任何对顺序锁临界区的 &lt;strong&gt;写&lt;/strong&gt; 操作都是独占的，每次进入 &lt;strong&gt;写临界区&lt;/strong&gt; 时，会先上锁自旋锁，
然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 &lt;strong&gt;偶数&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只会关闭抢占。
可以理解为在线程层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga16274374f2eeac631149433d1cf3491a&#34;&gt;&lt;code&gt;xwos_splk_wr_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga5cc1e68a7d23ca6b7210de17b950e64b&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga1320e69104e26e1a79b5459e7607584c&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga61fbffa6ca444335dbf3a4c2d2fd79b5&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaa46493b921777da3bc92fd5e91cf2388&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga694c4ac137e605fd951a3e3c1d37c855&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gabc138d69277ba1017ade0f27c6c282cb&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga065396cb9c428d0e6234ade20506ff2a&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gadcb38d5d6dad7969e1231c47c131f3c8&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。&lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaac8a682117d914620347320e9f560152&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3eb1f6f9a6a1feda5569757540b01df6&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga2e5a2faac19775d37f6f5ccde32a7313&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3f5f4b0151aa7b01887270f15a13818c&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga21e971d6ca670922416042f7ecc4d063&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga0fe331dfdb5fa645618cc74a90278d03&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。 &lt;strong&gt;写临界区&lt;/strong&gt; 内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面， &lt;strong&gt;写临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;写临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
&lt;strong&gt;写临界区&lt;/strong&gt; 内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;写临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaffbc56b927fa504cad49f737a8be68d1&#34;&gt;&lt;code&gt;xwos_splk_wr_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部，进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga4771dca2b7e1f58df3fea5dc0278bd0a&#34;&gt;&lt;code&gt;xwos_splk_wr_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部，尝试进入写临界区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga3e2867fefe9d28031957e563ffc76ff5&#34;&gt;&lt;code&gt;xwos_splk_wr_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部，退出写临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 写临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_wr_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;独占读临界区&#34;&gt;独占读临界区&lt;/h3&gt;
&lt;p&gt;如果希望读临界区不会被写操作无效掉，可以使用独占读的方式，
独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥 &lt;strong&gt;非独占读&lt;/strong&gt; ，
其他CPU依然可以进入非独占读临界区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 只对 &lt;strong&gt;线程&lt;/strong&gt; 上下文是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只会关闭抢占。
可以理解为在线程层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不能发生 &lt;strong&gt;调度&lt;/strong&gt; ，用户不可在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga0bc2e7584ad91b0c250ff029b25d70bd&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaa870ff02e389c6f9d61ee4119fc38204&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga390316c0f4e02e92669a87fefe0a0bb4&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;任意&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga24cf158c1835abd6bacdcd846b1ba787&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、CPU中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga5cd525a876d961a541876ba9a217e77e&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、CPU中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gadd1ae7af48feae2d216dc588d2789490&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_cpuirq()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、CPU中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirq&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;任意&lt;/strong&gt; 上下文都是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，不但会关闭抢占，还会把CPU中断也关了。
可以理解为在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生中断，也不可能发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga9c906f30b85d221d21be57fe2ff79410&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存CPU中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga7466ec4b9fede25fce836c3e0f718661&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_cpuirqsv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存CPU中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga6eb881e1a1c6e73879053a45e7af20cc&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_cpuirqrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占，恢复CPU中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_cpuirqsv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc2, cpuirq2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_cpuirqrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;loc1, cpuirq1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。&lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gad67dfd2f001aab35f69cf99d9831ba8c&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_irqs()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，关闭部分中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga2fb086d3289975531800d2633542c7a8&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_irqs()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，关闭部分中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga868886500d9e33300b0fbccd032ff449&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_irqs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、开启部分中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock, irq_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当使用 &lt;strong&gt;多个&lt;/strong&gt; 顺序锁时，嵌套的 &lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和指定的中断。
可以理解为在线程和指定的中断函数层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;指定的外设中断&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生指定的中断，也不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga8f7f5fa7a0103fb2bc89d69a6afbcdab&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_irqssv()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占，保存部分中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gaf80962b3c0731f34615604c6dbe30839&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_irqssv()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占，保存部分中断标志并关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga62dff199b6143032fe9bd5a03f51067c&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_irqsrs()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、恢复部分中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_irqssv&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock2, irq_array, flag2_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_irqsrs&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock1, irq_array, flag1_array, num);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占读临界区&lt;/strong&gt; 对 &lt;strong&gt;线程&lt;/strong&gt; 、 &lt;strong&gt;中断底半部&lt;/strong&gt; 是安全的。 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内，只关闭抢占和中断底半部。
可以理解为在线程和中断底半部层面， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的操作是 &lt;strong&gt;原子的&lt;/strong&gt; ， &lt;strong&gt;独占读临界区&lt;/strong&gt; 内的数据只能被 &lt;strong&gt;线程&lt;/strong&gt; 和 &lt;strong&gt;中断底半部&lt;/strong&gt; 上下文访问。
&lt;strong&gt;独占读临界区&lt;/strong&gt; 内不会发生 &lt;strong&gt;调度&lt;/strong&gt; ，但用户依然不能在 &lt;strong&gt;独占读临界区&lt;/strong&gt; 内使用会导致 &lt;strong&gt;睡眠&lt;/strong&gt; 与 &lt;strong&gt;阻塞&lt;/strong&gt; 的CAPI。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gad649d232c24bbbf43fb9d9f163381692&#34;&gt;&lt;code&gt;xwos_splk_rdex_lock_bh()&lt;/code&gt;&lt;/a&gt; ：上锁，关闭抢占、中断底半部&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#gab71ec7bec664746455b4f5c3ffaf5505&#34;&gt;&lt;code&gt;xwos_splk_rdex_trylock_bh()&lt;/code&gt;&lt;/a&gt; ：尝试上锁，关闭抢占、中断底半部&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html#ga56e9f3261d8966ac1dfc51619cd5f48d&#34;&gt;&lt;code&gt;xwos_splk_rdex_unlock_bh()&lt;/code&gt;&lt;/a&gt; ：解锁，开启抢占、中断底半部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_lock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 独占读临界区 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_splk_rdex_unlock_bh&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__seqlock.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/seqlock.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 条件量</title>
      <link>/docs/TechRefManual/Sync/Cond/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Cond/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;条件量是操作系统比较底层的同步机制，可以同时阻塞多个线程。当条件成立，条件量可以唤醒一个或所有正在等待的线程。&lt;/p&gt;
&lt;p&gt;操作系统或语言库都提供了条件量的功能，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX的 &lt;code&gt;pthread_cond_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C++的 &lt;code&gt;std::condition_variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Java的 &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Python的 &lt;code&gt;threading.Condition&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rust的 &lt;code&gt;std::sync::condvar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程需要在持有 &lt;strong&gt;互斥锁&lt;/strong&gt; 的情况下去等待条件量，
条件量阻塞线程时会同步释放 &lt;strong&gt;互斥锁&lt;/strong&gt; 。当条件成立，线程被唤醒时，条件量会自动上锁 &lt;strong&gt;互斥锁&lt;/strong&gt; 。
等待条件量发生错误时，条件量也会自动上锁 &lt;strong&gt;互斥锁&lt;/strong&gt; 后再返回。&lt;/p&gt;
&lt;p&gt;XWOS的条件量的功能类似，主要包括以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 等待条件量的 &lt;strong&gt;条件成立&lt;/strong&gt; 而阻塞；&lt;/li&gt;
&lt;li&gt;另一个线程 &lt;strong&gt;B&lt;/strong&gt; 或中断上下文或其他上下文通过 &lt;strong&gt;单播&lt;/strong&gt; 或 &lt;strong&gt;广播&lt;/strong&gt; 使 &lt;strong&gt;条件成立&lt;/strong&gt; ，并唤醒条件量上阻塞的线程 &lt;strong&gt;A&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，会自动解锁；&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，当等到 &lt;strong&gt;条件成立&lt;/strong&gt; 时，会自动上锁；&lt;/li&gt;
&lt;li&gt;线程 &lt;strong&gt;A&lt;/strong&gt; 持有 &lt;strong&gt;锁&lt;/strong&gt; 的情况下去等待条件量，当发生错误返回时， &lt;strong&gt;不会&lt;/strong&gt; 自动上锁；&lt;/li&gt;
&lt;li&gt;支持多种锁类型：
&lt;ul&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;顺序锁&lt;/li&gt;
&lt;li&gt;自定义的加锁与解锁函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持没有伴生锁的情况下操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;条件量对象与对象描述符描述符&#34;&gt;条件量对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;条件量对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，条件量对象也用 &lt;strong&gt;条件量对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__cond__d.html&#34;&gt;&lt;code&gt;xwos_cond_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;条件量对象描述符由 &lt;strong&gt;条件量对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_cond &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cond; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 条件量对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_cond_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;条件量的初始化销毁与动态创建删除&#34;&gt;条件量的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga02154ceda2ebb3198e0f452d05e84fe8&#34;&gt;&lt;code&gt;xwos_cond_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的条件量： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga2007c32a3bc08294a77ab09ac17e2e20&#34;&gt;&lt;code&gt;xwos_cond_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga8d6ff09dee39723571220a7f25d04eb3&#34;&gt;&lt;code&gt;xwos_cond_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的条件量： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6921e0eb38b073d68cb4af77ecc71c85&#34;&gt;&lt;code&gt;xwos_cond_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单播&#34;&gt;单播&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafe8a5951b17d91fe378756815abc8b9b&#34;&gt;&lt;code&gt;xwos_cond_unicast()&lt;/code&gt;&lt;/a&gt; 可用来在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使得条件量的条件成立，但只唤醒一个线程。
单播不会产生 &lt;strong&gt;选者信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;广播&#34;&gt;广播&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6a85c4b4f0a48d8f7af6d1eb9edf5828&#34;&gt;&lt;code&gt;xwos_cond_broadcast()&lt;/code&gt;&lt;/a&gt; 可用来在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使得条件量的条件成立，唤醒全部线程。
&lt;strong&gt;广播&lt;/strong&gt; 还会使得条件量向绑定的 &lt;a href=&#34;../sel&#34;&gt;信号选择器&lt;/a&gt; 发送 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;等待条件量&#34;&gt;等待条件量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga5e036562855a7585904903a707f19ca7&#34;&gt;&lt;code&gt;xwos_cond_wait()&lt;/code&gt;&lt;/a&gt; ：等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gad8c1310da94bd715059fef8521264cfa&#34;&gt;&lt;code&gt;xwos_cond_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga176a4bfcec1f402e0e8e127354e58911&#34;&gt;&lt;code&gt;xwos_cond_wait_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断等待条件量，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用了带附作用的上锁函数时，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_splk_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_wr_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_cpuirq()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_cpuirqsv()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_irqs()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_sqlk_rdex_lock_bh()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;等待条件量&lt;/strong&gt; 不会管理调度器开关、中断开关以及中断底半部开关。
等待之前是什么状态，无论返回值是 &lt;code&gt;XWOK&lt;/code&gt; 还是错误码，等待之后还是什么状态。&lt;/p&gt;
&lt;p&gt;XWOS的条件量与 &lt;code&gt;pthread_cond_t&lt;/code&gt; 不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XWOS的条件量， &lt;strong&gt;等待条件量&lt;/strong&gt; 返回值为 &lt;code&gt;XWOK&lt;/code&gt; 时才会对锁进行上锁，如果返回错误码，是否上锁不确定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_wait()&lt;/code&gt; 无论如何都会等待互斥锁被上锁时才返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;冻结与解冻&#34;&gt;冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;冻结&#34;&gt;冻结&lt;/h3&gt;
&lt;p&gt;条件量可以使用 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae28d45933a9a1cd5fbb282533f3a96d5&#34;&gt;&lt;code&gt;xwos_cond_freeze()&lt;/code&gt;&lt;/a&gt; 进行 &lt;strong&gt;冻结&lt;/strong&gt;，
被冻结的条件量不能被 &lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt; ，但不影响 &lt;strong&gt;等待&lt;/strong&gt; 操作。&lt;/p&gt;
&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gab932d4d14e734f2f413783512b0b10ac&#34;&gt;&lt;code&gt;xwos_cond_thaw()&lt;/code&gt;&lt;/a&gt; 可将已经冻结的条件量 &lt;strong&gt;解冻&lt;/strong&gt; 。
条件量 &lt;strong&gt;解冻&lt;/strong&gt; 后，可重新 &lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_cond_bind()&lt;/code&gt;&lt;/a&gt; 将条件量绑定到 &lt;a href=&#34;../sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当 &lt;strong&gt;广播&lt;/strong&gt; 条件量时，条件量会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。此外， &lt;strong&gt;单播&lt;/strong&gt; 不会产生 &lt;strong&gt;选者信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;绑定后的条件量可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_cond_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;条件量对象的生命周期管理&#34;&gt;条件量对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;条件量对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
条件量对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gab8acb77604393deba20d8511707bd820&#34;&gt;&lt;code&gt;xwos_cond_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae52e6bcefc86df3fd676534010c3d2b2&#34;&gt;&lt;code&gt;xwos_cond_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga0b954974711ff4689398312f2861e578&#34;&gt;&lt;code&gt;xwos_cond_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gad2319939fb53002f58ac0cd1d32bc2b2&#34;&gt;&lt;code&gt;xwos_cond_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwos__sync__cond.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/cond.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 循环队列</title>
      <link>/docs/TechRefManual/Isc/Xwcq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/Xwcq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的循环队列（xwcq）是由 &lt;strong&gt;NUM&lt;/strong&gt; 个大小为 &lt;strong&gt;SIZE&lt;/strong&gt; 的数据缓冲区组成的队列。
这些缓冲区首尾相连，形成一个环。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;pie
    title 循环队列
    &amp;#34;数据缓冲区0&amp;#34; : 1
    &amp;#34;数据缓冲区1&amp;#34; : 1
    &amp;#34;数据缓冲区2&amp;#34; : 1
    &amp;#34;数据缓冲区3&amp;#34; : 1
    &amp;#34;数据缓冲区4&amp;#34; : 1
    &amp;#34;数据缓冲区5&amp;#34; : 1
    &amp;#34;数据缓冲区6&amp;#34; : 1
    &amp;#34;数据缓冲区7&amp;#34; : 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消息可发送到队列的头部，也可以发送到队列的尾部。
消息可以从队列的头部接收，也可以从队列的尾部接收。&lt;/p&gt;
&lt;h3 id=&#34;循环队列对象与对象描述符描述符&#34;&gt;循环队列对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;循环队列对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，循环队列对象也用 &lt;strong&gt;循环队列对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwcq__d.html&#34;&gt;&lt;code&gt;xwcq_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;循环队列对象描述符由 &lt;strong&gt;循环队列对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwcq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cq; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 循环队列对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwcq_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h3 id=&#34;局限性&#34;&gt;局限性&lt;/h3&gt;
&lt;p&gt;循环队列有自己数据缓冲区，用户的消息会被拷贝到数据缓冲区内，用户不必额外申请动态内存。
但循环队列缓冲区大小是固定的，用户只能发送小于等于缓冲区大小的数据。&lt;/p&gt;
&lt;h2 id=&#34;循环队列的静态初始化销毁&#34;&gt;循环队列的静态初始化、销毁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga0c3766b13d0b48e0c99fab1d814c7b57&#34;&gt;&lt;code&gt;xwcq_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;初始化循环队列时，需要预先定义数据缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define BRDCQ_SIZE 64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define BRDCQ_NUM  8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;XWCQ_DEF_MEMPOOL&lt;/span&gt;(brdcq_mempool, BRDCQ_SIZE, BRDCQ_NUM);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwcq brdcq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;brd_init_xwcq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwcq_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;brdcq, BRDCQ_SIZE, BRDCQ_NUM, brdcq_mempool);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;销毁静态初始化的信号量： &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gad2cc23153007095e7eb3420412ad4083&#34;&gt;&lt;code&gt;xwcq_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环队列的动态创建删除&#34;&gt;循环队列的动态创建、删除&lt;/h2&gt;
&lt;p&gt;XWOS并未提供基于动态内存管理的创建与删除CAPI。&lt;/p&gt;
&lt;h2 id=&#34;发送消息&#34;&gt;发送消息&lt;/h2&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;入队&lt;/strong&gt; 是指将消息发送到循环队列的 &lt;strong&gt;尾端&lt;/strong&gt; 。
如果循环队列数据已被填满，循环队列会循环回队列 &lt;strong&gt;首端&lt;/strong&gt; 的位置，覆盖掉原数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gacc14c7eb323b5968c30d42371bced34b&#34;&gt;&lt;code&gt;xwcq_eq()&lt;/code&gt;&lt;/a&gt; ：可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插队&#34;&gt;插队&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;插队&lt;/strong&gt; 是指将消息发送到循环队列的 &lt;strong&gt;首端&lt;/strong&gt; 。
如果循环队列数据已被填满，循环队列会循环回队列 &lt;strong&gt;尾端&lt;/strong&gt; 的位置，覆盖掉原数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga99aaf9a7ad5acc2dde16642e3c76644f&#34;&gt;&lt;code&gt;xwcq_jq()&lt;/code&gt;&lt;/a&gt; ：可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接收消息&#34;&gt;接收消息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;接收消息&lt;/strong&gt; 是指从循环队列中 &lt;strong&gt;取走&lt;/strong&gt; 消息，消息取走后不再存在于循环队列。&lt;/p&gt;
&lt;h3 id=&#34;首端接收&#34;&gt;首端接收&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gac9f65a59cd4c07212e4515d81466edab&#34;&gt;&lt;code&gt;xwcq_dq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga1751e4a7d470159426dfc0b28f30c426&#34;&gt;&lt;code&gt;xwcq_dq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga9268a23f62386b705f358da0690719d7&#34;&gt;&lt;code&gt;xwcq_dq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga7b6a39511984b0701595df93d4f07072&#34;&gt;&lt;code&gt;xwcq_trydq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端离队&#34;&gt;尾端离队&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga9aaa9a95186c3bd701b31dc05d1f051b&#34;&gt;&lt;code&gt;xwcq_rq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf4c60c0ca895ff95a7f636871a83592b&#34;&gt;&lt;code&gt;xwcq_rq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gadc32b77f21a0faec18ce917f4cae6b46&#34;&gt;&lt;code&gt;xwcq_rq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga4ee21be691d89289330a6b775eaa2122&#34;&gt;&lt;code&gt;xwcq_tryrq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拷贝消息&#34;&gt;拷贝消息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;拷贝消息&lt;/strong&gt; 是指从循环队列中 &lt;strong&gt;拷贝&lt;/strong&gt; 消息，不会从循环队列中删除消息。&lt;/p&gt;
&lt;h3 id=&#34;首端拷贝&#34;&gt;首端拷贝&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf743e9140c73b57f82592e612e5f0310&#34;&gt;&lt;code&gt;xwcq_pfq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga8ee1e6f6ccb52d2ad7ff983299e457f8&#34;&gt;&lt;code&gt;xwcq_pfq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga47c4c89b9ae21ff278bb0911982a9178&#34;&gt;&lt;code&gt;xwcq_pfq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaf6e49bfc7b9b04d1c0162fba5fa19752&#34;&gt;&lt;code&gt;xwcq_trypfq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;尾端拷贝&#34;&gt;尾端拷贝&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga446e314e4d1bf1e91a6f17a4e57b5fc4&#34;&gt;&lt;code&gt;xwcq_prq()&lt;/code&gt;&lt;/a&gt; ：等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga927902d5c0f3137e42dc3040b8186c1e&#34;&gt;&lt;code&gt;xwcq_prq_to()&lt;/code&gt;&lt;/a&gt; ：限时等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gab7a4f7dad6f65d876840a5e1279cdab6&#34;&gt;&lt;code&gt;xwcq_prq_unintr()&lt;/code&gt;&lt;/a&gt; ：不可中断地等待消息，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaa0cca193c18e50f3357ec81431f591da&#34;&gt;&lt;code&gt;xwcq_tryprq()&lt;/code&gt;&lt;/a&gt; ：尝试获取消息，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;清空循环队列&#34;&gt;清空循环队列&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gae3abbdc3ed1a692d76a37d01de02f4b8&#34;&gt;&lt;code&gt;xwcq_flush()&lt;/code&gt;&lt;/a&gt; 将循环队列恢复到初始化状态。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列容量&#34;&gt;获取循环队列容量&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga1c85e05558f075453bfa3c7cd3fc02a5&#34;&gt;&lt;code&gt;xwcq_get_capacity()&lt;/code&gt;&lt;/a&gt; 获取循环队列的容量。
循环队列的容量是指数据缓冲区中数据槽的数量，也即是 &lt;code&gt;xwcq_init()&lt;/code&gt; 的第三个参数。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列单个数据槽的大小&#34;&gt;获取循环队列单个数据槽的大小&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaa51ad59ea6039a0e7f0086e019361a65&#34;&gt;&lt;code&gt;xwcq_get_size()&lt;/code&gt;&lt;/a&gt; 获取单个数据槽的大小。
也即是 &lt;code&gt;xwcq_init()&lt;/code&gt; 的第二个参数。&lt;/p&gt;
&lt;h2 id=&#34;获取循环队列中有效数据槽的数量&#34;&gt;获取循环队列中有效数据槽的数量&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga00c6353fe858d19a09198cf3adfd20fb&#34;&gt;&lt;code&gt;xwcq_get_availability()&lt;/code&gt;&lt;/a&gt; 获取循环队列中有效数据槽的数量。
有效数据槽是指包含了可被接收数据的数据槽。&lt;/p&gt;
&lt;h2 id=&#34;循环队列对象的生命周期管理&#34;&gt;循环队列对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;循环队列对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
循环队列对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gad5deec2a2c4c219ff7e4e5e562711936&#34;&gt;&lt;code&gt;xwcq_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga830514ae992ff57a790a427f98ee2802&#34;&gt;&lt;code&gt;xwcq_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#gaeb13f10158bb8bcc962c9d4b70304e83&#34;&gt;&lt;code&gt;xwcq_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwmd__isc__xwcq.html#ga51d97bf4e9311f1ca7aec6f99b557587&#34;&gt;&lt;code&gt;xwcq_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../../capi/group__xwmd__isc__xwcq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwmd/isc/xwcq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 原子操作库</title>
      <link>/docs/TechRefManual/Xwlib/Xwaop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Xwaop/</guid>
      <description>
        
        
        &lt;h2 id=&#34;内存模型&#34;&gt;内存模型&lt;/h2&gt;
&lt;p&gt;与标准库一样，XWOS的原子操作分为6种内存模型：&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_relaxed&#34;&gt;&lt;code&gt;xwaop_mo_relaxed&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;松散序，不作任何内存屏障操作。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_consume&#34;&gt;&lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;消费序，会在读操作之间增加 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 。
这个屏障并不常见，对于常见的x86/ARM都是自动处理 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 的。
据作者所知，目前只有Alpha架构的CPU需要程序员关注 &lt;strong&gt;Data dependency barrier&lt;/strong&gt; 。
Rust语言干脆连这个内存序都不提供。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_acquire&#34;&gt;&lt;code&gt;xwaop_mo_acquire&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;获得序，常常与配合读一起使用，形成 &lt;strong&gt;load-acquire&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_release&#34;&gt;&lt;code&gt;xwaop_mo_release&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;释放序，常常与配合写一起使用，形成 &lt;strong&gt;store-release&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_acq_rel&#34;&gt;&lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;获得释放序，加载时是 &lt;strong&gt;acquire&lt;/strong&gt; 的，回写时是 &lt;strong&gt;release&lt;/strong&gt; 的。通常用于 &lt;strong&gt;读-改-回写&lt;/strong&gt; 这种原子操作。&lt;/p&gt;
&lt;h4 id=&#34;xwaop_mo_seq_cst&#34;&gt;&lt;code&gt;xwaop_mo_seq_cst&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一致序，表明CPU对内存的访问顺序是严格按照程序代码（编译后的）的顺序所进行的。这在期刊文献中被称为 &lt;strong&gt;Sequential Consistency&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;原子操作&#34;&gt;原子操作&lt;/h2&gt;
&lt;p&gt;XWOS提供了原子操作模板库， &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; 中定义的各种 &lt;strong&gt;基本类型&lt;/strong&gt; 都可使用原子操作。
XWOS的原子操作库，可以与标准库 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 中的原子操作混合使用。&lt;/p&gt;
&lt;p&gt;原子操作函数模板包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_load()&lt;/code&gt; ：加载
&lt;ul&gt;
&lt;li&gt;可以指定6种内存序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_read()&lt;/code&gt; ：读
&lt;ul&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acquire&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_store()&lt;/code&gt; ：存储
&lt;ul&gt;
&lt;li&gt;可以指定6种内存序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_write()&lt;/code&gt; ：写
&lt;ul&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_release&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-改-写
&lt;ul&gt;
&lt;li&gt;基本运算
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_add()&lt;/code&gt; ：加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_sub()&lt;/code&gt; ：减&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_rsb()&lt;/code&gt; ：反向减法&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位运算
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_and()&lt;/code&gt; ：与&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_or()&lt;/code&gt; ：或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_xor()&lt;/code&gt; ：异或&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwaop_s1m()&lt;/code&gt; ：将数据掩码部分的位全部置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_c0m()&lt;/code&gt; ：将数据掩码部分的位全部清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwaop_x1m()&lt;/code&gt; ：将数据掩码部分的位全部翻转&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-测试-改-写
&lt;ul&gt;
&lt;li&gt;所有名称匹配正则表达式 &lt;code&gt;xwaop_t.+_then_.+&lt;/code&gt; 的函数
&lt;ul&gt;
&lt;li&gt;分为两种情况
&lt;ul&gt;
&lt;li&gt;测试成功，继续执行“改-写”操作，此时内存序为 &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试失败，相当于读操作，此时内存序为 &lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有原子操作函数的第一个参数均为 &lt;a href=&#34;../../XwosStd#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;基本类型&lt;/a&gt; ，第二个参数是原子数据的指针，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwsq_a refcnt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; nv, ov;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * 测试refcnt是否为0：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * + ture: refcnt增加1，nv返回refcnt增加以后的新值，ov返回refcnt增加以前的旧值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; *         内存序：acq_rel，rc为返回值XWOK；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * + false: nv与ov都返回refcnt的值，内存序：consume，rc为返回值-EACCES；
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwaop_teq_then_add&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;refcnt, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;nv, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ov);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;位图原子操作&#34;&gt;位图原子操作&lt;/h2&gt;
&lt;p&gt;位图（ &lt;code&gt;xwbmp_t&lt;/code&gt; 数组）可进行原子操作，XWOS提供了基本函数库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_define()&lt;/code&gt; ：声明原子位图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t1i()&lt;/code&gt; ：测试位图中的某位是否被置1&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_s1all()&lt;/code&gt; ：将位图所有位置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_c0all()&lt;/code&gt; ：将位图所有位清0&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-改-写
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_s1i()&lt;/code&gt; ：将位图中某位置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_c1i()&lt;/code&gt; ：将位图中某位清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_x1i()&lt;/code&gt; ：将位图中某位翻转&lt;/li&gt;
&lt;li&gt;内存序： &lt;code&gt;acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读-测试-改-写
&lt;ul&gt;
&lt;li&gt;所有名字匹配正则表达式 &lt;code&gt;xwbmpaop_.+_then_.+&lt;/code&gt; 的函数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t0i_then_s1i()&lt;/code&gt; ：测试位图中某位是否为0，如果是，就将它置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_t1i_then_c0i()&lt;/code&gt; ：测试位图中某位是否为1，如果是，就将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_fls_then_c0i()&lt;/code&gt; ：从最高位起查找位图中第一个为1的位并将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_flz_then_s1i()&lt;/code&gt; ：从最高位起查找位图中第一个为0的位并将它置1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_ffs_then_c0i()&lt;/code&gt; ：从最低位起查找位图中第一个为1的位并将它清0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmpaop_ffz_then_s1i()&lt;/code&gt; ：从最低位起查找位图中第一个为0的位并将它置1&lt;/li&gt;
&lt;li&gt;分为两种情况
&lt;ul&gt;
&lt;li&gt;测试成功，继续执行“改-写”操作，此时内存序为 &lt;code&gt;xwaop_mo_acq_rel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试失败，相当于读操作，此时内存序为 &lt;code&gt;xwaop_mo_consume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwaop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwaop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;位图原子操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwbmpaop.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwbmpaop.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 代码风格</title>
      <link>/docs/TechRefManual/CodeStyle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/CodeStyle/</guid>
      <description>
        
        
        &lt;h2 id=&#34;c语言&#34;&gt;C语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;风格：KR&lt;/li&gt;
&lt;li&gt;缩进：8空格（不使用TAB）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c语言-1&#34;&gt;C++语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;风格：Google&lt;/li&gt;
&lt;li&gt;缩进：2空格（不使用TAB）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;makefile&#34;&gt;Makefile&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;shell&#34;&gt;Shell&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;emacslisp&#34;&gt;EmacsLisp&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;rust语言&#34;&gt;Rust语言&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;lua语言&#34;&gt;Lua语言&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 互斥锁</title>
      <link>/docs/TechRefManual/Lock/Mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/Mutex/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;互斥锁是用来保证不同线程正确访问共享数据的机制。访问共享数据的代码片段被称为临界区。
互斥锁 &lt;strong&gt;不可&lt;/strong&gt; 用在 &lt;strong&gt;除线程以外&lt;/strong&gt; 的其他上下文(Context)。&lt;/p&gt;
&lt;p&gt;当线程等待互斥锁时，线程会被阻塞，并让出CPU的使用权。
互斥锁存在优先级反转问题：&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Lock/Mutex/priority-inversion_hu06d113db6caaf8381d16863409fb983c_97009_800x800_fill_catmullrom_smart1_3.png&#34; width=&#34;800&#34; height=&#34;800&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS互斥锁的优先级反转问题
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;优先级策略&#34;&gt;优先级策略&lt;/h3&gt;
&lt;p&gt;XWOS内核采取优先级天花板和优先级继承的混会策略解决此问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程和互斥锁都拥有优先级，它们在创建时需要指定一个 &lt;strong&gt;静态优先级&lt;/strong&gt; ，
当线程持有互斥锁时，线程可以获取互斥锁的优先级作为 &lt;strong&gt;动态优先级&lt;/strong&gt; ，
当互斥锁被线程等待时，互斥锁可以获取线程的优先级作为 &lt;strong&gt;动态优先级&lt;/strong&gt; ，
最终的优先级取 &lt;strong&gt;静态优先级&lt;/strong&gt; 和 &lt;strong&gt;动态优先级&lt;/strong&gt; 较大的一个；&lt;/li&gt;
&lt;li&gt;假设线程A优先级低，线程B的优先级中，线程C的优先级高。
线程A已经获得锁的情况下，线程C等待锁。线程C的优先级会传递给锁，
锁的优先级再传递给线程A。线程A的优先级被临时提高至和线程C的优先级一样，线程A不会被线程B抢占。&lt;/li&gt;
&lt;li&gt;优先级可以无限继承：假设线程A的优先级最低，线程 &lt;strong&gt;&lt;code&gt;T1、T2、...、Tn&lt;/code&gt;&lt;/strong&gt; 的优先级依次递增。
系统中有互斥锁 &lt;strong&gt;&lt;code&gt;L、M1、M2、...、Mn&lt;/code&gt;&lt;/strong&gt; 。
假设A持有L，T1持有M1去等待L，T2持有M2去等待M1，T3持有M3去等待M2，以此类推，Tn持有Mn去等待Mn-1。
由此形成优先级传递链： &lt;strong&gt;&lt;code&gt;Tn-&amp;gt;Mn-1-&amp;gt;Tn-1-&amp;gt;...-&amp;gt;M3-&amp;gt;T3-&amp;gt;M2-&amp;gt;T2-&amp;gt;M1-&amp;gt;T1-&amp;gt;L-&amp;gt;A&lt;/code&gt;&lt;/strong&gt; ，
Tn的优先级将会依次传递到 &lt;strong&gt;&lt;code&gt;Mn-1、Tn-1、... 、M3、T3、M2、T2、M1、T1、L、A&lt;/code&gt;&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁树与实时等待队列&#34;&gt;互斥锁树与实时等待队列&lt;/h3&gt;
&lt;p&gt;如何寻找互斥锁与线程的 &lt;strong&gt;动态优先级&lt;/strong&gt; ，是寻找最大值的问题，因此可以采用与 &lt;a href=&#34;../../Skd#%E6%97%B6%E9%97%B4%E6%A0%91&#34;&gt;时间树&lt;/a&gt; 类似的方法，使用红黑树解决此问题。
节点为互斥锁并查找最大优先级算法被称为 &lt;strong&gt;互斥锁树&lt;/strong&gt; ；节点为线程并查找最大优先级算法被称为 &lt;strong&gt;实时等待队列&lt;/strong&gt; 。&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Lock/Mutex/rightmost-rbtree_hu6bb0500ec3a7cabe3ed4a4195feadcf6_94587_680x491_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;491&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
带有最大值指针的红黑树
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;使用一个 &lt;strong&gt;rightmost&lt;/strong&gt; 指针指向最大值，可直接从 &lt;strong&gt;rightmost&lt;/strong&gt; 快速获取最大值，时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rightmost&lt;/strong&gt; 从红黑树中删除时，按照二叉树的性质，下一任 &lt;strong&gt;rightmost&lt;/strong&gt; 是前任的左孩子（即前驱）。
如果前任的前驱为叶子，下一任 &lt;strong&gt;rightmost&lt;/strong&gt; 一定是前任的父节点，算法时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;删除 &lt;strong&gt;rightmost&lt;/strong&gt; 在系统中是一个高频次的操作，但由于 &lt;strong&gt;rightmost&lt;/strong&gt; 缺少右子树，根据红黑树性质，左子树也不可能太复杂，
意味着删除 &lt;strong&gt;rightmost&lt;/strong&gt; 后，调整红黑树的代价不会太大；&lt;/li&gt;
&lt;li&gt;插入操作需要遍历树，时间复杂度为 &lt;strong&gt;O(logn)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;红黑树中不允许存在关键字相等的节点，因此拥有相同优先级的节点相互连接成链表；&lt;/li&gt;
&lt;li&gt;互斥锁解锁时，从等待队列中选择最高优先级的线程获取互斥锁，若最高优先级的线程不止一个，按照先进先出的方法选取线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁对象与对象描述符描述符&#34;&gt;互斥锁对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;互斥锁对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，互斥锁对象也用 &lt;strong&gt;互斥锁对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__mtx__d.html&#34;&gt;&lt;code&gt;xwos_mtx_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;互斥锁对象描述符由 &lt;strong&gt;互斥锁对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_mtx &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mtx; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 互斥锁对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_mtx_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;使用互斥锁&#34;&gt;使用互斥锁&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化和销毁互斥锁&#34;&gt;静态初始化和销毁互斥锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga05ea2a9762a817291b0ae6d76586e022&#34;&gt;&lt;code&gt;xwos_mtx_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的互斥锁： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga7b2464babb829bdc7fd0e433ff54bdca&#34;&gt;&lt;code&gt;xwos_mtx_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建和删除互斥锁&#34;&gt;动态创建和删除互斥锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga815282818f9a5ed5c1cd580e097a868b&#34;&gt;&lt;code&gt;xwos_mtx_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的互斥锁： &lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga8f76d838298d8b5e1ae06889c7a5c3e0&#34;&gt;&lt;code&gt;xwos_mtx_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上锁&#34;&gt;上锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gabd23c15c16510525e6a91fc3fcfa20f3&#34;&gt;&lt;code&gt;xwos_mtx_lock()&lt;/code&gt;&lt;/a&gt; 等待并上锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga5fd796bb80d4d1dfa65bf60741f05241&#34;&gt;&lt;code&gt;xwos_mtx_trylock()&lt;/code&gt;&lt;/a&gt; 尝试上锁互斥锁，不会阻塞调用线程，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga37eb46fa1271ff0ecebd4e0ceb0f4420&#34;&gt;&lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt;&lt;/a&gt; 限时等待上锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gac72f69bffd93d6d8fa7dcc6bf0302574&#34;&gt;&lt;code&gt;xwos_mtx_lock_unintr()&lt;/code&gt;&lt;/a&gt; 等待并上锁互斥锁，且等待不可被中断，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解锁&#34;&gt;解锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gaa6b3a2ce561acc043d826e47a9470919&#34;&gt;&lt;code&gt;xwos_mtx_unlock()&lt;/code&gt;&lt;/a&gt; 解锁互斥锁，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;获取锁的状态&#34;&gt;获取锁的状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#group__xwos__lock__mtx.html#ga3cddd729ac8dad2a6e9657ae72532354&#34;&gt;&lt;code&gt;xwos_mtx_get_lkst()&lt;/code&gt;&lt;/a&gt; 获取锁的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥锁对象的生命周期管理&#34;&gt;互斥锁对象的生命周期管理&lt;/h3&gt;
&lt;p&gt;互斥锁对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
互斥锁对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga2a560b50a5329f098f2a4cdd4331fef6&#34;&gt;&lt;code&gt;xwos_mtx_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#gafaef1dadab1c11783c1aab9a7ffff589&#34;&gt;&lt;code&gt;xwos_mtx_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga84e1bbb7833198a00678b9a3e5f83941&#34;&gt;&lt;code&gt;xwos_mtx_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html#ga698748b62131af5a434bfa5dae6dcda2&#34;&gt;&lt;code&gt;xwos_mtx_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lock__mtx.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/lock/mtx.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 日志</title>
      <link>/docs/TechRefManual/Xwlib/Log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Log/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS提供了日志框架，用户可以输出带有等级的日志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VERBOSE，等级1，冗长&lt;/li&gt;
&lt;li&gt;DEBUG，等级2，调试&lt;/li&gt;
&lt;li&gt;INFO，等级3，信息&lt;/li&gt;
&lt;li&gt;NOTICE，等级4，提醒&lt;/li&gt;
&lt;li&gt;WARNING，等级5，警告&lt;/li&gt;
&lt;li&gt;ERR，等级6，错误&lt;/li&gt;
&lt;li&gt;CRIT，等级7，危险&lt;/li&gt;
&lt;li&gt;EMERG，等级8，紧急&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户可以通过配置 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 来控制各种等级的日志是否输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当等级大于等于 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 的日志才会输出，&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; 配置为 &lt;code&gt;0&lt;/code&gt; 将关闭所有日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS的日志框架需要用户在BSP中提供后端驱动接口，以决定日志最终输出到串口、SD卡、还是别的设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当配置 &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，BSP中需要提供函数 &lt;code&gt;soc_log_write()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当配置 &lt;code&gt;BRDCFG_LOG&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，BSP中需要提供函数&lt;code&gt; board_log_write()&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;当配置 &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 与配置 &lt;code&gt;BRDCFG_LOG&lt;/code&gt; 同时为 &lt;code&gt;1&lt;/code&gt; 时， &lt;code&gt;SOCCFG_LOG&lt;/code&gt; 具有更高优先级；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__xwlog.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/xwlog.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 事件标志</title>
      <link>/docs/TechRefManual/Sync/Flg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Flg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当系统需要处理很多事件，如果每个事件都绑定一个特定的条件量，
每个条件量又由一个线程进行等待处理，会导致系统需要大量内存来创建条件量和线程。&lt;/p&gt;
&lt;p&gt;事件标志使用位图来管理一组事件，位图中的每个位代表一个事件，
当一个或多个事件状态发生变化时，事件对应的位也会发生变化，并唤醒正在等待的线程。
线程唤醒后，就可从事件位图中获取事件的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程可以等待位图中的事件位被置 &lt;strong&gt;1&lt;/strong&gt; ，也可以等待事件位被清 &lt;strong&gt;0&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;线程可以等待位图中的事件位同时被置 &lt;strong&gt;1&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;与&lt;/strong&gt; 的关系），也可以等待其中任意一个位被置 &lt;strong&gt;1&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;或&lt;/strong&gt; 的关系）。&lt;/li&gt;
&lt;li&gt;线程可以等待位图中的事件位同时被清 &lt;strong&gt;0&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;与&lt;/strong&gt; 的关系），也可以等待其中任意一个位被清 &lt;strong&gt;0&lt;/strong&gt; （事件与事件之间是逻辑 &lt;strong&gt;或&lt;/strong&gt; 的关系）。&lt;/li&gt;
&lt;li&gt;线程可以选择是否 &lt;strong&gt;消费&lt;/strong&gt; 事件。 &lt;strong&gt;消费&lt;/strong&gt; 事件是指，当事件到来，线程被唤醒时，可以选择是否 &lt;strong&gt;清除&lt;/strong&gt; 事件。&lt;/li&gt;
&lt;li&gt;线程可以等待事件标志位发生 &lt;strong&gt;翻转&lt;/strong&gt; ， &lt;strong&gt;翻转&lt;/strong&gt; 是指事件标志位由 &lt;strong&gt;1&lt;/strong&gt; 变为 &lt;strong&gt;0&lt;/strong&gt; ，或由 &lt;strong&gt;0&lt;/strong&gt; 变为 &lt;strong&gt;1&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事件标志对象与对象描述符描述符&#34;&gt;事件标志对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;事件标志对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，事件标志对象也用 &lt;strong&gt;事件标志对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__flg__d.html&#34;&gt;&lt;code&gt;xwos_flg_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;事件标志对象描述符由 &lt;strong&gt;事件标志对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_flg &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; flg; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 事件标志对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_flg_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;事件标志的初始化销毁与动态创建删除&#34;&gt;事件标志的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gab4131ef9b03a02111a64c57801259ab9&#34;&gt;&lt;code&gt;xwos_flg_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的事件标志 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga27de7560274252b37eef3e99c450342c&#34;&gt;&lt;code&gt;xwos_flg_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaf47e42024bad241bc993108f79bc5676&#34;&gt;&lt;code&gt;xwos_flg_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的事件标志 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gafb29743a2107ec5829a372546fe8478d&#34;&gt;&lt;code&gt;xwos_flg_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;产生事件&#34;&gt;产生事件&lt;/h2&gt;
&lt;p&gt;XWOS提供6个CAPI产生触发事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga4bbbb700f8945d8a477ecdf8f48e1be3&#34;&gt;&lt;code&gt;xwos_flg_s1m()&lt;/code&gt;&lt;/a&gt; ：同时设置多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaa512cf8063cc538dbb431dbc680b1d78&#34;&gt;&lt;code&gt;xwos_flg_s1i()&lt;/code&gt;&lt;/a&gt; ：设置单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gad9d0bd13e3b0c853597b982d348fd6dd&#34;&gt;&lt;code&gt;xwos_flg_c0m()&lt;/code&gt;&lt;/a&gt; ：同时清除多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga48c1627edd80a59ad4f88c3a91fb8bf0&#34;&gt;&lt;code&gt;xwos_flg_c0i()&lt;/code&gt;&lt;/a&gt; ：清除单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga422b4ec657c8baf31cf35a141ae0bff1&#34;&gt;&lt;code&gt;xwos_flg_x1m()&lt;/code&gt;&lt;/a&gt; ：同时翻转多个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga42d2e3e4536d53490ba1590aefdcaac2&#34;&gt;&lt;code&gt;xwos_flg_x1i()&lt;/code&gt;&lt;/a&gt; ：翻转单个事件标志位，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些CAPI除了会修改事件标志位图的状态，还会通过 &lt;strong&gt;广播&lt;/strong&gt; 唤醒所有正在等待的线程。
然后，线程通过比对位图状态，确定事件是否已经满足触发条件。
若满足触发条件，就退出等待；若未满足触发条件，重新进入阻塞等待状态。&lt;/p&gt;
&lt;h2 id=&#34;获取事件的状态&#34;&gt;获取事件的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaae27fd46b8558b5e820e8bc5ffcddcdd&#34;&gt;&lt;code&gt;xwos_flg_get_num()&lt;/code&gt;&lt;/a&gt; 获取事件标志中总共有多少个事件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gac47087827b24b63dc82d2998713c61be&#34;&gt;&lt;code&gt;xwos_flg_read()&lt;/code&gt;&lt;/a&gt; 直接读取事件的位图状态。此函数立即返回，不会阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待事件&#34;&gt;等待事件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaf64305d0e0c927adb6344e1f3c144c13&#34;&gt;&lt;code&gt;xwos_flg_wait()&lt;/code&gt;&lt;/a&gt; ：等待事件，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga560ad75ecf3593fbd5a947adcdf4d9da&#34;&gt;&lt;code&gt;xwos_flg_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待事件，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga3c65f8d4b4dc03c97881a07dfdeb33dc&#34;&gt;&lt;code&gt;xwos_flg_trywait()&lt;/code&gt;&lt;/a&gt; ：检查事件，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;触发条件&#34;&gt;触发条件&lt;/h3&gt;
&lt;p&gt;当调用等待事件的CAPI时，需要指定触发条件（参数： &lt;code&gt;trigger&lt;/code&gt; ）。触发条件分为 &lt;strong&gt;电平触发&lt;/strong&gt; 和 &lt;strong&gt;边沿触发&lt;/strong&gt; 。&lt;/p&gt;
&lt;h5 id=&#34;电平触发&#34;&gt;电平触发&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;电平触发&lt;/strong&gt; 源于数字电路，是一种类比概念，是指事件位的特定的状态（ &lt;strong&gt;1&lt;/strong&gt; 或 &lt;strong&gt;0&lt;/strong&gt; ）所产生的触发信号，下面的触发条件均为电平触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gac1bba82f45d1fb1796550b88b646c93b&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_SET_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位被置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gaaf92bdb3000f9b8c8981153560c126f7&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_SET_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位被置 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga2ac150517b9920b96d30085dab3c0385&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_CLR_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位被清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga7d1b859f2f363c78e413255244b0b023&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_CLR_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位被清 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;边沿触发&#34;&gt;边沿触发&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;边沿触发&lt;/strong&gt; 源于数字电路，是一种类比概念，是指事件状态发生改变（ &lt;strong&gt;1&lt;/strong&gt; 变 &lt;strong&gt;0&lt;/strong&gt; 或 &lt;strong&gt;0&lt;/strong&gt; 变 &lt;strong&gt;1&lt;/strong&gt; ）时产生的唤醒信号，下面的触发条件为边沿触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#ga790d7ae9a4ce53ffe53db0be8e1395a3&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_TGL_ALL&lt;/code&gt;&lt;/a&gt; ：所有事件位发生翻转&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__flg__trigger__em.html#gad3ddf23fa1fa775bf577bf1c69184ead&#34;&gt;&lt;code&gt;XWOS_FLG_TRIGGER_TGL_ANY&lt;/code&gt;&lt;/a&gt; ：任意事件位发生翻转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边沿触发时，必须要有一个初始状态，就像数字电路一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当位的初始值为 &lt;strong&gt;0&lt;/strong&gt; (低电平)，然后跳变到 &lt;strong&gt;1&lt;/strong&gt; (高电平)的瞬间被称为上升沿。此时触发的事件被称为上升沿触发。&lt;/li&gt;
&lt;li&gt;当位的初始值为 &lt;strong&gt;1&lt;/strong&gt; (高电平)，然后跳变到 &lt;strong&gt;0&lt;/strong&gt; (低电平)的瞬间被称为下降沿。此时触发的事件被称为下降沿触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;清除事件&#34;&gt;清除事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当采用 &lt;strong&gt;电平触发&lt;/strong&gt; 时，需要在读取事件位图后 &lt;strong&gt;清除&lt;/strong&gt; 事件标志位，否则事件会一直处于触发状态。
可以在调用CAPI时，指定参数 &lt;code&gt;action&lt;/code&gt; 为 &lt;a href=&#34;../../../../capi/group__xwos__flg__action__em.html#gad5dda65f6fb9b3c9ef0586356569039a&#34;&gt;&lt;code&gt;XWOS_FLG_ACTION_CONSUMPTION&lt;/code&gt;&lt;/a&gt; 。 &lt;strong&gt;清除&lt;/strong&gt; 的含义是：
&lt;ul&gt;
&lt;li&gt;当线程等待的是位图中的事件位被置 &lt;strong&gt;1&lt;/strong&gt; ， &lt;strong&gt;清除&lt;/strong&gt; 是指将这些位清 &lt;strong&gt;0&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;当线程等待的是位图中的事件位被清 &lt;strong&gt;0&lt;/strong&gt; ， &lt;strong&gt;清除&lt;/strong&gt; 是指将这些位置 &lt;strong&gt;1&lt;/strong&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当采用 &lt;strong&gt;边沿触发&lt;/strong&gt; 时，不需要 &lt;strong&gt;清除&lt;/strong&gt; 事件的触发条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga534a3b72742f053a82aa431765bdf63b&#34;&gt;&lt;code&gt;xwos_flg_bind()&lt;/code&gt;&lt;/a&gt; 将事件标志绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当等待的事件发生时，事件标志会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的事件标志可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga7f2340c7a08c61f3ae440b66675543aa&#34;&gt;&lt;code&gt;xwos_flg_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;事件标志对象的生命周期管理&#34;&gt;事件标志对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;事件标志对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
事件标志对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga6f4e9f7fc6eedef1b768d630793b24ce&#34;&gt;&lt;code&gt;xwos_flg_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga59586743a7e9812eb867adb21f9f93d6&#34;&gt;&lt;code&gt;xwos_flg_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gab5e8cd7ee6255280140a8b3375baf85f&#34;&gt;&lt;code&gt;xwos_flg_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga2d62426ddce0d88a8a3e495319d64df1&#34;&gt;&lt;code&gt;xwos_flg_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/flg.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: CRC</title>
      <link>/docs/TechRefManual/Xwlib/Crc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/Crc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRC8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__crc8.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/crc8.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRC32&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__lib__crc32.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/crc32.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 配置</title>
      <link>/docs/TechRefManual/Cfg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Cfg/</guid>
      <description>
        
        
        &lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;XWOS所有配置文件都集中于 &lt;code&gt;电路板名称/cfg&lt;/code&gt; 文件夹中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cfg/project.h&lt;/code&gt; ：工程配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/arch.h&lt;/code&gt; ：ARCH配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/cpu.h&lt;/code&gt; ：CPU配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/soc.h&lt;/code&gt; ：SOC配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/board.h&lt;/code&gt; ：电路板配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwos.h&lt;/code&gt; ：内核配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwmd.h&lt;/code&gt; ：中间件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwcd.h&lt;/code&gt; ：芯片与外设配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwem.h&lt;/code&gt; ：第三方组件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwam.h&lt;/code&gt; ：应用配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/oem.h&lt;/code&gt; ：OEM模块配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/autogen.h&lt;/code&gt; ：自动生成的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置说明&#34;&gt;配置说明&lt;/h2&gt;
&lt;p&gt;XWOS在设计之初曾考虑过使用现成的配置生成工具，例如Linux内核的Kconfig工具。
但为了降低跨平台开发的工作量和难度，最终选择使用C语言的头文件来描述所有配置。&lt;/p&gt;
&lt;h3 id=&#34;projecth-工程配置文件&#34;&gt;&lt;strong&gt;project.h&lt;/strong&gt; ：工程配置文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARCH&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_ARCH&lt;/code&gt; ：架构，可在 &lt;code&gt;xwcd/soc/&lt;/code&gt; 中选择 &lt;strong&gt;架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_SUBARCH&lt;/code&gt; ：子架构，可在 &lt;strong&gt;架构文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;子架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_COMPILER&lt;/code&gt; ：编译器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; ：选择gcc作为编译器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llvm&lt;/code&gt; / &lt;code&gt;clang&lt;/code&gt; ：选择clang作为编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_LIBC&lt;/code&gt; ：标准C库，目前支持
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newlib&lt;/code&gt; ：选择newlib作为C库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;picolibc&lt;/code&gt; ：选择picolibc作为C库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; ：不链接到C库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_LDSCRIPT&lt;/code&gt; ：链接脚本的的相对路径，相对于 &lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_CPU&lt;/code&gt; ：CPU子集，可在 &lt;strong&gt;架构文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;CPU文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOC&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_SOC&lt;/code&gt; ：片上系统，可在 &lt;strong&gt;CPU文件夹&lt;/strong&gt; 中选择 &lt;strong&gt;SOC文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电路板&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_BOARD&lt;/code&gt; ：电路板，可在 &lt;code&gt;xwbd/&lt;/code&gt; 中选择 &lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核配置&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCFG_CORE&lt;/code&gt; ：单核与多核的选择，可选择编译 &lt;code&gt;xwos/&lt;/code&gt; 下的哪种内核
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mp&lt;/code&gt; ：多核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt; ：单核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWCD&lt;/code&gt; ：是否需要引用芯片、驱动库，路径 &lt;code&gt;xwcd/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWMD&lt;/code&gt; ：是否需要引用中间件库，路径 &lt;code&gt;xwmd/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWEM&lt;/code&gt; ：是否需要引用第三方组件库，路径 &lt;code&gt;xwem/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_XWAM&lt;/code&gt; ：是否需要引用应用组件库，路径 &lt;code&gt;xwam/&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCFG_OEMPATH&lt;/code&gt; ：OEM模块的搜索路径
&lt;ul&gt;
&lt;li&gt;可以是相对路径，相对于 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以为绝对路径&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;archh-arch配置&#34;&gt;&lt;strong&gt;arch.h&lt;/strong&gt; ：ARCH配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据大小端选择，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LITTLE_ENDIAN&lt;/code&gt; ：小端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_BIG_ENDIAN&lt;/code&gt; ：大端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构位宽，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_32BIT&lt;/code&gt; ：32位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_64BIT&lt;/code&gt; ：64位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点单元
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_FPU&lt;/code&gt; ：是否包含浮点单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C标准库
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_COMPILER_ERRNO&lt;/code&gt; ：是否使用libc的 &lt;code&gt;errno.h&lt;/code&gt; 中定义的错误码，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位操作与原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位操作函数&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位图操作函数&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWAOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的原子操作函数集&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPAOP_&amp;lt;OP&amp;gt;&lt;/code&gt; ：是否使用汇编实现的位图原子操作函数集&amp;lt;OP&amp;gt;，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpuh-cpu配置&#34;&gt;&lt;strong&gt;cpu.h&lt;/strong&gt; ：CPU配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_CPU_NUM&lt;/code&gt; ：CPU数量，仅仅对SMP的系统有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_L1_CACHELINE_SIZE&lt;/code&gt; ：L1缓存的CacheLine大小，仅对有1级缓冲的SOC有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;soch-soc配置&#34;&gt;&lt;strong&gt;soc.h&lt;/strong&gt; ：SOC配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ARM-M
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_PRIO_BITNUM&lt;/code&gt; ：ARM-M中断优先级寄存器的位数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_SUBPRIO_BITIDX&lt;/code&gt; ：ARM-M子中断优先级从第几位开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供 &lt;strong&gt;CRC32&lt;/strong&gt; 计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供 &lt;strong&gt;CRC8&lt;/strong&gt; 计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nuclei RISC-V bumblebee (rv32imac)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EPPC (e200z0)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt; ：SOC异常数量，固定为9&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt; ：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_SYSHWT_SRCCLK&lt;/code&gt; ：滴答定时器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_SYSHWT_CHANNEL&lt;/code&gt; ：滴答定时器的通道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC&lt;/code&gt; ：是有启用外部快速晶振&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC_VALUE&lt;/code&gt; ：外部快速晶振的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FXOSC_DIV&lt;/code&gt; ：外部快速晶振的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC&lt;/code&gt; ：是否启用内部的快速RC振荡器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC_VALUE&lt;/code&gt; ：内部快速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FIRC_DIV&lt;/code&gt; ：内部快速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC&lt;/code&gt; ：是否启用外部慢速晶振&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC_VALUE&lt;/code&gt; ：外部慢速晶振的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SCOSC_DIV&lt;/code&gt; ：外部慢速晶振的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SIRC_VALUE&lt;/code&gt; ：内部慢速RC振荡器的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_SIRC_DIV&lt;/code&gt; ：内部慢速RC振荡器的分频系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CLK_FMPLL_VALUE&lt;/code&gt; ：锁相环的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BUG&lt;/code&gt; ：SOC是否提供 &lt;code&gt;soc_bug()&lt;/code&gt; 的定义，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BKUP&lt;/code&gt; ：是否启用备用RAM区域，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt; ：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;boardh-电路板配置&#34;&gt;&lt;strong&gt;board.h&lt;/strong&gt; ：电路板配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XWOS HOOK
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt; ：是否使用空闲任务HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_idle_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_PRE_SWCX_HOOK&lt;/code&gt; ：是否使用任务切换前HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_pre_swcx_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_POST_SWCX_HOOK&lt;/code&gt; ：是否使用任务切换后HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_post_swcx_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt; ：是否使用系统滴答定时器中断HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_xwskd_syshwt_hook(struct xwospl_skd *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_STACK_POOL&lt;/code&gt; ：是否提供了线程栈的内存池，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;xwer_t board_thd_stack_pool_alloc(xwsz_t , xwstk_t **)&lt;/code&gt; 与 &lt;code&gt;xwer_t board_thd_stack_pool_free(xwstk_t *)&lt;/code&gt; 的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_POSTINIT_HOOK&lt;/code&gt; ：是否使用线程初始化后HOOK，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当取值 &lt;code&gt;1&lt;/code&gt; 时，需要提供 &lt;code&gt;void board_thd_postinit_hook(struct xwospl_thd *)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_LOG&lt;/code&gt; ：是否支持日志打印，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 。取值为 &lt;code&gt;1&lt;/code&gt; 时需要提供 &lt;code&gt;board_log_write()&lt;/code&gt; 的定义，用于log字符串的输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_DCACHE&lt;/code&gt; ：是否支持DCACHE，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_ICACHE&lt;/code&gt; ：是否支持ICACHE，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二进制标记
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_FIRMWARE_TAILFLAG&lt;/code&gt; ：定义编译后的bin文件尾的标记字符串，可用于升级功能检查文件是否完整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路板模块的配置： &lt;code&gt;BMCFG_&amp;lt;module&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;电路板模块的路径需要按照 &lt;a href=&#34;./BuildSystem#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;&lt;strong&gt;构建系统&lt;/strong&gt;&lt;/a&gt; 的规则转换为配置宏，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwosh-内核配置&#34;&gt;&lt;strong&gt;xwos.h&lt;/strong&gt; ：内核配置&lt;/h3&gt;
&lt;p&gt;操作系统相关的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_BUG&lt;/code&gt; ：是否启用BUG调试，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;玄武C库：
&lt;ul&gt;
&lt;li&gt;日志
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_LOG&lt;/code&gt; ：是否启用Log调试，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt; ：最低日志等级；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_BUFSIZE&lt;/code&gt; ：日志格式化缓冲区大小；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_SC&lt;/code&gt; ：是否启用系统调用，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP8&lt;/code&gt; ：是否启用8位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP16&lt;/code&gt; ：是否启用16位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP32&lt;/code&gt; ：是否启用32位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP64&lt;/code&gt; ：是否启用64位原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWBMPAOP&lt;/code&gt; ：是否启用位图原子操作库，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据结构
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_MAP&lt;/code&gt; ：是否启用键值对，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRC
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32&lt;/code&gt; ：是否启用CRC32，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0X04C11DB7&lt;/code&gt; ：是否启用CRC32多项式0x04C11DB7，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0XEDB88320&lt;/code&gt; ：是否启用CRC32多项式0xEDB88320，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8&lt;/code&gt; ：是否启用CRC8，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X07&lt;/code&gt; ：是否启用CRC8多项式0x07，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X31&lt;/code&gt; ：是否启用CRC8多项式0x31，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X9B&lt;/code&gt; ：是否启用CRC8多项式0x9B，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;长跳转
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_SETJMP&lt;/code&gt; ：是否启用 &lt;code&gt;setjmp()/longjmp()&lt;/code&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存管理
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_ALIGNMENT&lt;/code&gt; ：内存管理对齐的字节数，通常设置为8字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_ALIGNMENT&lt;/code&gt; ：线程栈对齐的字节数，通常设置为8字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_SIZE_DEFAULT&lt;/code&gt; ：栈内存的默认大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_SIZE_MIN&lt;/code&gt; ：栈内存大小的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_GUARD_SIZE_DEFAULT&lt;/code&gt; ：栈的默认警戒线位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_CHK_SWCX&lt;/code&gt; ：是否在切换上下文时检查栈溢出，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;栈的类型，只可选择一种配置为 &lt;code&gt;1&lt;/code&gt; ：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FD_STACK&lt;/code&gt; ：满递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_ED_STACK&lt;/code&gt; ：空递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FA_STACK&lt;/code&gt; ：满递增栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_EA_STACK&lt;/code&gt; ：满递增栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMSLICE&lt;/code&gt; ：是否启用内存切片算法，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_BMA&lt;/code&gt; ：是否启用伙伴算法，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMPOOL&lt;/code&gt; ：是否启用内存池，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核配置
&lt;ul&gt;
&lt;li&gt;调度器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYSHWT_PERIOD&lt;/code&gt; ：硬件定时器周期，单位纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_PRIORITY_RT_NUM&lt;/code&gt; ：调度器实时优先级数量，数量越小越省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_IDLE_STACK_SIZE&lt;/code&gt; ：空闲任务栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_IDLE_TLS&lt;/code&gt; ：是否启用空闲任务的TLS(线程本地私有变量)，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH&lt;/code&gt; ：是否启用中断底半部，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH_STACK_SIZE&lt;/code&gt; ：中断底半部栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_BH_TLS&lt;/code&gt; ：是否启用中断底半部任务的TLS(线程本地私有变量)，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_PM&lt;/code&gt; ：是否启用电源管理，此配置只对单核系统有效，多核系统不可关闭电源管理。取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_PRIVILEGED_DEFAULT&lt;/code&gt; ：线程是否默认为特权线程，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_MEMPOOL&lt;/code&gt; ：是否启用mempool线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_MEMSLICE&lt;/code&gt; ：是否启用memslice线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_SMA&lt;/code&gt; ：是否启用sma线程对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_STDC_MM&lt;/code&gt; ：是否启用C标准库中的 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建线程对象，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_LOCAL_DATA_NUM&lt;/code&gt; ：线程私有数据的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_THD_EXIT&lt;/code&gt; ：是否启用线程退出，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT&lt;/code&gt; ：是否启用软件定时器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_MEMPOOL&lt;/code&gt; ：是否启用mempool软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_MEMSLICE&lt;/code&gt; ：是否启用memslice软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_SMA&lt;/code&gt; ：是否启用sma软件定时器对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SKD_SWT_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建定时器对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_PLSEM&lt;/code&gt; ：是否启用管道信号量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_RTSEM&lt;/code&gt; ：是否启用实时信号量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_MEMPOOL&lt;/code&gt; ：是否启用mempool信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_MEMSLICE&lt;/code&gt; ：是否启用memslice信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_SMA&lt;/code&gt; ：是否启用sma信号量对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_SEM_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建信号量对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND&lt;/code&gt; ：是否启用条件量，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_MEMPOOL&lt;/code&gt; ：是否启用mempool条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_MEMSLICE&lt;/code&gt; ：是否启用memslice条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_SMA&lt;/code&gt; ：是否启用memslice条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_COND_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建条件量对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT&lt;/code&gt; ：是否启用事件，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_MEMPOOL&lt;/code&gt; ：是否启用mempool事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_MEMSLICE&lt;/code&gt; ：是否启用memslice事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_SMA&lt;/code&gt; ：是否启用sma事件对象缓存，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_SYNC_EVT_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建事件对象，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX&lt;/code&gt; ：是否启用互斥锁，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_MEMPOOL&lt;/code&gt; ：是否启用mempool互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_MEMSLICE&lt;/code&gt; ：是否启用memslice互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_SMA&lt;/code&gt; ：是否启用sma互斥锁对象缓存，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_MTX_STDC_MM&lt;/code&gt; ：是否启用C标准库中 &lt;code&gt;malloc()&lt;/code&gt; 来动态创建互斥锁对象，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOSCFG_LOCK_FAKEMTX&lt;/code&gt; ：是否启用虚假互斥锁，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwmdh-中间件配置&#34;&gt;&lt;strong&gt;xwmd.h&lt;/strong&gt; ：中间件配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc&lt;/code&gt; ：是否启用点对点通讯协议，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_LOG&lt;/code&gt; ：是否开启日志，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_PORT_NUM&lt;/code&gt; ：消息通道的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_PRI_NUM&lt;/code&gt; ：消息优先级的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RETRY_PERIOD&lt;/code&gt; ：重发消息的周期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RETRY_NUM&lt;/code&gt; ：重发消息的最大次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_MEMBLK_SIZE&lt;/code&gt; ：用于发送与接收的单位内存块的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_MEMBLK_ODR&lt;/code&gt; ：单位内存块的数量，以2的n次方形式表示，此处配置的是指数n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_RXTHD_PRIORITY&lt;/code&gt; ：接收线程的优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwssc_TXTHD_PRIORITY&lt;/code&gt; ：发送线程的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq&lt;/code&gt; ：是否启用消息队列，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwcq&lt;/code&gt; ：是否启用循环队列，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc&lt;/code&gt; ：是否启用libc的适配代码，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_xwrust_ffi&lt;/code&gt; ：是否启用XWOS RUST的底层C语言接口，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwcdh芯片与外设配置&#34;&gt;xwcd.h：芯片与外设配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_CHECK_PARAMETERS&lt;/code&gt; ：是否开启API参数检查，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds&lt;/code&gt; ：是否启用玄武设备栈，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LITE&lt;/code&gt; ：是否启用LITE版的玄武设备栈，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_PM&lt;/code&gt; ：是否启用电源管理，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC&lt;/code&gt; ：是否启用SOC，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_CLK&lt;/code&gt; ：是否启用SOC的Clock，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_PWR&lt;/code&gt; ：是否启用SOC的Power，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_GPIO&lt;/code&gt; ：是否启用SOC的GPIO，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_EIRQ&lt;/code&gt; ：是否启用SOC的外部IO中断，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_EIRQ_ROISRT&lt;/code&gt; ：SOC外部IO中断向量表是否为 &lt;code&gt;const&lt;/code&gt; 的，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_DMA&lt;/code&gt; ：是否启用SOC的DMA，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SOC_DMA_ROCBT&lt;/code&gt; ：SOC外部DMA回调函数表是否为 &lt;code&gt;const&lt;/code&gt; 的，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_UART&lt;/code&gt; ：是否启用UART，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_UART_RXQ_SIZE&lt;/code&gt; ：UART接收队列的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_I2C_MASTER&lt;/code&gt; ：是否启用I2C总线控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_I2C_PERIPHERAL&lt;/code&gt; ：是否启用I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SPI_MASTER&lt;/code&gt; ：是否启用SPI总线控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_SPI_PERIPHERAL&lt;/code&gt; ：是否启用SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LIN&lt;/code&gt; ：是否启用LIN总线，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_LINID&lt;/code&gt; ：是否启用LIN总线的ID校验表，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN&lt;/code&gt; ：是否启用CAN总线，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER&lt;/code&gt; ：是否启用CAN控制器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_ROCBT&lt;/code&gt; ：CAN控制器的回调函数表是否为只读，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_SDU_MAXSIZE&lt;/code&gt; ：CAN消息数据的最大数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_RXQNUM&lt;/code&gt; ：CAN接收队列的最大数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_I2CP&lt;/code&gt; ：CAN控制器是否为I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_CONTROLLER_SPIP&lt;/code&gt; ：CAN控制器是否为SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER&lt;/code&gt; ：是否启用CAN接收器，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER_I2CP&lt;/code&gt; ：CAN接收器是否为I2C外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_CAN_TRANSCEIVER_SPIP&lt;/code&gt; ：CAN接收器是否为SPI外设，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_ds_MISC&lt;/code&gt; ：是否启用MISC设备，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_i2c_eeprom&lt;/code&gt; ：是否启用I2C EEPROM的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_spi_flash_w25qxx&lt;/code&gt; ：是否启用SPI FLASH W25Q的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_spi_lcd_st7735&lt;/code&gt; ：是否启用SPI LCD ST7735的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWCDCFG_peripheral_can_transceiver_tja1042&lt;/code&gt; ：是否启用CAN收发器TJA1042的驱动，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwemh第三方软件配置&#34;&gt;xwem.h：第三方软件配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_serializing_nanopb&lt;/code&gt; ：是否启用protobuf-nanopb，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_fatfs&lt;/code&gt; ：是否启用FatFs，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_littlefs&lt;/code&gt; ：是否启用littlefs，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_spiffs&lt;/code&gt; ：是否启用spiffs，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_dhara&lt;/code&gt; ：是否启用dhara，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua&lt;/code&gt; ：是否启用Lua语言，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_INT_TYPE&lt;/code&gt; ：Lua语言中整数类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_FLOAT_TYPE&lt;/code&gt; ：Lua语言中浮点类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_THD_STACK_SIZE&lt;/code&gt; ：Lua交互式解释器线程的栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_BRDLIBS&lt;/code&gt; ：是否启用BSP中Lua库，取值：&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwamh应用配置&#34;&gt;xwam.h：应用配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_xwobj&lt;/code&gt; ：是否启用示例 &lt;strong&gt;玄武对象&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_new&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的创建&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_exit&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的退出&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_thd_sleep&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程的睡眠&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_swt&lt;/code&gt; ：是否启用示例 &lt;strong&gt;软件定时器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_cpuirq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;CPU中断&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_mtx&lt;/code&gt; ：是否启用示例 &lt;strong&gt;互斥锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_spinlock&lt;/code&gt; ：是否启用示例 &lt;strong&gt;自旋锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_lock_seqlock&lt;/code&gt; ：是否启用示例 &lt;strong&gt;顺序锁&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_sem&lt;/code&gt; ：是否启用示例 &lt;strong&gt;信号量&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_cond&lt;/code&gt; ：是否启用示例 &lt;strong&gt;条件量&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_br&lt;/code&gt; ：是否启用示例 &lt;strong&gt;线程栅栏&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_flg&lt;/code&gt; ：是否启用示例 &lt;strong&gt;事件标志&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_sync_sel&lt;/code&gt; ：是否启用示例 &lt;strong&gt;信号选择器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_sma&lt;/code&gt; ：是否启用示例 &lt;strong&gt;简单内存分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_memslice&lt;/code&gt; ：是否启用示例 &lt;strong&gt;内存切片分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_mm_bma&lt;/code&gt; ：是否启用示例 &lt;strong&gt;伙伴算法分配器&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_xwlib_crc&lt;/code&gt; ：是否启用示例 &lt;strong&gt;CRC计算&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_cxx&lt;/code&gt; ：是否启用示例 &lt;strong&gt;C++&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_isc_xwmq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;消息队列&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_example_isc_xwcq&lt;/code&gt; ：是否启用示例 &lt;strong&gt;循环队列&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_application_w25qrpt&lt;/code&gt; ：是否启用应用 &lt;strong&gt;W25Q读写工具&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWAMCFG_application_ramcode&lt;/code&gt; ：是否启用应用 &lt;strong&gt;RAMCODE&lt;/strong&gt; ，取值： &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程栅栏</title>
      <link>/docs/TechRefManual/Sync/Br/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Br/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的线程栅栏是用于协调多个线程并行工作的同步机制。&lt;/p&gt;
&lt;p&gt;线程栅栏在创建时，会指明有多少个线程槽。
当线程到达线程栅栏时会阻塞并等待，直到指定数量的线程都达到线程栅栏，所有线程被同时唤醒。&lt;/p&gt;
&lt;h3 id=&#34;线程栅栏对象与对象描述符描述符&#34;&gt;线程栅栏对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;线程栅栏对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，线程栅栏对象也用 &lt;strong&gt;线程栅栏对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__br__d.html&#34;&gt;&lt;code&gt;xwos_br_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;线程栅栏对象描述符由 &lt;strong&gt;线程栅栏对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_br &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; br; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 线程栅栏对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_br_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;线程栅栏的初始化销毁与动态创建删除&#34;&gt;线程栅栏的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga14263f3e94d189d110eb62bdceca51b5&#34;&gt;&lt;code&gt;xwos_br_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的线程栅栏： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gadf0ab06127734021e54209b8fb9b8cf1&#34;&gt;&lt;code&gt;xwos_br_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga01340bc335a510cde0aea244ae6e55b0&#34;&gt;&lt;code&gt;xwos_br_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的线程栅栏： &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga0562246ab3c7f893323c9103b93bdaba&#34;&gt;&lt;code&gt;xwos_br_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通过线程栅栏同步线程&#34;&gt;通过线程栅栏同步线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga6b28c7fe0cb6e0569f5bdc93fa7f0afe&#34;&gt;&lt;code&gt;xwos_br_wait()&lt;/code&gt;&lt;/a&gt; ：等待所有线程到达栅栏，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga22bb233fcefa640a3d3e196eac1c5753&#34;&gt;&lt;code&gt;xwos_br_wait_to()&lt;/code&gt;&lt;/a&gt; ：限时等待所有线程到达栅栏，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑信号选择器&#34;&gt;绑定与解绑信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_br_bind()&lt;/code&gt;&lt;/a&gt; 将线程栅栏绑定到 &lt;a href=&#34;../Sel&#34;&gt;&lt;strong&gt;信号选择器&lt;/strong&gt;&lt;/a&gt; 上。
当指定数量的线程抵达线程栅栏时，线程栅栏会向 &lt;strong&gt;信号选择器&lt;/strong&gt; 发送一个 &lt;strong&gt;选择信号&lt;/strong&gt; 。此时 &lt;strong&gt;信号选择器&lt;/strong&gt; 会唤醒正在等待的线程。&lt;/p&gt;
&lt;p&gt;绑定后的线程栅栏可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_br_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;线程栅栏对象的生命周期管理&#34;&gt;线程栅栏对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;线程栅栏对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
线程栅栏对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga7402fda20860499d41f347a0b69ded8b&#34;&gt;&lt;code&gt;xwos_br_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae9d7efa29affa54491a5bc59e12f5691&#34;&gt;&lt;code&gt;xwos_br_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#ga5ad53ec7b82b801714b872f580896db4&#34;&gt;&lt;code&gt;xwos_br_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafd544bdd7b0b78a883ecb7eb66b7ea31&#34;&gt;&lt;code&gt;xwos_br_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/br.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 构建系统</title>
      <link>/docs/TechRefManual/BuildSystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/BuildSystem/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;俗话说：工欲善其事，必先利其器。
一切美好的想法都需要合适的开发环境来实践。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS构建系统基于 &lt;code&gt;make&lt;/code&gt; 编写，特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持纯命令行方式编译，可用于持续集成环境中；&lt;/li&gt;
&lt;li&gt;可跨平台使用，支持linux、Windows、MACOS；&lt;/li&gt;
&lt;li&gt;支持基于Eclipse的IDE；&lt;/li&gt;
&lt;li&gt;为了方便集成第三方软件，XWOS参考了Android的构建系统的 &lt;code&gt;Android.mk&lt;/code&gt; 设计出 &lt;code&gt;xwmo.mk&lt;/code&gt; ，
称为 &lt;strong&gt;玄武模块&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建流程&#34;&gt;构建流程&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TD
    make(&amp;#34;make&amp;#34;) --&amp;gt; cfg
    cfg[&amp;#34;生成配置&amp;#34;] --&amp;gt; arch
    arch[&amp;#34;编译arch.a&amp;#34;] --&amp;gt; cpu
    cpu[&amp;#34;编译cpu.a&amp;#34;] --&amp;gt; soc
    soc[&amp;#34;编译soc.a&amp;#34;] --&amp;gt; brd
    brd[&amp;#34;编译brd.a&amp;#34;] --&amp;gt; xwos
    xwos[&amp;#34;编译XWOS内核&amp;#34;] --&amp;gt; xwmd
    xwmd[&amp;#34;编译中间件模块&amp;#34;] --&amp;gt; xwcd
    xwcd[&amp;#34;编译设备模块&amp;#34;] --&amp;gt; bm
    bm[&amp;#34;编译电路板模块&amp;#34;] --&amp;gt; xwem
    xwem[&amp;#34;编译第三方软件模块&amp;#34;] --&amp;gt; xwam
    xwam[&amp;#34;编译应用模块&amp;#34;] --&amp;gt; oem
    oem[&amp;#34;编译OEM模块&amp;#34;] --&amp;gt; elf
    elf[&amp;#34;链接ELF文件&amp;#34;] --&amp;gt; bin
    bin[&amp;#34;生成bin文件&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;开始&#34;&gt;开始&lt;/h3&gt;
&lt;p&gt;XWOS的构建是从 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 下执行命令 &lt;code&gt;make&lt;/code&gt; 开始的，以 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; 代表此目录。
执行 &lt;code&gt;make&lt;/code&gt; 时，可传递参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WKSPC=output-dir&lt;/code&gt; ：配置输出文件的路径，可为相对于 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 的路径，也可为绝对路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS=topdir&lt;/code&gt; ：配置XWOS的根路径，可为相对于 &lt;strong&gt;电路板描述层目录&lt;/strong&gt; 的路径，也可为绝对路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成配置&#34;&gt;生成配置&lt;/h3&gt;
&lt;p&gt;构建系统调用脚本 &lt;code&gt;XWOS/xwbs/util/el/mkcfg.el&lt;/code&gt; 处理 &lt;code&gt;$(XWOS_BRD_DIR)/cfg&lt;/code&gt; 下的所有配置文件，
将它们转化成三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/XWOS.cfg&lt;/code&gt; ， &lt;code&gt;makefile&lt;/code&gt; 环境变量，之后被 &lt;code&gt;makefile&lt;/code&gt; 引入。
&lt;ul&gt;
&lt;li&gt;其中包含一些关键的路径信息，不同的SOC通过这些路径找到各自的编译配置：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_PATH)&lt;/code&gt; ： XWOS源码的根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_ARCH_DIR)&lt;/code&gt; ：架构相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_CPU_DIR)&lt;/code&gt; ：CPU相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_SOC_DIR)&lt;/code&gt; ：SOC相关的源码路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; ：电路板相关的源码路径，此路经也是最开始执行&lt;code&gt;make&lt;/code&gt;的地方；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BM_DIR)&lt;/code&gt; ：电路板相关的玄武模块路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; ：OEM相关的玄武模块路径，通常为私有代码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; ： &lt;code&gt;$(XWOS_WKSPC_DIR)/obj&lt;/code&gt; ，编译输出的目录；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_BRD_DIR)/cfg/autogen.h&lt;/code&gt; ，自动生成的头文件，被顶级头文件 &lt;code&gt;xwos/standard.h&lt;/code&gt; 包含&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/XWOS.cfg.rs&lt;/code&gt; ：Rust语言的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(XWOS_WKSPC_DIR)/env.rc&lt;/code&gt; ， &lt;strong&gt;shell&lt;/strong&gt; 环境变量脚本，可通过 &lt;code&gt;source&lt;/code&gt; 命令引入这个文件，使得 &lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt; 生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译-archa&#34;&gt;编译 &lt;code&gt;arch.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_ARCH_DIR)/arch.mk&lt;/code&gt; 编译架构描述层(Arch Description Layer)的源码。
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_ARCH_DIR)/arch.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-cpua&#34;&gt;编译 &lt;code&gt;cpu.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_CPU_DIR)/arch.mk&lt;/code&gt; 编译CPU描述层(CPU Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_CPU_DIR)/cpu.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-soca&#34;&gt;编译 &lt;code&gt;soc.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_SOC_DIR)/soc.mk&lt;/code&gt; 编译SOC描述层(SOC Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_SOC_DIR)/soc.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译-brda&#34;&gt;编译 &lt;code&gt;brd.a&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;$(XWOS_BRD_DIR)/brd.mk&lt;/code&gt; 编译电路板描述层(Board Description Layer)的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_BRD_DIR)/brd.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译xwos内核&#34;&gt;编译XWOS内核&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则 &lt;code&gt;xwos/xwos.mk&lt;/code&gt; 编译XWOS内核的源码，
编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。编译后输出静态库 &lt;code&gt;$(XWOS_OBJ_DIR)/$(XWOS_XWOS_DIR)/xwos.a&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;编译中间件模块&#34;&gt;编译中间件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwmd/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWMDCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译设备模块&#34;&gt;编译设备模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwcd/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWCDCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译电路板模块&#34;&gt;编译电路板模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;$(XWOS_BM_DIR)&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/board.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;BMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译第三方软件模块&#34;&gt;编译第三方软件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwem/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWEMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译应用模块&#34;&gt;编译应用模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;xwam/&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;XWAMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译oem模块&#34;&gt;编译OEM模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OEM文件夹路径由位于配置文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/XWOS.h&lt;/code&gt; 中的
配置 &lt;code&gt;XWCFG_OEMPATH&lt;/code&gt; 指定：
&lt;ul&gt;
&lt;li&gt;可以是相对于 &lt;code&gt;$(XWOS_BRD_DIR)&lt;/code&gt; 的相对路径；&lt;/li&gt;
&lt;li&gt;可以是绝对路径；&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外。&lt;/li&gt;
&lt;li&gt;配置工具 &lt;code&gt;xwbs/util/el/mkcfg.el&lt;/code&gt; 会根据此配置生成变量 &lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建系统会递归扫描 &lt;code&gt;$(XWOS_OEM_DIR)&lt;/code&gt; 文件夹以及子文件下的所有 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件，生成模块列表，
依次将它们编译成 &lt;code&gt;.a&lt;/code&gt; 静态库，输出到 &lt;code&gt;$(XWOS_OBJ_DIR)/oem&lt;/code&gt; 目录下。&lt;/li&gt;
&lt;li&gt;编译时头文件搜索的起始目录为 &lt;code&gt;$(XWOS_PATH)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个模块，构建系统会另启一个子进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。&lt;/li&gt;
&lt;li&gt;每个中间件模块在 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/oem.h&lt;/code&gt; 中都有一个编译开关 &lt;code&gt;OEMCFG_&lt;/code&gt; 的宏定义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 时表示编译这个模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 或 &lt;strong&gt;未定义&lt;/strong&gt; 表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考 &lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链接elf文件&#34;&gt;链接ELF文件&lt;/h3&gt;
&lt;p&gt;构建系统最终会将以上生成的所有 &lt;code&gt;.a&lt;/code&gt; 静态库链接成 &lt;code&gt;XWOS.elf&lt;/code&gt; 文件，
连接脚本由位于配置文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/XWOS.h&lt;/code&gt; 中的 &lt;code&gt;XWCFG_LDSCRIPT&lt;/code&gt; 指定。&lt;/p&gt;
&lt;h3 id=&#34;生成bin文件&#34;&gt;生成bin文件&lt;/h3&gt;
&lt;p&gt;构建系统会将 &lt;strong&gt;XWOS.elf&lt;/strong&gt; 文件转换成 &lt;strong&gt;.bin&lt;/strong&gt; 文件以及 &lt;strong&gt;.hex&lt;/strong&gt; 文件。&lt;/p&gt;
&lt;h2 id=&#34;构建选项&#34;&gt;构建选项&lt;/h2&gt;
&lt;h4 id=&#34;v&#34;&gt;&lt;code&gt;V&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用：输出完整的编译过程。&lt;/li&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项&lt;/li&gt;
&lt;li&gt;0: 关闭选项（默认值）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#b8860b&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;d&#34;&gt;&lt;code&gt;D&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用：优化编译，输出体积较小的二进制，但不利于调试。&lt;/li&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项（默认值）&lt;/li&gt;
&lt;li&gt;0: 关闭选项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#b8860b&#34;&gt;D&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;玄武模块&#34;&gt;玄武模块&lt;/h2&gt;
&lt;p&gt;XWOS的设备模块、中间件模块、第三方软件模块、电路板模块、以及OEM模块，
都是使用 &lt;code&gt;xwmo.mk&lt;/code&gt; 来描述编译规则的，将它们统一称为 &lt;strong&gt;玄武模块(XWMO)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 &lt;code&gt;xwmo.mk&lt;/code&gt; 文件代表了一个 &lt;strong&gt;玄武模块&lt;/strong&gt; ，其原理类似于Android系统中的 &lt;code&gt;Android.mk&lt;/code&gt; 。
构建系统会另启一个进程 &lt;code&gt;make&lt;/code&gt; 对其进行编译，
其中源代码列表、附加编译选项、头文件路径等对每个编译玄武模块的子进程都是独立的。&lt;/p&gt;
&lt;p&gt;示例， &lt;code&gt;xwam/example/cxx&lt;/code&gt; 的&lt;code&gt; xwmo.mk&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含环境变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; mif.c                                     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; task.cxx                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; test/vector.cxx                         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; test/literal.cxx test/exception.cxx &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加仅对gcc生效的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; -Wno-unused-value                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; -fexceptions                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加仅对gcc生效的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的头文件搜索路径，其中使用函数getXwmoDir获得当前xwmo的路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.mk&lt;/span&gt;                                    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模块路径命名规则&#34;&gt;模块路径命名规则&lt;/h3&gt;
&lt;p&gt;由于模块路径需要对应于C语言中的一个宏定义作为编译开关，
因此模块路径需要符合C语言标识符的规则，但可以包含几个特殊符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径各级目录命名要符合C语言命名规则；&lt;/li&gt;
&lt;li&gt;路径中每级目录以 &lt;code&gt;/&lt;/code&gt; 隔开；&lt;/li&gt;
&lt;li&gt;路径中可包含 &lt;code&gt;.&lt;/code&gt; ，但不能出现 &lt;code&gt;../&lt;/code&gt; 和 &lt;code&gt;./&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中可包含 &lt;code&gt;-&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模块编译开关的命名规则&#34;&gt;模块编译开关的命名规则&lt;/h3&gt;
&lt;p&gt;模块必须要有一个与路径对应的宏开关，并被配置为 &lt;code&gt;1&lt;/code&gt; ，才能被编译：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块路径只需要转换相对路径部分：
&lt;ul&gt;
&lt;li&gt;中间件模块：取 &lt;code&gt;xwmd/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;设备驱动模块：取 &lt;code&gt;xwcd/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;电路板模块：取 &lt;code&gt;$(XWOS_BRD_DIR)/bm/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;第三方软件模块：取 &lt;code&gt;xwem/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;应用模块：取 &lt;code&gt;xwam/&lt;/code&gt; （不含）之后的路径；&lt;/li&gt;
&lt;li&gt;OEM模块：取 &lt;code&gt;OEM文件夹/&lt;/code&gt; （不含）之后的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;_&lt;/code&gt; ，需要两个 &lt;code&gt;_&lt;/code&gt; 来表示；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;/&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;.&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;路径中的 &lt;code&gt;-&lt;/code&gt; 被转换成 &lt;code&gt;_&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;增加前缀：
&lt;ul&gt;
&lt;li&gt;中间件模块： &lt;code&gt;XWMDCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设备模块： &lt;code&gt;XWCDCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;电路板模块： &lt;code&gt;BMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三方软件模块： &lt;code&gt;XWEMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用模块： &lt;code&gt;XWAMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OEM模块： &lt;code&gt;OEMCFG_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例：
&lt;ul&gt;
&lt;li&gt;中间件模块： &lt;code&gt;xwmd/isc/xwpcp&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWMDCFG_isc_xwpcp&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;设备驱动模块： &lt;code&gt;xwcd/perpheral/ds/i2c/eeprom&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWCDCFG_perpheral_ds_i2c_eeprom&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;电路板模块： &lt;code&gt;xwbd/WeActMiniStm32H750/bm/stm32_cube&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;BMCFG_stm32__cube&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;第三方软件模块： &lt;code&gt;xwem/vm/l__u_a-5.4.6&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWEMCFG_vm_l____u__a_5_4_6&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;应用模块： &lt;code&gt;xwam/example/cxx&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;XWAMCFG_example_cxx&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;OEM模块： &lt;code&gt;oem/app&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;OEMCFG_app&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以借助 &lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt; 中的 &lt;code&gt;xwmc&lt;/code&gt; 命令生成编译开关的宏标识符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;增加模块&#34;&gt;增加模块&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中间件模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwmd/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设备驱动模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwcd/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;电路板模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;$(XWOS_BRD_DIR)/bm/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/board.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;第三方软件模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwem/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;应用模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于 &lt;code&gt;xwam/&lt;/code&gt; 目录中；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;OEM模块&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;模块位于OEM文件夹内；&lt;/li&gt;
&lt;li&gt;宏编译开关位于文件 &lt;code&gt;$(XWOS_BRD_DIR)/cfg/oem.h&lt;/code&gt; ，定义为 &lt;code&gt;1&lt;/code&gt; 表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwmomk-语法说明&#34;&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 语法说明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 是 &lt;code&gt;makefile&lt;/code&gt; 的一部分，其中语法简化为定义几个特殊的变量即可完成编译。&lt;/p&gt;
&lt;h4 id=&#34;cc&#34;&gt;C/C++&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_ASRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的汇编源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_AFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的汇编编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C++源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对gcc起作用的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 只对llvm起作用的C++编译选项&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS_gcc&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到gcc头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并增加到llvm头文件搜索路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_LUASRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 转换为C语言数组的Lua脚本源文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.mk&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;rust模块&#34;&gt;RUST模块&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.rust.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;预编译模块&#34;&gt;预编译模块&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XWOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/functions.mk&lt;/span&gt;                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含xwbs定义的Makefile函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_PREBUILT&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 预先编译好的.a文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/xwmo.prebuilt.mk&lt;/span&gt;                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用包含编译规则的Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;xwmomk-中可用的函数&#34;&gt;&lt;code&gt;xwmo.mk&lt;/code&gt; 中可用的函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getXwmoDir&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;$(call getXwmoDir)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：获取当前 &lt;strong&gt;玄武模块&lt;/strong&gt; 的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getXwmoName&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;$(call getXwmoName)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：获取当前 &lt;strong&gt;玄武模块&lt;/strong&gt; 的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoWildcard&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoWildcard,WILDCARD,DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：在目录 &lt;code&gt;DIR&lt;/code&gt; 中搜索符合通配符 &lt;code&gt;WILDCARD&lt;/code&gt; 的文件，并输出文件列表。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;XWMO_CSRCS += $(call XwmoWildcard,*.c,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：在 &lt;code&gt;picolibc&lt;/code&gt; 搜索所有的 &lt;code&gt;*.c&lt;/code&gt; 文件，并将返回的文件列表赋值给 &lt;code&gt;XWMO_CSRCS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoWildcardRecursively&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoWildcardRecursively,WILDCARD,DIR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：在目录 &lt;code&gt;DIR&lt;/code&gt; 以及其子目录中搜索符合通配符 &lt;code&gt;WILDCARD&lt;/code&gt; 的文件，并输出文件列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoReqCfg&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoReqCfg,CFG,VALUE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：测试配置 &lt;code&gt;CFG&lt;/code&gt; 是否为 &lt;code&gt;VALUE&lt;/code&gt; ，如果不是就报错。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;$(call XwmoReqCfg,XWCFG_LIBC,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：如果配置 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 不为 &lt;code&gt;picolibc&lt;/code&gt; 就报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;XwmoReqNotCfg&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;$(call XwmoReqNotCfg,CFG,VALUE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简介：测试配置 &lt;code&gt;CFG&lt;/code&gt; 是否为 &lt;code&gt;VALUE&lt;/code&gt; ，如果是就报错。&lt;/li&gt;
&lt;li&gt;用法举例
&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;$(call XwmoReqCfg,XWCFG_LIBC,picolibc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：如果配置 &lt;code&gt;XWCFG_LIBC&lt;/code&gt; 为 &lt;code&gt;picolibc&lt;/code&gt; 就报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;辅助功能&#34;&gt;辅助功能&lt;/h2&gt;
&lt;p&gt;XWOS的编译系统类似于Android，也定义了一些与编译相关的辅助命令。&lt;/p&gt;
&lt;h3 id=&#34;初始化环境&#34;&gt;初始化环境&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;source&lt;/span&gt; xwbd/WeActMiniStm32H750/env.sh &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 以电路板WeActMiniStm32H750为例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmc&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块编译开关的C语言宏标识符。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; XWEMCFG_vm_lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmn&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块的 &lt;strong&gt;.a&lt;/strong&gt; 文件名。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; xwem_vm_lua.a &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：编译整个XWOS工程，类似Android的 &lt;code&gt;m&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;用法： &lt;code&gt;xwm [选项] [目标]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;目标：make的目标&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 编译整个工程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm c &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 清理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwm d &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 侧底清理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的 &lt;code&gt;mm&lt;/code&gt; 命令，使用当前路径作为模块的路径。&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的 &lt;code&gt;mmm&lt;/code&gt; 命令，需要指定模块的路径。&lt;/li&gt;
&lt;li&gt;选项 &lt;code&gt;-B&lt;/code&gt; ：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwmmm xwem/vm/lua
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcroot&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到XWOS的根目录，类似Android的 &lt;code&gt;croot&lt;/code&gt; 命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcbd&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到电路板描述层目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 信号选择器</title>
      <link>/docs/TechRefManual/Sync/Sel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/Sel/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;信号选择器类似于事件标志，使用位图来管理一组 &lt;strong&gt;同步对象&lt;/strong&gt; 。使得单一线程可以同时等待多个 &lt;strong&gt;同步对象&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 &lt;strong&gt;同步对象&lt;/strong&gt; 在信号选择器位图中都绑定一个特定的 &lt;strong&gt;位&lt;/strong&gt; ，&lt;/p&gt;
&lt;p&gt;当这些 &lt;strong&gt;同步对象&lt;/strong&gt; 发送 &lt;strong&gt;选择信号&lt;/strong&gt; 时，信号选择器位图中特定的 &lt;strong&gt;位&lt;/strong&gt; 被置 &lt;strong&gt;1&lt;/strong&gt; ，同时唤醒正在等待信号选择器的线程。
线程唤醒后可以通过检测哪些 &lt;strong&gt;位&lt;/strong&gt; 被置 &lt;strong&gt;1&lt;/strong&gt; 来判断哪些 &lt;strong&gt;同步对象&lt;/strong&gt; 发送了 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;信号选择器对象与对象描述符描述符&#34;&gt;信号选择器对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;信号选择器对象是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，信号选择器对象也用 &lt;strong&gt;信号选择器对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../../api/structxwos__sel__d.html&#34;&gt;&lt;code&gt;xwos_sel_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;信号选择器对象描述符由 &lt;strong&gt;信号选择器对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sel &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sel; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 信号选择器对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_sel_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;同步对象的绑定与解绑&#34;&gt;同步对象的绑定与解绑&lt;/h2&gt;
&lt;p&gt;XWOS中所有 &lt;strong&gt;同步对象&lt;/strong&gt; 都带有两个相似的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绑定
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4a04b2c6003ed59a0f82c7b8ed8c7f68&#34;&gt;&lt;code&gt;xwos_sem_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_cond_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga534a3b72742f053a82aa431765bdf63b&#34;&gt;&lt;code&gt;xwos_flg_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gae2675cc244078d9ba58e9d8ae24faa4b&#34;&gt;&lt;code&gt;xwos_br_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga55059a1edf93b0554bf89112a884acb3&#34;&gt;&lt;code&gt;xwos_sel_bind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解绑
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sem.html#ga4aab3913939aa6cfa040af1039e564d5&#34;&gt;&lt;code&gt;xwos_sem_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_cond_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga7f2340c7a08c61f3ae440b66675543aa&#34;&gt;&lt;code&gt;xwos_flg_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__br.html#gafaf7f192db151d1f3759a2dc8f5e7157&#34;&gt;&lt;code&gt;xwos_br_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga5adbc4dcb319feccd63056cbf3d76e0c&#34;&gt;&lt;code&gt;xwos_sel_unbind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同步对象&lt;/strong&gt; 绑定操作又分为 &lt;strong&gt;独占绑定&lt;/strong&gt; 与 &lt;strong&gt;非独占绑定&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占绑定：是指 &lt;strong&gt;同步对象&lt;/strong&gt; 一旦绑定了信号选择器位图中的某一位后，其他 &lt;strong&gt;同步对象&lt;/strong&gt; 不可再绑定此位，发送的 &lt;strong&gt;选择信号&lt;/strong&gt; 也被称为 &lt;strong&gt;独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;非独占绑定：是指 &lt;strong&gt;同步对象&lt;/strong&gt; 一旦绑定了信号选择器位图中的某一位后，其他 &lt;strong&gt;同步对象&lt;/strong&gt; 还可继续再绑定此位，发送的 &lt;strong&gt;选择信号&lt;/strong&gt; 也被称为 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同步对象&lt;/strong&gt; 采用的绑定方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量：独占绑定&lt;/li&gt;
&lt;li&gt;条件量：非独占绑定&lt;/li&gt;
&lt;li&gt;事件标志：非独占绑定&lt;/li&gt;
&lt;li&gt;线程栅栏：非独占绑定&lt;/li&gt;
&lt;li&gt;信号选择器：非独占绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;选择信号&#34;&gt;选择信号&lt;/h2&gt;
&lt;h3 id=&#34;选择信号的设置&#34;&gt;选择信号的设置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选择信号&lt;/strong&gt; 的设置，对于不同的 &lt;strong&gt;同步对象&lt;/strong&gt; 有不同解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量
&lt;ul&gt;
&lt;li&gt;计数器的值大于 &lt;strong&gt;0&lt;/strong&gt; 时就会被设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;条件量
&lt;ul&gt;
&lt;li&gt;广播操作： &lt;a href=&#34;../../../../capi/group__xwos__sync__cond.html#ga6a85c4b4f0a48d8f7af6d1eb9edf5828&#34;&gt;&lt;code&gt;xwos_cond_broadcast()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件标志
&lt;ul&gt;
&lt;li&gt;事件标志位图中任何一位发生改变的操作：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga4bbbb700f8945d8a477ecdf8f48e1be3&#34;&gt;&lt;code&gt;xwos_flg_s1m()&lt;/code&gt;&lt;/a&gt; ：同时设置多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gaa512cf8063cc538dbb431dbc680b1d78&#34;&gt;&lt;code&gt;xwos_flg_s1i()&lt;/code&gt;&lt;/a&gt; ：设置单个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#gad9d0bd13e3b0c853597b982d348fd6dd&#34;&gt;&lt;code&gt;xwos_flg_c0m()&lt;/code&gt;&lt;/a&gt; ：同时清除多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga48c1627edd80a59ad4f88c3a91fb8bf0&#34;&gt;&lt;code&gt;xwos_flg_c0i()&lt;/code&gt;&lt;/a&gt; ：清除单个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga422b4ec657c8baf31cf35a141ae0bff1&#34;&gt;&lt;code&gt;xwos_flg_x1m()&lt;/code&gt;&lt;/a&gt; ：同时翻转多个事件标志位&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__flg.html#ga42d2e3e4536d53490ba1590aefdcaac2&#34;&gt;&lt;code&gt;xwos_flg_x1i()&lt;/code&gt;&lt;/a&gt; ：翻转单个事件标志位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程栅栏
&lt;ul&gt;
&lt;li&gt;所有线程抵达栅栏处，并同时被唤醒；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号选择器
&lt;ul&gt;
&lt;li&gt;信号选择器本身也是 &lt;strong&gt;同步对象&lt;/strong&gt; ，也可绑定在另一个信号选择器上。当源信号选择器收到了 &lt;strong&gt;选择信号&lt;/strong&gt; ，会将其传递到绑定的另一个目的信号选择器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 810px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Sync/Sel/xwos-sel_hudcf9cb7156ebc4dfb2218a5a4fe7da02_94248_800x600_fill_catmullrom_smart1_3.png&#34; width=&#34;800&#34; height=&#34;600&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS信号选择器示意图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;选择信号的清除&#34;&gt;选择信号的清除&lt;/h3&gt;
&lt;h4 id=&#34;独占-方式的-选择信号&#34;&gt;&lt;strong&gt;独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;信号量：当信号量中的计数器的值小于等于 &lt;strong&gt;0&lt;/strong&gt; 时， &lt;strong&gt;选择信号&lt;/strong&gt; 才会被清除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;非独占-方式的-选择信号&#34;&gt;&lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;非独占&lt;/strong&gt; 方式绑定的 &lt;strong&gt;同步对象&lt;/strong&gt; 向信号选择器发送 &lt;strong&gt;选择信号&lt;/strong&gt; 后，其位图中的位置会被置 &lt;strong&gt;1&lt;/strong&gt; 。
同时会唤醒所有等待的线程，此时线程们会竞争进入信号选择器的临界区。&lt;/p&gt;
&lt;p&gt;最先进入的线程会读取信号选择器的 &lt;strong&gt;选择信号&lt;/strong&gt; 位图，并与调用函数时传递的 &lt;strong&gt;掩码&lt;/strong&gt; 进行比较，判断是否有 &lt;strong&gt;掩码&lt;/strong&gt; 中的 &lt;strong&gt;选择信号&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有，会清除信号选择器位图中 &lt;strong&gt;所有&lt;/strong&gt; 的 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ，包括 &lt;strong&gt;掩码&lt;/strong&gt; 中没有设置的 &lt;strong&gt;选择信号&lt;/strong&gt; 。
因此后续线程将无法再检测到任何 &lt;strong&gt;非独占&lt;/strong&gt; 方式的 &lt;strong&gt;选择信号&lt;/strong&gt; ，会重新阻塞等待。
XWOS不推荐在信号选择器上，多于一个线程等待。&lt;/li&gt;
&lt;li&gt;如果没有，线程会重新阻塞等待，然后下一个线程进入临界区检测。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;信号选择器的初始化销毁与动态创建删除&#34;&gt;信号选择器的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gaae37e3a4348e0dbee6118df0a0e91b64&#34;&gt;&lt;code&gt;xwos_sel_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的信号选择器： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga3a847008f0f8c6ced37e20de38ab8a1b&#34;&gt;&lt;code&gt;xwos_sel_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga42a5404828d0a9185276be474f9b9e46&#34;&gt;&lt;code&gt;xwos_sel_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的信号选择器： &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga6c9034f4c09265ed282c8039e665f23d&#34;&gt;&lt;code&gt;xwos_sel_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待选择信号&#34;&gt;等待选择信号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gac2107de7d97466c5f6fde732b86fe0c0&#34;&gt;&lt;code&gt;xwos_sel_select()&lt;/code&gt;&lt;/a&gt; ：等待信号选择器中的 &lt;strong&gt;选择信号&lt;/strong&gt; ，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga070fb02f1220d6257b1e98a54990e2f7&#34;&gt;&lt;code&gt;xwos_sel_select_to()&lt;/code&gt;&lt;/a&gt; ：限时等待信号选择器中的 &lt;strong&gt;选择信号&lt;/strong&gt; ，只能在 &lt;strong&gt;线程&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga9c635b47293e77b2d1012d6e66b3053d&#34;&gt;&lt;code&gt;xwos_sel_tryselect()&lt;/code&gt;&lt;/a&gt; ：检测信号选择器中是否有 &lt;strong&gt;选择信号&lt;/strong&gt; ，可在 &lt;strong&gt;任意&lt;/strong&gt; 上下文使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绑定与解绑其他信号选择器&#34;&gt;绑定与解绑其他信号选择器&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga55059a1edf93b0554bf89112a884acb3&#34;&gt;&lt;code&gt;xwos_sel_bind()&lt;/code&gt;&lt;/a&gt; 将信号选择器绑定到另一个 &lt;strong&gt;信号选择器&lt;/strong&gt; 上，形成传递链。
但信号选择器不可相互绑定形成循环链，否则会造成无限传递。&lt;/p&gt;
&lt;p&gt;绑定后的信号选择器可以通过 &lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga5adbc4dcb319feccd63056cbf3d76e0c&#34;&gt;&lt;code&gt;xwos_sel_unbind()&lt;/code&gt;&lt;/a&gt; 解绑。&lt;/p&gt;
&lt;h2 id=&#34;信号选择器对象的生命周期管理&#34;&gt;信号选择器对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;信号选择器对象的基类是 &lt;a href=&#34;../../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
信号选择器对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga3b26f1ae6f050c2251b81ad992b7edc3&#34;&gt;&lt;code&gt;xwos_sel_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#gad4f2be2d1f0e894957b2491b540c44d2&#34;&gt;&lt;code&gt;xwos_sel_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga73d231bc26cb34ce5cda1d39c33f6dfc&#34;&gt;&lt;code&gt;xwos_sel_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html#ga8bb0a86f605e1dd71cfcd7b18afb0c4c&#34;&gt;&lt;code&gt;xwos_sel_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../../capi/group__xwos__sync__sel.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/sync/sel.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 启动流程</title>
      <link>/docs/TechRefManual/BootFlow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/BootFlow/</guid>
      <description>
        
        
        &lt;h2 id=&#34;xwos的启动流程&#34;&gt;XWOS的启动流程&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart LR
    预初始化阶段 --&amp;gt; 初始化阶段 --&amp;gt; 后初始化阶段 --&amp;gt; 主函数阶段

    subgraph 预初始化阶段
        direction TB
        exc[&amp;#34;异常初始化&amp;#34;]
        exc[&amp;#34;浮点单元初始化&amp;#34;]
        exc[&amp;#34;内存初始化&amp;#34;]
    end

    subgraph 初始化阶段
        xwos_init[&amp;#34;xwos_init()&amp;#34;]
    end

    subgraph 后初始化阶段
        direction LR
        device[&amp;#34;设备驱动初始化&amp;#34;]
        mm[&amp;#34;动态内存分配器的初始化&amp;#34;]
    end

    subgraph 主函数阶段
        direction LR
        skd_init[&amp;#34;初始化调度器: xwos_skd_init_lc()&amp;#34;]
        thd[&amp;#34;建立线程&amp;#34;]
        skd_start[&amp;#34;启动调度器: xwos_skd_start_lc()&amp;#34;]
    end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XWOS将初始化流程分为四个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预初始化阶段（用户定义）：&lt;code&gt;xwos_preinit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化阶段（XWOS定义）：&lt;code&gt;xwos_init()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后初始化阶段（用户定义）：&lt;code&gt;xwos_postinit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主函数阶段（用户定义）：&lt;code&gt;xwos_main()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;预初始化阶段&#34;&gt;预初始化阶段&lt;/h3&gt;
&lt;p&gt;预初始化阶段，用户需要提供函数的定义： &lt;code&gt;void xwos_preinit(void)&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要完成CPU架构低级初始化，例如：中断的初始化，浮点运算单元的初始化等；&lt;/li&gt;
&lt;li&gt;需要完成对内存的初始化，以及数据区的重定向工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化阶段&#34;&gt;初始化阶段&lt;/h3&gt;
&lt;p&gt;初始化阶段的函数 &lt;code&gt;void xwos_init(void)&lt;/code&gt; 由XWOS定义，对XWOS内核进行初始化。用户不可重新定义此函数。
&lt;code&gt;xwos_init()&lt;/code&gt; 会访问全局变量，因此必须保证在 &lt;strong&gt;预初始化阶段&lt;/strong&gt; 完成对内存的初始化以及数据区的重定向工作。
在多核系统中， &lt;code&gt;xwos_init()&lt;/code&gt; 在每个CPU的初始化流程中都会被调用一次。&lt;/p&gt;
&lt;h3 id=&#34;后初始化阶段&#34;&gt;后初始化阶段&lt;/h3&gt;
&lt;p&gt;后初始化阶段，用户需要提供函数的定义： &lt;code&gt;void xwos_postinit(void)&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可选择在此阶段完成驱动的初始化；&lt;/li&gt;
&lt;li&gt;用户可选择在此阶段完成动态内存分配器的初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主函数阶段&#34;&gt;主函数阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户可选择在此阶段完成驱动的初始化；&lt;/li&gt;
&lt;li&gt;用户可选择在此阶段完成动态内存分配器的初始化；&lt;/li&gt;
&lt;li&gt;用户需要在此阶段建立线程；&lt;/li&gt;
&lt;li&gt;用户需要在此阶段调用 &lt;code&gt;xwos_skd_start_lc()&lt;/code&gt; 启动调度器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户自定义的启动流程&#34;&gt;用户自定义的启动流程&lt;/h2&gt;
&lt;p&gt;如果用户使用自定义的启动流程，需要在调用XWOS任何API之前调用 &lt;code&gt;xwos_init()&lt;/code&gt; 。
此函数会访问全局变量，需要在数据区重定向工作完成之后才可被调用。&lt;/p&gt;
&lt;p&gt;在多核系统中， &lt;code&gt;xwos_init()&lt;/code&gt; 需要在每个CPU的初始化流程中被调用一次。&lt;/p&gt;
&lt;h3 id=&#34;自定义的启动流程举例&#34;&gt;自定义的启动流程举例&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: XWOS对象</title>
      <link>/docs/TechRefManual/Xwobj/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwobj/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS的内核对象全部继承于 &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_object {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; magic;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;atomic_xwsq_t&lt;/span&gt; refcnt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        xwobj_gc_f gcfunc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tik&lt;/code&gt; ：对象的标签，是由系统分配的独一无二的整数。此标签即为对象的 &lt;strong&gt;身份证ID&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magic&lt;/code&gt; ：常数 &lt;code&gt;0x58574F53U&lt;/code&gt; ，用于确定内存地址是否为 &lt;strong&gt;XWOS的对象&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refcnt&lt;/code&gt; ：XWOS的对象使用引用计数法管理生命周期，当对象的引用计数减为 &lt;code&gt;0&lt;/code&gt; ，会调用 &lt;code&gt;gcfunc()&lt;/code&gt; 进行垃圾回收；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcfunc&lt;/code&gt; ：垃圾回收函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照面向对象的思想， &lt;code&gt;struct xwos_object&lt;/code&gt; 应当作为子类对象结构体的第一个成员。 &lt;code&gt;struct xwos_object *&lt;/code&gt; 就可强制类型转换为子类对象的指针。&lt;/p&gt;
&lt;h2 id=&#34;对象描述符&#34;&gt;对象描述符&lt;/h2&gt;
&lt;p&gt;当使用对象指针访问对象时，有可能会出现一种情况：
对象已经被释放，甚至被释放后的内存又被用来构建新的对象。但是对象指针的持有者并不知道这种情况。由此引发各种指针问题。
为了解决这类问题，XWOS引入 &lt;strong&gt;对象描述符&lt;/strong&gt; 。&lt;strong&gt;对象描述符&lt;/strong&gt; 由 &lt;strong&gt;对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_object &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; obj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwobj_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;code&gt;0&lt;/code&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;p&gt;相应的，当 &lt;code&gt;struct xwos_object&lt;/code&gt; 被子类继承后，子类也应该有对应的 &lt;strong&gt;对象描述符&lt;/strong&gt; 。
例如，线程对象的 &lt;strong&gt;线程对象描述符&lt;/strong&gt; 、互斥锁对象的 &lt;strong&gt;互斥锁对象描述符&lt;/strong&gt; 等。&lt;/p&gt;
&lt;h2 id=&#34;对象的生命周期&#34;&gt;对象的生命周期&lt;/h2&gt;
&lt;p&gt;XWOS的对象使用引用计数法管理生命周期，XWOS对象的生命周期分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造阶段&lt;/strong&gt; ：对象通过 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga908c48f09f38f5be9d69758fe30c5d3f&#34;&gt;&lt;code&gt;xwos_object_construct()&lt;/code&gt;&lt;/a&gt; 构造后进入 &lt;strong&gt;构造阶段&lt;/strong&gt; ，
此时对象的引用计数为 &lt;strong&gt;0&lt;/strong&gt; 。如果存在派生与继承，需要按照从 &lt;strong&gt;基类到子类&lt;/strong&gt; 的顺序依次调用构造函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用阶段&lt;/strong&gt; ：处于构造阶段的对象，通过 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga82ce393acdabdb355bf091c21f784444&#34;&gt;&lt;code&gt;xwos_object_activate()&lt;/code&gt;&lt;/a&gt; 激活后进入 &lt;strong&gt;应用阶段&lt;/strong&gt; 。
如果存在派生与继承，需要按照从 &lt;strong&gt;基类到子类&lt;/strong&gt; 的顺序依次调用激活函数。
此阶段对象的引用计数 &lt;strong&gt;&amp;gt;= 1&lt;/strong&gt; ，对象可以开始被使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放阶段&lt;/strong&gt; ：当对象引用计数从 &lt;strong&gt;&amp;gt;= 1&lt;/strong&gt; 减少为 &lt;strong&gt;0&lt;/strong&gt; ，对象进入 &lt;strong&gt;释放阶段&lt;/strong&gt; ，此阶段会调用对象的 &lt;code&gt;gcfunc()&lt;/code&gt; 释放对象。
用户需要提供 &lt;code&gt;gcfunc()&lt;/code&gt; 的定义， &lt;code&gt;gcfunc()&lt;/code&gt; 内还需要调用对象的析构函数 &lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gaaaa2a74387092ee01a9e495a2994d1fa&#34;&gt;&lt;code&gt;xwos_object_destruct()&lt;/code&gt;&lt;/a&gt;
如果存在派生与继承，需要按照从 &lt;strong&gt;子类到基类&lt;/strong&gt; 的顺序依次调用析构函数。
至此对象生命周期结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象的生命周期管理&#34;&gt;对象的生命周期管理&lt;/h3&gt;
&lt;p&gt;XWOS提供两组对象的生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga78e0a4c3320e9e2348d4443294147458&#34;&gt;&lt;code&gt;xwos_object_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gad75451193241a605aef8b9fc6f934dcb&#34;&gt;&lt;code&gt;xwos_object_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#ga33f685c358784c30a9f1fb8a5ca11d3d&#34;&gt;&lt;code&gt;xwos_object_rawput()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，引用计数为 &lt;strong&gt;0&lt;/strong&gt; 时不调用垃圾回收函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gac510a6eb1b6a08450ec6d65fe3bf7694&#34;&gt;&lt;code&gt;xwos_object_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html#gac2826d86066a8dfdcc77fe7a8c53edfc&#34;&gt;&lt;code&gt;xwos_object_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;局限性&#34;&gt;局限性&lt;/h2&gt;
&lt;p&gt;频繁地管理对象的生命周期会影响CPU的运行效率，因为引用计数的操作是原子操作，原子操作会影响CPU的性能，
CPU性能越强，影响越巨大。因此，除了必要的情况，XWOS内核各种对象的CAPI被设计为直接使用 &lt;strong&gt;对象的指针&lt;/strong&gt; 作为参数，并且不会自动管理对象的生命周期。
对象的有效性，身份的合法性，生命周期需要由用户手动管理。&lt;/p&gt;
&lt;p&gt;通常，在简单的MCU RTOS应用，这些对象都是只创建不释放的，也没有必要关心生命周期。
事实上，对象的生命周期的CAPI主要是给高级语言设计的，例如 &lt;strong&gt;Lua&lt;/strong&gt; 虚拟机用来实现对象生命周期的自动管理。&lt;/p&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__lib__xwobj.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/lib/object.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 中断管理</title>
      <link>/docs/TechRefManual/Irq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Irq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;异常与中断&#34;&gt;异常与中断&lt;/h2&gt;
&lt;p&gt;XWOS将中断分为EXC和IRQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EXC是指架构中定义的中断，在某些架构中被称为 &lt;strong&gt;异常(Exception)&lt;/strong&gt; ，中断号用负数表示；&lt;/li&gt;
&lt;li&gt;IRQ是指外设中断，例如UART的中断等，中断号用 &lt;strong&gt;0&lt;/strong&gt; 和 &lt;strong&gt;正数&lt;/strong&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内核中断&#34;&gt;内核中断&lt;/h2&gt;
&lt;p&gt;XWOS内核的中断包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切换上下文的中断：用于切换线程；&lt;/li&gt;
&lt;li&gt;滴答定时器的中断：用于提供周期性定时中断；&lt;/li&gt;
&lt;li&gt;调度器服务中断：用于启动调度、退出线程、冻结线程、电源管理等其他操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中断优先级&#34;&gt;中断优先级&lt;/h2&gt;
&lt;p&gt;XWOS对中断优先级的要求：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;切换上下文的中断为系统中最低优先级中断
切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;cpu中断开关&#34;&gt;CPU中断开关&lt;/h2&gt;
&lt;p&gt;CPU只能操作自身的中断开关，不可操作其他CPU的中断。下面的函数运行在哪个CPU，就对哪个CPU起作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga4e777c174af9414602e004935f9ce44c&#34;&gt;&lt;code&gt;xwos_cpuirq_enable_lc()&lt;/code&gt;&lt;/a&gt; ：开启CPU的中断开关&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gaa4e10b3911a94474d3caf07e2002c9f3&#34;&gt;&lt;code&gt;xwos_cpuirq_disable_lc()&lt;/code&gt;&lt;/a&gt; ：关闭CPU的中断开关&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga6786862246388dace5c878fa112fac4d&#34;&gt;&lt;code&gt;xwos_cpuirq_save_lc()&lt;/code&gt;&lt;/a&gt; ：保存当前CPU的中断开关状态后关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gab348bfecc115e0d9bb7fc54646f26ebd&#34;&gt;&lt;code&gt;xwos_cpuirq_restore_lc()&lt;/code&gt;&lt;/a&gt; ：恢复之前保存的CPU的中断开关状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要在操作系统移植实现层(XWOSIMPL)中给出上述函数的具体实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_enable_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_enable_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_disable_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_disable_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_save_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_save_lc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_restore_lc()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_cpuirq_restore_lc()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用局限&#34;&gt;使用局限&lt;/h3&gt;
&lt;p&gt;关闭与开启CPU总中断开关需要确保不会发生嵌套，例如下面的嵌套代码是 &lt;strong&gt;错误&lt;/strong&gt; 的，因为 &lt;strong&gt;临界区1&lt;/strong&gt; 结束时会意外地将CPU中断打开，
从而无法保证 &lt;strong&gt;临界区0&lt;/strong&gt; 的安全性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_disable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区1 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_enable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_disable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 错误！！！发生嵌套 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 此处CPU中断被意外打开 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_enable_lc&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当关闭中断的代码发生嵌套时，需要保存与恢复CPU总中断开关，上面的例子可以更正为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwreg_t&lt;/span&gt; cpuirq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_save_lc&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区1 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_restore_lc&lt;/span&gt;(cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwreg_t&lt;/span&gt; cpuirq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_save_lc&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区0 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cpuirq_restore_lc&lt;/span&gt;(cpuirq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;外设中断&#34;&gt;外设中断&lt;/h2&gt;
&lt;h3 id=&#34;获取当前代码的中断号&#34;&gt;获取当前代码的中断号&lt;/h3&gt;
&lt;p&gt;XWOS提供CAPI &lt;a href=&#34;../../../capi/group__xwos__irq.html#ga5b3edca9786bee32463bb95c2bcb27ee&#34;&gt;&lt;code&gt;xwos_irq_get_id()&lt;/code&gt;&lt;/a&gt; 可以获取当前中断的中断号。
如果不在中断内使用此CAPI，将返回错误码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-ENOTISRCTX&lt;/code&gt; ：当前上下文不为中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，此CAPI还可用于判断是否为 &lt;strong&gt;中断上下文&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_get_id()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_get_id()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外设中断的其他capi&#34;&gt;外设中断的其他CAPI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#gac8e3525698cdb1785a323248d4dca617&#34;&gt;&lt;code&gt;xwos_irq_enable()&lt;/code&gt;&lt;/a&gt; ：开启某个外设中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga09330a9bee1901dbd57994b4fc48a822&#34;&gt;&lt;code&gt;xwos_irq_disable()&lt;/code&gt;&lt;/a&gt; ：关闭某个外设中断&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga882084561afe57f26871d6881b4a999e&#34;&gt;&lt;code&gt;xwos_irq_save()&lt;/code&gt;&lt;/a&gt; ：保存某个外设中断的开关，然后将其关闭&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html#ga8e390ff7129fb539b2d784e1d19ec3b9&#34;&gt;&lt;code&gt;xwos_irq_restore()&lt;/code&gt;&lt;/a&gt; ：恢复某个外设中断的开关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件： &lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_enable()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_enable()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_disable()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_disable()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_save()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_save()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_restore()&lt;/code&gt; ：对应于 &lt;code&gt;xwos_irq_restore()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__irq.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/irq.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 调度器</title>
      <link>/docs/TechRefManual/Skd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Skd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS调度器最基本的调度单位是 &lt;strong&gt;线程&lt;/strong&gt; ，暂时不支持 &lt;strong&gt;MMU虚拟内存&lt;/strong&gt; 与 &lt;strong&gt;进程&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;线程&lt;/strong&gt; 都有自己独立的 &lt;strong&gt;栈&lt;/strong&gt; 内存，但所有内存对所有线程都可见，除非使用MPU增加限制；&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;线程&lt;/strong&gt; 都有调度优先级；&lt;/li&gt;
&lt;li&gt;调度器可以冻结线程，支持电源管理；&lt;/li&gt;
&lt;li&gt;每个CPU都有自己独立的调度器，线程只能在自身CPU的调度器中调度，如果需要在CPU间移动，需要进行 &lt;strong&gt;迁移&lt;/strong&gt; 操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;
&lt;p&gt;XWOS的优先级，用类型 &lt;code&gt;xwpr_t&lt;/code&gt; 表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值越 &lt;strong&gt;小&lt;/strong&gt; ，优先级越 &lt;strong&gt;低&lt;/strong&gt; ，优先级的值越 &lt;strong&gt;大&lt;/strong&gt; ，优先级越 &lt;strong&gt;高&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;为了保证今后的扩展性，应该使用宏，而不要直接使用 &lt;code&gt;xwpr_t&lt;/code&gt; 的数值：
&lt;ul&gt;
&lt;li&gt;最小优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga440d65baefaf78c6d4d2ac4a817470bd&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_MIN&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;最大优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#gab96ee2b3dd640e72ea2da7aa40f7e1c0&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_MAX&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;无效优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga18540129b73106a735c623179b54e37e&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RT_INVALID&lt;/code&gt;&lt;/a&gt; 获取 。&lt;/li&gt;
&lt;li&gt;其他优先级应该使用最大优先级和最小优先级进行计算获取：
&lt;ul&gt;
&lt;li&gt;降低优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga80d502888629efa9bef83dddf93d2d2f&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_DROP&lt;/code&gt;&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;提高优先级可以通过宏 &lt;a href=&#34;../../../capi/group__xwos__skd.html#gaa931e264469c6a30fb720b85d60b8295&#34;&gt;&lt;code&gt;XWOS_SKD_PRIORITY_RAISE&lt;/code&gt;&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度算法&#34;&gt;调度算法&lt;/h2&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个优先级都有一个先进先出(FIFO)的 &lt;strong&gt;就绪&lt;/strong&gt; 队列；&lt;/li&gt;
&lt;li&gt;使用一个位图标记每个优先级队列是否为空；非空的队列对应的位被置1，否则被清0。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Skd/ready-queue_hu9b60b1c85faa2d0c7a8cad73f43546b4_90524_680x680_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;680&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS调度器就绪队列
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;调度流程&#34;&gt;调度流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义操作&lt;strong&gt;fls&lt;/strong&gt;：从最高位起查找第一个被置1的位，并返回其序号，
如果所有位都为0，返回-1。此操作需要CPU的相关指令来实现，例如ARM的clz，
DEC Alpha的ctlz，x86的lzcnt，PowerPC的cntlz等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流程图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TB
    start --&amp;gt; fls
    fls --&amp;gt; idx
    idx --否--&amp;gt; idle
    idx --是--&amp;gt; q
    q --&amp;gt; t
    t --&amp;gt; skd
    skd --&amp;gt; e
    idle --&amp;gt; e

    start(&amp;#34;开始&amp;#34;)
    fls[&amp;#34;idx = fls(bitmap)&amp;#34;]
    idx{&amp;#34;idx &amp;gt;= 0 ?&amp;#34;}
    idle[&amp;#34;调度空闲任务&amp;#34;]
    q[&amp;#34;选择优先级为idx的就绪队列&amp;#34;]
    t[&amp;#34;从就绪队列头部选择第一个线程&amp;#34;]
    skd[&amp;#34;调度选择的线程&amp;#34;]
    e(&amp;#34;结束&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;启动调度器&#34;&gt;启动调度器&lt;/h2&gt;
&lt;p&gt;当 &lt;a href=&#34;BootFlow&#34;&gt;启动流程&lt;/a&gt; 进入 &lt;code&gt;xwos_main()&lt;/code&gt; 后，可调用 &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga41a4beaa63dc64bef8a346afbdbd6bee&#34;&gt;&lt;code&gt;xwos_skd_start_lc()&lt;/code&gt;&lt;/a&gt; 启动调度器，此时上下文(Context)将由 &lt;strong&gt;启动&lt;/strong&gt; 切换为 &lt;strong&gt;线程&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;抢占&#34;&gt;抢占&lt;/h2&gt;
&lt;p&gt;调度器始终选择优先级最高的线程，高优先级的线程可以抢占低优先级的线程。&lt;/p&gt;
&lt;p&gt;相同的优先级的线程，调度器按照 &lt;strong&gt;先进先出&lt;/strong&gt; 的方法调度，同优先级线程之间 &lt;strong&gt;不能&lt;/strong&gt; 相互抢占。&lt;/p&gt;
&lt;p&gt;用户可以关闭抢占： &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga50fdb4d22f93b80c109b628b5f7690d7&#34;&gt;&lt;code&gt;xwos_skd_dspmpt_lc()&lt;/code&gt;&lt;/a&gt; ，
也可以打开抢占： &lt;a href=&#34;../../../capi/group__xwos__skd.html#ga4006c65a55cf7b4897cbcaef2a74c10e&#34;&gt;&lt;code&gt;xwos_skd_enpmpt_lc()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;调度器中的特殊任务&#34;&gt;调度器中的特殊任务&lt;/h2&gt;
&lt;h3 id=&#34;空闲任务&#34;&gt;空闲任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器中没有任何线程&lt;strong&gt;就绪&lt;/strong&gt;，调度器会调度空闲任务；&lt;/li&gt;
&lt;li&gt;空闲任务比较特殊，属于 &lt;strong&gt;最低优先级&lt;/strong&gt; 的线程上下文，但不能使用任何会导致睡眠与阻塞的函数。&lt;/li&gt;
&lt;li&gt;用户可在空闲任务中HOOK用户代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;xwbd/电路板/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;board_xwskd_idle_hook()&lt;/code&gt; 并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断底半部任务&#34;&gt;中断底半部任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器配置 &lt;code&gt;XWOSCFG_SD_BH&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 时，
调度器会为系统预留一个 &lt;strong&gt;最高优先级&lt;/strong&gt; 线程；&lt;/li&gt;
&lt;li&gt;中断底半部任务比较特殊，属于线程上下文，但不能使用任何会导致睡眠、阻塞的函数；&lt;/li&gt;
&lt;li&gt;中断底半部任务可抢占任何线程；&lt;/li&gt;
&lt;li&gt;当开启中断底半部时，调度器的滴答定时器任务运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;XWOS的中断底半部并未完全开发完成，目前只开放给滴答定时器任务使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户可以关闭中断底半部： &lt;a href=&#34;../../../capi/group__xwos__skd.html#gaf0f7900e90d47f8e5e3866ad8fe4be06&#34;&gt;&lt;code&gt;xwos_skd_dsbh_lc()&lt;/code&gt;&lt;/a&gt; ，
也可以打开中断底半部： &lt;a href=&#34;../../../capi/group__xwos__skd.html#gae8f42d03c7733220185c152e36a558fb&#34;&gt;&lt;code&gt;xwos_skd_enbh_lc()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;滴答定时器任务&#34;&gt;滴答定时器任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统内核通常都会包含一个定时器，用于产生固定周期的 &lt;strong&gt;滴答&lt;/strong&gt; （或称为 &lt;strong&gt;节拍&lt;/strong&gt; ）中断；&lt;/li&gt;
&lt;li&gt;滴答定时器任务也即是在此定时器中断中执行的周期性任务；&lt;/li&gt;
&lt;li&gt;如果 &lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt; 配置为 &lt;code&gt;1&lt;/code&gt; ，滴答定时器任务运行在中断底半部任务内部；&lt;/li&gt;
&lt;li&gt;如果 &lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt; 配置为 &lt;code&gt;0&lt;/code&gt; ，滴答定时器任务运行在中断上下文中；&lt;/li&gt;
&lt;li&gt;用户可以在滴答定时器任务中HOOK自己的代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;board_xwskd_syshwt_hook()&lt;/code&gt; 并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器的中断&#34;&gt;调度器的中断&lt;/h2&gt;
&lt;h3 id=&#34;切换上下文的中断&#34;&gt;切换上下文的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度器用于切换正在执行的线程的中断&lt;/li&gt;
&lt;li&gt;中断优先级： &lt;strong&gt;最低&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户可在切换上下文时，Hook自己的代码：
&lt;ul&gt;
&lt;li&gt;在切换上下文开始之前：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_PRE_SWCX_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义Hook函数 &lt;code&gt;board_thd_preinit_hook()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在切换上下文开始之后：
&lt;ul&gt;
&lt;li&gt;在配置文件 &lt;code&gt;电路板目录/cfg/board.h&lt;/code&gt; 中定义配置 &lt;code&gt;BRDCFG_XWSKD_POST_SWCX_HOOK&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;定义Hook函数 &lt;code&gt;board_thd_postinit_hook()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滴答定时器的中断&#34;&gt;滴答定时器的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于产生固定周期的 &lt;strong&gt;滴答&lt;/strong&gt; （或称为 &lt;strong&gt;节拍&lt;/strong&gt; ）的定时器中断，&lt;a href=&#34;#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;由此中断触发执行。&lt;/li&gt;
&lt;li&gt;中断优先级： &lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度器服务中断&#34;&gt;调度器服务中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于执行调度器特殊操作的软中断，包括：
&lt;ul&gt;
&lt;li&gt;调度器休眠 &lt;code&gt;xwosplcb_skd_suspend_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程退出 &lt;code&gt;xwosplcb_thd_exit_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程冻结 &lt;code&gt;xwosplcb_thd_freeze_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程迁移 &lt;code&gt;xwosplcb_thd_immigrate_lic()&lt;/code&gt; 和 &lt;code&gt;xwosplcb_thd_outmigrate_lic()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断优先级：&lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt;= 调度器服务中断&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;硬件定时器&#34;&gt;硬件定时器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS内核要求每个CPU都有一个私有的滴答定时器，产生固定频率的中断；&lt;/li&gt;
&lt;li&gt;通常配置为 &lt;strong&gt;1000HZ&lt;/strong&gt; ，可参考配置文件 &lt;code&gt;xwbd/电路板/cfg/xwos.h&lt;/code&gt; 中的配置 &lt;code&gt;XWOSCFG_SYSHWT_PERIOD&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;XWOS的滴答定时器会产生三个变量：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 滴答计数
&lt;ul&gt;
&lt;li&gt;在每次滴答定时器中断时，&lt;code&gt;tickcount&lt;/code&gt; 都会自增1；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 可以表示滴答定时器中断了多少次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;tickcount&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#ga0e2076d41b83f77080d40bb5cb9c7210&#34;&gt;&lt;code&gt;xwtm_nowtc()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;tickcount&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 系统时间
&lt;ul&gt;
&lt;li&gt;XWOS内核使用 &lt;strong&gt;纳秒(ns)&lt;/strong&gt; 作为时间的基本单位，假设滴答器频率 &lt;strong&gt;1000HZ&lt;/strong&gt; ， &lt;code&gt;tickcount&lt;/code&gt; 每1ms增加一次，即每1ms增加 &lt;code&gt;1000000&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 与 &lt;code&gt;tickcount&lt;/code&gt; 的关系： &lt;code&gt;timetick = tickcount * 1000000&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;timetick&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#gad144b9695441072c91d83aabc54ab5c4&#34;&gt;&lt;code&gt;xwtm_now()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;timetick&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 系统时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是以纳秒为单位的系统时间戳；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是通过把滴答定时器到下一次中断还剩多少时间计算出来，再累加到 &lt;code&gt;timetick&lt;/code&gt; 上获取的，其精度由SOC的主频与计数器的位宽决定；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 &lt;code&gt;timestamp&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;通过CAPI &lt;a href=&#34;../../../capi/group__xwos__time.html#gabdeea033c32e82ed1d6e5abcdf8d1aee&#34;&gt;&lt;code&gt;xwtm_nowts()&lt;/code&gt;&lt;/a&gt; 可以获取当前CPU的 &lt;code&gt;timestamp&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;超时管理&#34;&gt;超时管理&lt;/h2&gt;
&lt;h3 id=&#34;时间树&#34;&gt;时间树&lt;/h3&gt;
&lt;p&gt;XWOS内核中，每个需要超时管理的对象（线程、软件定时器）都是以 &lt;strong&gt;时间树节点&lt;/strong&gt; 组织到时间树中。
&lt;strong&gt;时间树节点&lt;/strong&gt; 中包含了超时的 &lt;strong&gt;系统时间点&lt;/strong&gt; ，调度器每次进入滴答定时器任务时，都会检测时间树中是否有节点超时。
在时间树中，所有节点的 &lt;strong&gt;系统时间点&lt;/strong&gt; 都是未来的时间。最先超时的节点一定是 &lt;strong&gt;系统时间点&lt;/strong&gt; 最小的节点。
因此时间树的超时问题就是寻找最小值的问题。XWOS使用红黑树解决此最小值的问题，因此算法被称为 &lt;strong&gt;时间树&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个 &lt;strong&gt;leftmost&lt;/strong&gt; 指针指向最小值，超时可直接从 &lt;strong&gt;leftmost&lt;/strong&gt; 快速获取最小值，时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;超时后， &lt;strong&gt;leftmost&lt;/strong&gt; 从红黑树中被删除，按照二叉树的性质，下一任 &lt;strong&gt;leftmost&lt;/strong&gt; 是前任的右孩子（即后继）。
如果前任的后继为叶子，下一任 &lt;strong&gt;leftmost&lt;/strong&gt; 一定是前任的父节点，算法时间复杂度为 &lt;strong&gt;O(1)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;删除 &lt;strong&gt;leftmost&lt;/strong&gt; 在系统中是一个高频次的操作，但由于 &lt;strong&gt;leftmost&lt;/strong&gt; 缺少左子树，根据红黑树性质，右子树也不可能太复杂，
意味着删除 &lt;strong&gt;leftmost&lt;/strong&gt; 后，调整红黑树的代价不会太大；&lt;/li&gt;
&lt;li&gt;插入操作需要遍历树，时间复杂度为 &lt;strong&gt;O(logn)&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;红黑树中不允许存在关键字相同的节点，因此拥有相同 &lt;strong&gt;系统时间点&lt;/strong&gt; 的节点组成链表，超时后它们全部被唤醒。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Skd/timetree_hu5a14de9a02930993b5ae32946216e0fc_64326_680x490_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;490&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS时间树
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;超时函数的统一形式&#34;&gt;超时函数的统一形式&lt;/h3&gt;
&lt;p&gt;XWOS所有带超时管理的CAPI函数，都是以后缀 &lt;strong&gt;_to&lt;/strong&gt; 结尾，超时的参数都为 &lt;strong&gt;xwtm_t to&lt;/strong&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 睡眠 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_sleep_to&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号量 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sem_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sem &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sem, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待条件量 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cond_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_cond &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cond,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;union&lt;/span&gt; xwlk_ulock lock, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; lktype,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkdata, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkst);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待互斥锁 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_mtx_lock_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_mtx &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mtx, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号旗 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_flg_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_flg &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; flg, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; trigger, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; action,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; origin[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; msk[],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号选择器 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sel_select_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sel &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sel, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; msk[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; trg[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待线程同步 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_br_wait_to&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_br &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; br, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; pos, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwbmp_t&lt;/span&gt; sync[], &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数 &lt;strong&gt;to&lt;/strong&gt; 表明线程期望在未来的某个时间点被唤醒。&lt;/p&gt;
&lt;p&gt;当用户实现了一个具有超时功能的接口，写接口时发现其中需要调用多个具有超时功能的CAPI，
更糟糕的是这些CAPI内部可能又调用了其他具有超时功能的CAPI。&lt;/p&gt;
&lt;p&gt;计算每个CAPI花费了多少时间，然后将他们从超时时间中减去，显然很难实现。
最简单的方式就是只看结果，即 &lt;strong&gt;只关注未来什么时间点要唤醒&lt;/strong&gt; 。
将这个 &lt;strong&gt;未来时间点&lt;/strong&gt; 在内部CAPI中传递，无论这些带有超时功能的CAPI调用多少层，只要发生超时就唤醒。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;my_api&lt;/span&gt;(..., &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwtm_t&lt;/span&gt; to)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_mtx_lock_to&lt;/span&gt;(mtx, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sem_wait_to&lt;/span&gt;(sem, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...&lt;span style=&#34;&#34;&gt;省略&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;无论 &lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt; 等待了多少时间，也不会影响 &lt;code&gt;xwos_sem_wait_to()&lt;/code&gt; 在 &lt;code&gt;to&lt;/code&gt; 这个时间点唤醒。
当 &lt;code&gt;xwos_mtx_lock_to()&lt;/code&gt; 把时间用尽， &lt;code&gt;to&lt;/code&gt; 就变成 &lt;strong&gt;过去的时间点&lt;/strong&gt; ， &lt;code&gt;xwos_sem_wait_to()&lt;/code&gt; 会立即返回 &lt;strong&gt;-ETIMEDOUT&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;获取上下文&#34;&gt;获取上下文&lt;/h2&gt;
&lt;p&gt;XWOS提供CAPI &lt;a href=&#34;../../../capi/group__xwos__skd.html#gace60b65a388c9ca8f796451733208173&#34;&gt;&lt;code&gt;xwos_skd_get_context_lc()&lt;/code&gt;&lt;/a&gt; 可以获取上下文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_INIT_EXIT&lt;/code&gt; ：初始化与反初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_THD&lt;/code&gt; ：线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_ISR&lt;/code&gt; ：中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_BH&lt;/code&gt; ：中断底半部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKD_CONTEXT_IDLE&lt;/code&gt; ：空闲任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;暂停和继续调度器&#34;&gt;暂停和继续调度器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html#ga6fd2598d05fd97e1e9afdc93e16ec672&#34;&gt;&lt;code&gt;xwos_skd_pause_lc()&lt;/code&gt;&lt;/a&gt; ：暂停本地CPU调度器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停调度器包括几个操作：
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;关闭本地CPU调度器的抢占；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关闭本地CPU调度器的中断底半部；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;关闭本地CPU的系统定时器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html#ga21200028ffbf1fe2027b947a76b949ad&#34;&gt;&lt;code&gt;xwos_skd_continue_lc()&lt;/code&gt;&lt;/a&gt; ：继续运行本地CPU调度器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继续运行调度器包括几个操作：
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;启动本地CPU的系统定时器；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;打开本地CPU调度器的中断底半部；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;打开本地CPU调度器的抢占。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__skd.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/skd.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__time.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/time.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程</title>
      <link>/docs/TechRefManual/Thd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Thd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt; 是XWOS最基本的调度单位，在其他RTOS中可能称之为 &lt;strong&gt;任务&lt;/strong&gt; 。
XWOS的线程，除了最基本的运行、睡眠、退出操作外，还支持冻结与解冻，迁移等操作。&lt;/p&gt;
&lt;p&gt;XWOS线程的函数，是仿造 &lt;code&gt;pthread&lt;/code&gt; 的函数设计的。&lt;/p&gt;
&lt;h3 id=&#34;线程的状态&#34;&gt;线程的状态&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 760px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Thd/thread-state_huaec0f5f93355fc1242cf72cb5941b922_44070_750x500_fill_catmullrom_smart1_3.png&#34; width=&#34;750&#34; height=&#34;500&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS线程状态图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;待命（standby）&lt;/strong&gt; ：线程对象已被初始化，但未指定主函数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪（ready）&lt;/strong&gt; ：线程已加入到就绪队列中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行（running）&lt;/strong&gt; ：线程正在运行，每个CPU中只可能存在一个线程正在运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;睡眠（sleeping）&lt;/strong&gt; ：线程正在睡眠；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞（blocking）&lt;/strong&gt; ：线程正在等待，可与&lt;strong&gt;睡眠&lt;/strong&gt;态组合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可被冻结（freezable）&lt;/strong&gt; ：线程可被冻结；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冻结（frozen）&lt;/strong&gt; ：线程已被冻结；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出（exiting）&lt;/strong&gt; ：线程即将结束；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移（migrating）&lt;/strong&gt; ：线程正处于迁移到别的CPU的过程中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; ：分离态的线程退出后由操作系统自动回收其内存资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已连接(joined)&lt;/strong&gt; ： &lt;strong&gt;连接态(joinable)&lt;/strong&gt; 的线程被其他线程 &lt;code&gt;join()&lt;/code&gt; 后的状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可被中断（uninterrupted）&lt;/strong&gt; ：线程的 &lt;strong&gt;阻塞&lt;/strong&gt; 与 &lt;strong&gt;睡眠&lt;/strong&gt; 不可被中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的分离态与连接态&#34;&gt;线程的分离态与连接态&lt;/h3&gt;
&lt;p&gt;XWOS线程的分离态与连接态是参考 &lt;strong&gt;pthread&lt;/strong&gt; 设计的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;code&gt;xwos_thd_join()&lt;/code&gt; 或 &lt;code&gt;xwos_thd_stop()&lt;/code&gt; 来回收其内存资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程对象与对象描述符&#34;&gt;线程对象与对象描述符&lt;/h3&gt;
&lt;p&gt;线程对象是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，线程对象也用 &lt;strong&gt;线程对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../api/structxwos__thd__d.html&#34;&gt;&lt;code&gt;xwos_thd_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;线程对象描述符由 &lt;strong&gt;线程对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; thd; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 线程对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_thd_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;线程的初始化与创建&#34;&gt;线程的初始化与创建&lt;/h2&gt;
&lt;h3 id=&#34;线程属性&#34;&gt;线程属性&lt;/h3&gt;
&lt;p&gt;线程在创建或初始化时，可通过参数 &lt;a href=&#34;../../../api/structxwos__thd__attr.html&#34;&gt;&lt;code&gt;struct xwos_thd_attr&lt;/code&gt;&lt;/a&gt; 设定其属性。
XWOS的线程属性参考 &lt;strong&gt;pthread&lt;/strong&gt; 来实现，其结构体定义也与 &lt;code&gt;pthread_attr_t&lt;/code&gt; 类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::privileged&lt;/code&gt; ：表示线程拥有系统特权。
&lt;ul&gt;
&lt;li&gt;在ARMv6m/ARMv7m中，是通过 &lt;code&gt;CONTROL&lt;/code&gt; 寄存器的 &lt;code&gt;bit0(nPRIV)&lt;/code&gt; 来实现的；&lt;/li&gt;
&lt;li&gt;在Embedded PowerPC中，是通过 &lt;code&gt;MSR&lt;/code&gt; 寄存器的 &lt;code&gt;bit17(PR)&lt;/code&gt; 来实现的；&lt;/li&gt;
&lt;li&gt;在RISCV32中，是通过 &lt;code&gt;MCAUSE&lt;/code&gt; 寄存器的 &lt;code&gt;bit28&lt;/code&gt; 和 &lt;code&gt;bit29(MPP)&lt;/code&gt; 来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::detached&lt;/code&gt; ：表示线程是分离的，类似于POSIX线程的detached属性。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;code&gt;xwos_thd_join()&lt;/code&gt; 或 &lt;code&gt;xwos_thd_stop()&lt;/code&gt; 来回收其内存资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack&lt;/code&gt; ：表示线程的栈的首地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack_size&lt;/code&gt; ：表示线程的栈的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::stack_guard_size&lt;/code&gt; ：表示线程的警戒线位置。
&lt;ul&gt;
&lt;li&gt;当栈指针sp增长超过了警戒线位置会触发 &lt;strong&gt;stackoverflow&lt;/strong&gt; 警告，但这需要SOC的MPU或MMU来提供支持，
可以在线程创建后的HOOK函数 &lt;code&gt;board_thd_postinit_hook()&lt;/code&gt; 来针对不同的SOC设置MPU或MMU。&lt;/li&gt;
&lt;li&gt;XWOS内部也提供了一种基于 &lt;code&gt;if...else...&lt;/code&gt; 的检测逻辑，但 &lt;strong&gt;stack overflow&lt;/strong&gt; 后导致程序跑飞，可能没有机会运行检测逻辑的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::name&lt;/code&gt; ：表示线程的名字，用于调试时的日志输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_thd_attr::priority&lt;/code&gt; ：表示线程的优先级，XWOS的优先级是数值越大，优先级越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;静态初始化&#34;&gt;静态初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaa65fb89529f37b1b87a2003fe562d99b&#34;&gt;&lt;code&gt;xwos_thd_init()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;li&gt;静态初始化线程还需预先定义栈数组，作用域为全局。&lt;/li&gt;
&lt;li&gt;栈数组的首地址与大小，必须要满足CPU的ABI规则。例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 &lt;code&gt;__xwcc__aligned(8)&lt;/code&gt; 来修饰，且大小是8的倍数。&lt;/li&gt;
&lt;li&gt;如果CPU内有L1Cache，应该使用 &lt;code&gt;__xwcc_alignl1cache&lt;/code&gt; 来修饰栈数组，让其对其到L1Cache的缓存线上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd static_thd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwos_thd_d static_thdd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;__xwcc_aligned&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwstk_t&lt;/span&gt; static_thd_stack[&lt;span style=&#34;color:#666&#34;&gt;512&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程函数... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;some_function&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_attr_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;static.thd&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; static_thd_stack;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack_size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(static_thd_stack);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.priority &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; THD_PRIORITY;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.detached &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.privileged &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;static_thd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;static_thdd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr, thd_func, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;动态创建&#34;&gt;动态创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaf224b65a6b895c5fa4ca51bfa3ff92e1&#34;&gt;&lt;code&gt;xwos_thd_create()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;li&gt;动态方式创建的线程，栈内存也可以动态申请，其地址对齐问题由操作系统内核处理。&lt;/li&gt;
&lt;li&gt;动态方式创建的线程，栈内存也支持使用静态方式定义的数组。栈数组的首地址与大小，必须要满足CPU的ABI规则。
例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 &lt;code&gt;__xwcc__aligned(8)&lt;/code&gt; 来修饰，且大小是8的倍数。&lt;/li&gt;
&lt;li&gt;如果CPU内有L1Cache，应该使用 &lt;code&gt;__xwcc_alignl1cache&lt;/code&gt; 来修饰栈静态方式定义的数组，让其对其到L1Cache的缓存线上。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;xwos_thd_d dynamic_thdd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程函数... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;some_function&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_thd_attr attr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_attr_init&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;dynamic.thd&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.stack_size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2048&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.priority &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; THD_PRIORITY;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.detached &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        attr.privileged &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_thd_create&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;dynamic_thdd, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;attr, thd_func, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;中断线程的阻塞态与睡眠态&#34;&gt;中断线程的阻塞态与睡眠态&lt;/h2&gt;
&lt;p&gt;但线程调用了会 &lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;睡眠&lt;/strong&gt; 的函数而进入 &lt;strong&gt;阻塞态&lt;/strong&gt; 或 &lt;strong&gt;睡眠态&lt;/strong&gt; 时，它会让出CPU，调度器会重新调度。
其他线程或上下文可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga2fc40de236c05f0a22420a4bca61ac56&#34;&gt;&lt;code&gt;xwos_thd_intr()&lt;/code&gt;&lt;/a&gt; 中断其 &lt;strong&gt;阻塞态&lt;/strong&gt; 或 &lt;strong&gt;睡眠态&lt;/strong&gt; ，
&lt;strong&gt;阻塞&lt;/strong&gt; 或 &lt;strong&gt;睡眠&lt;/strong&gt; 的函数会以错误码 &lt;strong&gt;-EINTR&lt;/strong&gt; ( &lt;strong&gt;-4&lt;/strong&gt; ) 返回。&lt;/p&gt;
&lt;h2 id=&#34;线程的退出与返回值&#34;&gt;线程的退出与返回值&lt;/h2&gt;
&lt;h3 id=&#34;线程的退出&#34;&gt;线程的退出&lt;/h3&gt;
&lt;p&gt;线程退出通常有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主函数直接 &lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;主函数中调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac5fbf8b3d9060ff19a12563cb3202beb&#34;&gt;&lt;code&gt;xwos_cthd_exit(rc)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此CAPI的用法类似于POSIX中的函数 &lt;code&gt;pthread_exit()&lt;/code&gt; ，调用的线程会立即终止并抛出返回值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_exit&lt;/span&gt;(XWOK); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程在此处结束，并抛出返回值 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 后面的代码不再执行 ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;线程分离&#34;&gt;线程分离&lt;/h3&gt;
&lt;p&gt;线程退出的行为，与属性 &lt;code&gt;xwos_thd_attr::detached&lt;/code&gt; 有关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离态(detached)&lt;/strong&gt; 的线程退出后，系统自动回收其资源；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接态(joinable)&lt;/strong&gt; 线程需要由另一个线程调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga26965560c7f4ad21b5089eed17a30e25&#34;&gt;&lt;code&gt;xwos_thd_stop()&lt;/code&gt;&lt;/a&gt; 来回收其内存资源。
若忘记调用，资源不会自动被回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通知线程退出&#34;&gt;通知线程退出&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gab4cdf4d2e068124cc11888b462da5de4&#34;&gt;&lt;code&gt;xwos_thd_quit()&lt;/code&gt;&lt;/a&gt; 可用于通知线程退出。
调用此CAPI，可为线程设置 &lt;strong&gt;退出状态&lt;/strong&gt; ，并中断线程的 &lt;strong&gt;阻塞状态&lt;/strong&gt; 和 &lt;strong&gt;睡眠状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被通知退出的线程&lt;/strong&gt; 正在调用的 &lt;strong&gt;阻塞和睡眠&lt;/strong&gt; 的CAPI将以返回值 &lt;code&gt;-EINTR&lt;/code&gt; 返回。除非 &lt;strong&gt;被通知退出的线程&lt;/strong&gt; 是 &lt;strong&gt;不可被中断&lt;/strong&gt; 的。&lt;/p&gt;
&lt;p&gt;线程自己可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac642513fb53a00db87738c6d2dd8e430&#34;&gt;&lt;code&gt;xwos_cthd_frz_shld_stop()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;退出状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;等待线程退出&#34;&gt;等待线程退出&lt;/h3&gt;
&lt;p&gt;若线程是 &lt;strong&gt;连接态(joinable)&lt;/strong&gt; 的，其他线程可通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 等待线程结束并获取其返回值。
此CAPI调用后，操作系统还会回收线程的资源。&lt;/p&gt;
&lt;h3 id=&#34;终止线程&#34;&gt;终止线程&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga26965560c7f4ad21b5089eed17a30e25&#34;&gt;&lt;code&gt;xwos_thd_stop()&lt;/code&gt;&lt;/a&gt; 可终止线程并等待它退出。
此CAPI等价于 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gab4cdf4d2e068124cc11888b462da5de4&#34;&gt;&lt;code&gt;xwos_thd_quit()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#gae78b56eaf8e520f68c1e06710e78b017&#34;&gt;&lt;code&gt;xwos_thd_join()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;线程自身检测-退出状态&#34;&gt;线程自身检测 &lt;strong&gt;退出状态&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;线程自己可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;退出状态&lt;/strong&gt; 。
可以作为线程循环的结束条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_stop&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...thread loop... */&lt;/span&gt; ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线程自身的睡眠&#34;&gt;线程自身的睡眠&lt;/h2&gt;
&lt;p&gt;XWOS内核提供多种线程睡眠方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gad1072fb4ff4803b8181fc7f54fcb3880&#34;&gt;&lt;code&gt;xwos_cthd_sleep()&lt;/code&gt;&lt;/a&gt; ：睡眠的时间的起点由此CAPI自己获取，这种方式只需告诉CAPI需要睡眠多少事件，使用简单，但精度较低。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga067c6169bf591a14813b004494e41f45&#34;&gt;&lt;code&gt;xwos_cthd_sleep_to()&lt;/code&gt;&lt;/a&gt; ：指定未来的某个时间点被唤醒，精度较高。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga46e5a1cbd6c58a36dda954a76e44b3e2&#34;&gt;&lt;code&gt;xwos_cthd_sleep_from()&lt;/code&gt;&lt;/a&gt;：睡眠时间的起点和持续时间由调用者提供，时间起点可以是 &lt;strong&gt;过去&lt;/strong&gt; 的时间点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果线程只是想让调度器在同优先级的就绪队列中重新调度一下，可以通过调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac453f990c2da012a43e7cbe121b8ec10&#34;&gt;&lt;code&gt;xwos_cthd_sleep()&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;线程的冻结与解冻&#34;&gt;线程的冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;线程自身冻结&#34;&gt;线程自身冻结&lt;/h3&gt;
&lt;p&gt;线程的冻结，是用来支持内核的一些特殊功能的，用户不能随意冻结线程。
在以下情况，XWOS内核要求线程进入冻结状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统准备进入低功耗模式。如果此时线程还在运行，很有可能因其正在访问硬件资源、
占用锁，导致系统关闭硬件、清理资源时发生异常。因此线程需要运行到一个特殊的点后冻结，这个点就是 &lt;strong&gt;冻结点&lt;/strong&gt; 。
线程进入冻结点前，需要返回到最外层的主函数中，并释放掉所有的锁和硬件资源。&lt;/li&gt;
&lt;li&gt;线程迁移至另一个CPU。线程迁移时，也需要返回至最外层的冻结点，保证不能占用当前CPU的任何资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程可以通过 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga9bde1c6bafdb881079b41803296b69ee&#34;&gt;&lt;code&gt;xwos_cthd_shld_frz()&lt;/code&gt;&lt;/a&gt; 检测 &lt;strong&gt;可被冻结&lt;/strong&gt; 状态。
一旦检测到 &lt;strong&gt;可被冻结&lt;/strong&gt; 状态，就需要调用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga7088d8e2a4c5ee8497dba07ff2dbc32d&#34;&gt;&lt;code&gt;xwos_cthd_freeze()&lt;/code&gt;&lt;/a&gt; 冻结自己。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_stop&lt;/span&gt;()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断线程是否需要退出 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;do_sth&lt;/span&gt;(&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程在内部阻塞在某个同步对象或锁上 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;EINTR &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; rc) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 当线程需要冻结，阻塞/睡眠将被中断会以-EINTR返回 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_shld_frz&lt;/span&gt;()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断是否需要冻结 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;release_resource&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 释放资源... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_freeze&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 冻结 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程解冻后，从这里继续执行。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 如果线程发生了迁移，线程在另一个CPU上也是从此处开始运行。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#00a000&#34;&gt;acquire_resource&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 重新获取资源... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 处理其他原因导致的中断... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果线程冻结之前不需要释放任何资源，可以使用 &lt;a href=&#34;../../../capi/group__xwos__thd.html#gac642513fb53a00db87738c6d2dd8e430&#34;&gt;&lt;code&gt;xwos_cthd_frz_shld_stop()&lt;/code&gt;&lt;/a&gt; 。
此CAPI等价于 &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga9bde1c6bafdb881079b41803296b69ee&#34;&gt;&lt;code&gt;xwos_cthd_shld_frz()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga7088d8e2a4c5ee8497dba07ff2dbc32d&#34;&gt;&lt;code&gt;xwos_cthd_freeze()&lt;/code&gt;&lt;/a&gt; + &lt;a href=&#34;../../../capi/group__xwos__thd.html#ga27ed7a92e01aed514e941e0440e8863b&#34;&gt;&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;线程循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;thd_func&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; wasfrz;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_frz_shld_stop&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;wasfrz)) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 通过wasfrz可以获知线程是否被冻结过 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...线程循环... */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ...省略... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;线程的解冻不由用户来操作，系统完成特殊功能后会自动对线程进行解冻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统退出低功耗模式时&lt;/li&gt;
&lt;li&gt;线程迁移操作已经完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的迁移&#34;&gt;线程的迁移&lt;/h2&gt;
&lt;p&gt;在多核系统中，XWOS的线程只会在某个CPU上被调度，XWOS内核并不会自动对线程做均衡处理，但支持将线程迁移到另一个CPU上。&lt;/p&gt;
&lt;h3 id=&#34;迁移流程&#34;&gt;迁移流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假定条件：线程正在CPU-A上，准备迁移到CPU-B上&lt;/li&gt;
&lt;li&gt;流程：
&lt;ul&gt;
&lt;li&gt;用户在任意CPU的任意上下文调用CAPI： &lt;a href=&#34;../../../capi/group__xwos__thd.html#gaccabca6cd9608f56205e634f9676a8f5&#34;&gt;&lt;code&gt;xwos_thd_migrate()&lt;/code&gt;&lt;/a&gt; ；
&lt;ul&gt;
&lt;li&gt;系统向CPU-A发送调度器服务中断，提出 &lt;strong&gt;迁移出&lt;/strong&gt; 的申请；&lt;/li&gt;
&lt;li&gt;CPU-A切换至调度器服务中断，向线程设置冻结标志，并中断线程的阻塞态和睡眠态，然后退出中断上下文；&lt;/li&gt;
&lt;li&gt;CPU-A中线程被重新调度，并运行到冻结点；&lt;/li&gt;
&lt;li&gt;线程在冻结点向CPU-A发送调度器服务中断，执行 &lt;strong&gt;冻结&lt;/strong&gt; 操作；&lt;/li&gt;
&lt;li&gt;线程冻结后，CPU-A向CPU-B申请调度器服务中断，提出 &lt;strong&gt;迁移进&lt;/strong&gt; 的申请；&lt;/li&gt;
&lt;li&gt;CPU-B切换至调度器服务中断，把线程加入到自己的调度器中，解除线程的冻结状态，并加入就绪列表中；&lt;/li&gt;
&lt;li&gt;迁移完成，线程开始在CPU-B中调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的本地存储&#34;&gt;线程的本地存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;C11&lt;/strong&gt; 标准之后引入线程本地存储(TLS)，XWOS支持关键字 &lt;code&gt;_Thread_local&lt;/code&gt; ( &lt;strong&gt;C99&lt;/strong&gt; )、 &lt;code&gt;thread_local&lt;/code&gt; ( &lt;strong&gt;C2X&lt;/strong&gt; ) ，
以及 &lt;strong&gt;gcc&lt;/strong&gt; 以及 &lt;strong&gt;clang&lt;/strong&gt; 编译器扩展的关键字 &lt;code&gt;__thread&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;strong&gt;C99&lt;/strong&gt; 以前的标准，用户可以通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gae188b894f4ddcf94b3df3c7cd1f071d5&#34;&gt;&lt;code&gt;xwos_cthd_set_data()&lt;/code&gt;&lt;/a&gt; ：设置线程自身私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga160c44b91fdff5f5610a32e72c822639&#34;&gt;&lt;code&gt;xwos_cthd_get_data()&lt;/code&gt;&lt;/a&gt; ：获取线程自身私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga62529c26dfb773bd973f0841e3c06ed4&#34;&gt;&lt;code&gt;xwos_thd_set_data()&lt;/code&gt;&lt;/a&gt; ：设置任意线程私有变量&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#gaf2fdd413163f2868c68199c12467c2a0&#34;&gt;&lt;code&gt;xwos_thd_get_data()&lt;/code&gt;&lt;/a&gt; ：获取任意线程私有变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程对象的生命周期管理&#34;&gt;线程对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;线程对象的基类是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
线程对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga1183035d75506a5e3d7ea52a096cabe7&#34;&gt;&lt;code&gt;xwos_thd_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga3a3e3d71eed7967d5fd21915317dfe8c&#34;&gt;&lt;code&gt;xwos_thd_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga4b75215c8821082a451e274bc07fcd2d&#34;&gt;&lt;code&gt;xwos_thd_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html#ga12a0141b2c54bd3c0b73fe74049155cb&#34;&gt;&lt;code&gt;xwos_thd_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__thd.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/thd.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 软件定时器</title>
      <link>/docs/TechRefManual/Swt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Swt/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;软件定时器是基于调度器的&lt;a href=&#34;../Skd#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;实现的，因此时间精度最小为滴答定时器的中断频率。
软件定时器可以是 &lt;strong&gt;单次&lt;/strong&gt; 的，也可以是 &lt;strong&gt;周期&lt;/strong&gt; 的。&lt;/p&gt;
&lt;h3 id=&#34;软件定时器对象与对象描述符描述符&#34;&gt;软件定时器对象与对象描述符描述符&lt;/h3&gt;
&lt;p&gt;软件定时器对象是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 的派生类 。
类似的，软件定时器对象也用 &lt;strong&gt;软件定时器对象描述符&lt;/strong&gt; &lt;a href=&#34;../../../api/structxwos__swt__d.html&#34;&gt;&lt;code&gt;xwos_swt_d&lt;/code&gt;&lt;/a&gt;
来解决有效性和身份合法性的问题。&lt;/p&gt;
&lt;p&gt;软件定时器对象描述符由 &lt;strong&gt;软件定时器对象的指针&lt;/strong&gt; 和 &lt;strong&gt;标签&lt;/strong&gt; 组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_swt &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; swt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 软件定时器对象的指针 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwsq_t&lt;/span&gt; tik; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/**&amp;lt; 标签 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} xwos_swt_d;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过对象描述符引用对象时，首先检测 &lt;code&gt;obj-&amp;gt;magic&lt;/code&gt; 的值，是否为 &lt;code&gt;0x58574F53U&lt;/code&gt; ，由此可确定指针 &lt;code&gt;obj&lt;/code&gt; 指向一个有效的 &lt;strong&gt;XWOS的对象&lt;/strong&gt; 。
然后对比标签 &lt;code&gt;obj-&amp;gt;tik&lt;/code&gt; 和 &lt;code&gt;tik&lt;/code&gt; 是否相等，由此可以确定对象的 &lt;strong&gt;身份&lt;/strong&gt; 。
因为对象的 &lt;code&gt;tik&lt;/code&gt; 是全局唯一的，当对象被释放后，它的 &lt;code&gt;tik&lt;/code&gt; 会被析构函数析构为 &lt;strong&gt;0&lt;/strong&gt; 。
当内存地址被重新构建为新的对象，那么它的 &lt;code&gt;tik&lt;/code&gt; 一定与对象描述符的 &lt;code&gt;tik&lt;/code&gt; 不一致。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器的初始化销毁与动态创建删除&#34;&gt;软件定时器的初始化、销毁与动态创建、删除&lt;/h2&gt;
&lt;h3 id=&#34;静态初始化销毁&#34;&gt;静态初始化、销毁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化： &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga6caba60b647d79eaedc3c27574eed0dd&#34;&gt;&lt;code&gt;xwos_swt_init()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt; 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁静态初始化的软件定时器： &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaea2454a168f5c6c5e73d49e40951aca1&#34;&gt;&lt;code&gt;xwos_swt_fini()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态创建删除&#34;&gt;动态创建、删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;动态创建： &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga66c1d6aeb17f7409f8ea0a891da4f301&#34;&gt;&lt;code&gt;xwos_swt_create()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt; 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除动态创建的软件定时器： &lt;a href=&#34;../../../capi/group__xwos__swt.html#gac631b6c398b820410a9507bb3b24645a&#34;&gt;&lt;code&gt;xwos_swt_delete()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软件定时器的标志&#34;&gt;软件定时器的标志&lt;/h2&gt;
&lt;p&gt;软件定时器在初始化或创建时，需要指定 &lt;strong&gt;标志&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga2b8e3dc8c11fed042cdf140302bd3e3c&#34;&gt;&lt;code&gt;XWOS_SWT_FLAG_NULL&lt;/code&gt;&lt;/a&gt; ：无任何标志，占位符，也表示定时器为单次的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gaa30937ca651cbc12c7d2827d3eae987f&#34;&gt;&lt;code&gt;XWOS_SWT_FLAG_RESTART&lt;/code&gt;&lt;/a&gt; ：定时器为周期性的，即超时后自动重新开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;启动软件定时器&#34;&gt;启动软件定时器&lt;/h2&gt;
&lt;p&gt;软件定时器初始化或创建完成后，可以使用 &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga3defb3f4a851acb451b38adbdf28d0cb&#34;&gt;&lt;code&gt;xwos_swt_start()&lt;/code&gt;&lt;/a&gt; 启动。&lt;/p&gt;
&lt;p&gt;启动时，需要指定开始的时间起点，周期，以及回调函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf5517e151d64405f9db648f50a71ee07&#34;&gt;&lt;code&gt;xwos_swt_f&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器的回调函数&#34;&gt;软件定时器的回调函数&lt;/h2&gt;
&lt;p&gt;软件定时器超时后，其回调函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf5517e151d64405f9db648f50a71ee07&#34;&gt;&lt;code&gt;xwos_swt_f&lt;/code&gt;&lt;/a&gt; 会被调用。其原型被定义为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwos_swt_f) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_swt &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中第一个参数是软件定时器自己的指针，第二个参数是在 &lt;a href=&#34;../../../capi/group__xwos__swt.html#ga3defb3f4a851acb451b38adbdf28d0cb&#34;&gt;&lt;code&gt;xwos_swt_start()&lt;/code&gt;&lt;/a&gt; 指定的回调函数的参数。&lt;/p&gt;
&lt;p&gt;软件定时器的回调函数运行在滴答定时器任务中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当开启中断底半部时，软件定时器的回调函数运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;当关闭中断底半部时，软件定时器的回调函数运行在中断上下文中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是运行在中断底半部还是中断上下文，软件定时器的回调函数都 &lt;strong&gt;不&lt;/strong&gt; 可使用任何会导致睡眠、阻塞的API。&lt;/p&gt;
&lt;h2 id=&#34;停止软件定时器&#34;&gt;停止软件定时器&lt;/h2&gt;
&lt;p&gt;用户可以通过 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gab2fe98dd896049aeba43a524909a8a5b&#34;&gt;&lt;code&gt;xwos_swt_stop()&lt;/code&gt;&lt;/a&gt; 停止已经启动的软件定时器。&lt;/p&gt;
&lt;p&gt;对于未启动的软件定时器，此函数 &lt;a href=&#34;../../../capi/group__xwos__swt.html#gab2fe98dd896049aeba43a524909a8a5b&#34;&gt;&lt;code&gt;xwos_swt_stop()&lt;/code&gt;&lt;/a&gt; 只会返回错误码，
不会产生任何破坏性的影响。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器对象的生命周期管理&#34;&gt;软件定时器对象的生命周期管理&lt;/h2&gt;
&lt;p&gt;软件定时器对象的基类是 &lt;a href=&#34;../Xwobj&#34;&gt;XWOS对象&lt;/a&gt; &lt;a href=&#34;../../../api/structxwos__object.html&#34;&gt;&lt;code&gt;struct xwos_object&lt;/code&gt;&lt;/a&gt; 。
软件定时器对象也有两组生命周期管理的CAPI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象指针&lt;/strong&gt; 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 &lt;strong&gt;释放-又被申请&lt;/strong&gt; 为另一个对象的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gaf804ccd1a6eab3e80edcd9cd5a8d7752&#34;&gt;&lt;code&gt;xwos_swt_grab()&lt;/code&gt;&lt;/a&gt; ：增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga29900a2342065235217f98d5048bdcac&#34;&gt;&lt;code&gt;xwos_swt_put()&lt;/code&gt;&lt;/a&gt; ：减少引用计数，当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;strong&gt;对象描述符&lt;/strong&gt; 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#ga585f2ef89c9a4565006beedd7c10aacd&#34;&gt;&lt;code&gt;xwos_swt_acquire()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再增加引用计数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html#gab6df0a49f8b9be89f96d9c95773d13c2&#34;&gt;&lt;code&gt;xwos_swt_release()&lt;/code&gt;&lt;/a&gt; ：通过对象描述符确定对象有效且合法，再减少引用计数。
当引用计数减少为 &lt;strong&gt;0&lt;/strong&gt; 时，调用垃圾回收函数释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__swt.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/swt.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 锁</title>
      <link>/docs/TechRefManual/Lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Lock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;临界区管理&#34;&gt;临界区管理&lt;/h2&gt;
&lt;p&gt;临界区是指访问共用资源的程序片段，传统RTOS中，通常使用以下几种方式保护临界区资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用协作式内核：线程（任务）不主动放弃CPU不会发生调度，因此共享的资源在
线程（任务）中访问都是安全的。&lt;/li&gt;
&lt;li&gt;关闭抢占：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;li&gt;关闭中断：可用于保护线程与线程、线程与中断共享的资源。&lt;/li&gt;
&lt;li&gt;互斥锁：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS内核是假定系统为MP来设计的（UP可以视为MP的特例），
因此在进入临界区的方式与传统RTOS有些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭抢占：使用自旋锁或其派生锁的&lt;code&gt;lock&lt;/code&gt;与&lt;code&gt;unlock&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;关闭CPU总中断：使用自旋锁或其派生锁的&lt;code&gt;lock_cpuirq&lt;/code&gt;与&lt;code&gt;unlock_cpuirq&lt;/code&gt;形式的API。
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_cpuirqsv&lt;/code&gt;与&lt;code&gt;unlock_cpuirqrs&lt;/code&gt;
形式的API来保存与恢复CPU总中断开关标志，防止内层锁解锁时意外地把CPU总中断打开；&lt;/li&gt;
&lt;li&gt;关闭部分中断：使用自旋锁或其派生锁的&lt;code&gt;lock_irqs&lt;/code&gt;与&lt;code&gt;unlock_irqs&lt;/code&gt;形式的API，
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_irqssv&lt;/code&gt;与&lt;code&gt;unlock_irqsrs&lt;/code&gt;
形式的API来保存与恢复部分中断开关标志，防止内层锁解锁时意外地把这些中断打开；&lt;/li&gt;
&lt;li&gt;关闭中断底半部：使用自旋锁或其派生锁的&lt;code&gt;lock_bh&lt;/code&gt;与&lt;code&gt;unlock_bh&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;互斥锁：只能用于保护被多个线程共享的资源；&lt;/li&gt;
&lt;li&gt;原子操作：XWOS中提供原子操作的函数库&lt;code&gt;xwos/lib/xwaop.h&lt;/code&gt;，并抽象了std:atomic类似的内存模型。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 同步</title>
      <link>/docs/TechRefManual/Sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Sync/</guid>
      <description>
        
        
        &lt;p&gt;XWOS提供多种同步机制，它们统一称为&lt;strong&gt;同步对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;条件量&lt;/li&gt;
&lt;li&gt;事件标志&lt;/li&gt;
&lt;li&gt;线程栅栏&lt;/li&gt;
&lt;li&gt;信号选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;与&lt;strong&gt;条件量&lt;/strong&gt;是操作系统最基本的两种同步机制，
其他复杂的同步机制都可基于这两种同步机制实现。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 内存管理</title>
      <link>/docs/TechRefManual/Mm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Mm/</guid>
      <description>
        
        
        &lt;p&gt;XWOS提供四种内存管理的算法。&lt;/p&gt;
&lt;h2 id=&#34;简单内存分配器&#34;&gt;简单内存分配器&lt;/h2&gt;
&lt;p&gt;简单内存分配器只分配大小最适应内存块，不对内存进行回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单，代码量非常小；&lt;/li&gt;
&lt;li&gt;运行时间稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：内存一旦分配出去不再回收，释放函数只是一个 &lt;strong&gt;Dummy&lt;/strong&gt; 函数；&lt;/li&gt;
&lt;li&gt;适用性：简单的RTOS应用场合或不需要回收内存的场合&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__sma.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/sma.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存切片分配器&#34;&gt;内存切片分配器&lt;/h2&gt;
&lt;p&gt;内存切片分配器将内存切割成等量的块，就像 &lt;strong&gt;卡片&lt;/strong&gt; 一样，然后将它们连接在一起形成队列，
每次分配时取一块内存，回收时再把内存切片放回到队列中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单，代码量较小；&lt;/li&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;申请与释放操作的运行时间是稳定的；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;内存块大小固定，如果要求的内存过小，会造成内存浪费；
如果要求的内存超过内存块的大小，无法满足需求；&lt;/li&gt;
&lt;li&gt;连续申请的两块内存不能保证是连续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：对时间稳定性要求高的RTOS应用场合。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__memslice.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/memslice.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;伙伴算法分配器&#34;&gt;伙伴算法分配器&lt;/h2&gt;
&lt;p&gt;伙伴算法分配器在分配时，会将内存不断地二等分，直到切割到能满足要求的最小内存大小为止。
释放时会检查与之相邻并等长的内存块（称为伙伴）是否也空闲，
如果是，就和“伙伴”合并成更大的内存块，
然后继续检测合并后的内存块是否也存在可以合并的伙伴，一直向上合并到不能合并为止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;支持大小不固定的内存申请操作；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;代码稍微复杂；&lt;/li&gt;
&lt;li&gt;因为存在合并与切割的循环，申请与释放操作的所需要的时间不是特别稳定；&lt;/li&gt;
&lt;li&gt;内存大小固定为2的指数，如果申请的内存过小，会造成内存浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：对内存复用性要求高的应用场合。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__bma.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/bma.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存池&#34;&gt;内存池&lt;/h2&gt;
&lt;p&gt;内存池是结合了内存切片分配器与伙伴算法分配器的算法。内存管理的基本单位为页，
一页内存为4096字节，页内存使用伙伴算法分配器管理。
内存池还使用对象缓存算法建立各种小尺寸的块：8字节、16字节、32字节、
64字节、96字节、128字节、160字节、192字节、256字节、320字节、384字节、
512字节、768字节、1024字节、2048字节。
当申请内存大于2048字节，直接分配页内存；当申请的内存小于等于2048字节，
就从尺寸最合适的对象缓存分配器中分配一块内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;支持释放操作；&lt;/li&gt;
&lt;li&gt;支持大小不固定的内存申请操作；&lt;/li&gt;
&lt;li&gt;反复申请与释放不会造成内存碎片；&lt;/li&gt;
&lt;li&gt;小内存块不会浪费过多的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;代码复杂；&lt;/li&gt;
&lt;li&gt;申请与释放操作的所需要的时间不稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用性：外接尺寸较大的SRAM或SDRAM的内存管理，C++和Lua虚拟机的对象池。&lt;/li&gt;
&lt;li&gt;上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。&lt;/li&gt;
&lt;li&gt;CAPI参考： &lt;a href=&#34;../../../capi/group__xwmm__mempool.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/mm/mempool.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 电源管理</title>
      <link>/docs/TechRefManual/Pm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Pm/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XWOS有两套电源管理框架，分别用于MP系统和UP系统。&lt;/p&gt;
&lt;p&gt;XWOS的电源管理框架只提供了基本流程，最终SOC如何休眠由BSP中的回调函数实现：
用户可以自行决定是否保持SDRAM的刷新、是否保持某些GPIO的输出、或则是否进入最低功耗的待机等等。&lt;/p&gt;
&lt;h2 id=&#34;mp系统的电源管理&#34;&gt;MP系统的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;电源管理领域&#34;&gt;电源管理领域&lt;/h3&gt;
&lt;p&gt;MP系统中，CPU不唯一，XWOS中使用 &lt;strong&gt;电源管理领域(PMDM)&lt;/strong&gt; 来统一管理所有CPU的休眠与唤醒。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 789px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Pm/mp-pm-flow_huad237c88a54a050d1276e5f5ab1230e1_100614_779x658_fill_catmullrom_smart1_3.png&#34; width=&#34;779&#34; height=&#34;658&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
MP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了可以进行 &lt;strong&gt;电源管理阶段&lt;/strong&gt; 转换的方向。
&lt;strong&gt;电源管理领域&lt;/strong&gt; 将电源管理分为四个阶段（图中绿色的框）：&lt;/p&gt;
&lt;h5 id=&#34;正在运行--xwmp_pmdm_stage_running-&#34;&gt;正在运行 ( &lt;code&gt;XWMP_PMDM_STAGE_RUNNING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;所有CPU正常运行，可以使用下面CAPI进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwos_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此CAPI是操作系统抽象层 &lt;strong&gt;OSAL&lt;/strong&gt; 中的CAPI，实际调用的是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwmp_pmdm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;冻结调度器--解冻调度器--xwmp_pmdm_stage_freezing---xwmp_pmdm_stage_thawing-&#34;&gt;冻结调度器 —— 解冻调度器 ( &lt;code&gt;XWMP_PMDM_STAGE_FREEZING - XWMP_PMDM_STAGE_THAWING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，PMDM会通知所有CPU冻结线程。当调度器中线程全部冻结后，调度器会向PMDM报告 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态。
调度器冻结线程的过程是一个比较复杂的过程，这个阶段又分为几个子阶段（图中蓝色的框）：&lt;/p&gt;
&lt;h6 id=&#34;冻结线程--解冻线程--xwmp_skd_wklkcnt_freezing---xwmp_skd_wklkcnt_thawing-&#34;&gt;冻结线程 —— 解冻线程 ( &lt;code&gt;XWMP_SKD_WKLKCNT_FREEZING - XWMP_SKD_WKLKCNT_THAWING&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;调度器会中断所有线程的 &lt;strong&gt;等待&lt;/strong&gt; 和 &lt;strong&gt;睡眠&lt;/strong&gt; 态，并为所有线程设置 &lt;strong&gt;可冻结&lt;/strong&gt; 标志，
然后依次调度每个线程，直到它们运行到 &lt;strong&gt;冻结点&lt;/strong&gt; 进行冻结，这个过程耗时比较长，
在执行过程中如果遇到唤醒事件，调度器会在唤醒事件中断中切换为解冻流程：
解冻已经冻结的线程，并取消未冻结的线程的 &lt;strong&gt;可冻结&lt;/strong&gt; 标志。&lt;/p&gt;
&lt;h6 id=&#34;全部线程已经冻结--xwmp_skd_wklkcnt_allfrz-&#34;&gt;全部线程已经冻结 ( &lt;code&gt;XWMP_SKD_WKLKCNT_ALLFRZ&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断。
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照 &lt;a href=&#34;../Skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt; 中的约束，唤醒事件中断的优先级低于调度器服务中断，
因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，
滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h6 id=&#34;调度器已经暂停--xwmp_skd_wklkcnt_suspended-&#34;&gt;调度器已经暂停 ( &lt;code&gt;XWMP_SKD_WKLKCNT_SUSPENDED&lt;/code&gt; )&lt;/h6&gt;
&lt;p&gt;CPU从上一步骤的调度器服务中断中退出后，会切换回线程上下文，此时因所有线程已经冻结，
CPU只可能运行在 &lt;a href=&#34;../Skd#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1&#34;&gt;空闲任务&lt;/a&gt; 中。
CPU会在空闲任务中向PMDM报告调度器 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态。此过程不能在调度器服务中断中进行，
因为调度器服务中断是最高优先级中断，不能被唤醒事件中断打断，有可能会导致无法唤醒的问题。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复--xwmp_pmdm_stage_suspending---xwmp_pmdm_stage_resuming-&#34;&gt;正在暂停 —— 正在恢复 ( &lt;code&gt;XWMP_PMDM_STAGE_SUSPENDING - XWMP_PMDM_STAGE_RESUMING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;当最后一个CPU报告了 &lt;strong&gt;已经暂停&lt;/strong&gt; 的状态后，会在最后一个CPU的 &lt;strong&gt;空闲任务&lt;/strong&gt; 中执行用户的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数。
此时，如果出现唤醒事件，电源管理的阶段会从 &lt;strong&gt;正在暂停&lt;/strong&gt; 切换为 &lt;strong&gt;正在恢复&lt;/strong&gt; ，并执行用户的 &lt;code&gt;resume()&lt;/code&gt; 回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt; 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt; 回调函数用于在唤醒之前执行与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时，PMDM会自动锁定 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; ，并关闭当前CPU的总中断开关。
&lt;strong&gt;resume-suspend锁&lt;/strong&gt; 是自旋锁，如果CPU-1正在执行 &lt;code&gt;suspend()&lt;/code&gt; 回调函数，此时出现了唤醒事件，会分下面两种情况进行处理：
&lt;ul&gt;
&lt;li&gt;唤醒事件中断也绑定在CPU-1上，唤醒事件中断会挂起，直到 &lt;code&gt;suspend()&lt;/code&gt; 回调函数返回，
PMDM解锁 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; 并打开CPU总中断开关，才被处理，然后执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;li&gt;唤醒事件中断绑定在CPU-2上，CPU-2会立即进入唤醒事件中断，但一直会 &lt;strong&gt;自旋&lt;/strong&gt; 等待CPU-1释放 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; ，
直到获得 &lt;strong&gt;resume-suspend锁&lt;/strong&gt; 后，才会执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例WeActMiniStm32H750的 &lt;code&gt;resume()&lt;/code&gt; 与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_resume&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 恢复stm32cube中的所有设备 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwds_pm_resume&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 暂停stm32cube：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 暂停所有设备
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 配置GPIO */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;xwds_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置休眠方式为STOP模式：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           STOP模式下寄存器与内部RAM数据不丢失，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           因此休眠方式为SuspendToRAM，唤醒后运行状态可恢复。*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_SetRegulModeDS&lt;/span&gt;(LL_PWR_REGU_DSMODE_LOW_POWER);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_EnableFlashPowerDown&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD1PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D1STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD2PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D2STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_PWR_CPU_SetD3PowerMode&lt;/span&gt;(LL_PWR_CPU_MODE_D3STOP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableDeepSleep&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置ARMv7-m的DEEPSLEEP位 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableDeepSleep&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;已经暂停--xwmp_pmdm_stage_suspended-&#34;&gt;已经暂停 ( &lt;code&gt;XWMP_PMDM_STAGE_SUSPENDED&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt; ：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt; ：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当最后一个CPU的 &lt;strong&gt;空闲任务&lt;/strong&gt; 执行完上一阶段的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数后，
PMDM将电源管理步骤切换到此阶段，并执行 &lt;code&gt;sleep()&lt;/code&gt; 回调函数。
SOC系统在 &lt;code&gt;sleep()&lt;/code&gt; 回调函数内部进入低功耗状态，
此时时钟停止，代码停止运行， &lt;code&gt;sleep()&lt;/code&gt; 回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将 &lt;code&gt;sleep()&lt;/code&gt; 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。
例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ &lt;code&gt;WFI&lt;/code&gt; ），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现， &lt;code&gt;wakeup()&lt;/code&gt; 回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数 &lt;code&gt;sleep()&lt;/code&gt; 与 &lt;code&gt;wakeup()&lt;/code&gt; 之间没有锁的保护，
因此 &lt;code&gt;sleep()&lt;/code&gt; 回调函数需要设计成能被 &lt;code&gt;wakeup()&lt;/code&gt; 回调函数打断。&lt;/p&gt;
&lt;p&gt;示例，WeActMiniStm32H750的 &lt;code&gt;wakeup()&lt;/code&gt; 与 &lt;code&gt;sleep()&lt;/code&gt; 回调函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_wakeup&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;LL_LPM_EnableSleep&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 清除DEEPSLEEP位 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;SystemClock_Config&lt;/span&gt;(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从STOP模式恢复后，需要重新配置时钟 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_sleep&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00a000&#34;&gt;cm_wfi&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分为两种情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中的 &lt;code&gt;WFI&lt;/code&gt; 指令执行后出现唤醒事件：
唤醒流程执行完毕后，代码会回到 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中 &lt;strong&gt;位置2&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 中的 &lt;code&gt;WFI&lt;/code&gt; 指令执行之前出现唤醒事件：
唤醒事件中断会打断 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 函数，
然后执行 &lt;code&gt;stm32cube_pm_wakeup()&lt;/code&gt; 函数，
函数 &lt;code&gt;LL_LPM_EnableSleep()&lt;/code&gt; 会清除ARMv7-m的DEEPSLEEP位，接下来的唤醒流程也会将滴答定时器重新打开，
当再次回到 &lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt; 的 &lt;strong&gt;位置1&lt;/strong&gt; 时， &lt;code&gt;WFI&lt;/code&gt; 指令只会使CPU进入ARMv7-m的SLEEP模式，
只是短暂地暂停了一下CPU时钟，即将到来的滴答定时器中断可使系统恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;up内核的电源管理&#34;&gt;UP内核的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;流程-1&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 683px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/TechRefManual/Pm/up-pm-flow_hud28fc7ba75fb6cae820cff89a3e4c72a_66458_673x499_fill_catmullrom_smart1_3.png&#34; width=&#34;673&#34; height=&#34;499&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
UP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY-SA-4.0&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了 &lt;strong&gt;电源管理阶段&lt;/strong&gt; 切换的方向。
UP系统电源管理分为五个阶段：&lt;/p&gt;
&lt;h5 id=&#34;正在运行--xwup_pm_stage_running-&#34;&gt;正在运行 ( &lt;code&gt;XWUP_PM_STAGE_RUNNING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;调度器正常运行，可以使用下面CAPI进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;xwer_t&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;xwup_skd_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;正在冻结线程--正在解冻线程--xwup_pm_stage_freezing---xwup_pm_stage_thawing-&#34;&gt;正在冻结线程 —— 正在解冻线程 ( &lt;code&gt;XWUP_PM_STAGE_FREEZING - XWUP_PM_STAGE_THAWING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，调度器会中断所有线程的 &lt;strong&gt;等待&lt;/strong&gt; 和 &lt;strong&gt;睡眠&lt;/strong&gt; 态，并通知所有线程冻结。这个过程耗时比较长，
在执行过程中如果遇到唤醒事件，调度器可在唤醒事件中断中切换为解冻流程：解冻已冻结的线程，并将调度器状态逐步恢复至 &lt;strong&gt;正在运行&lt;/strong&gt; 。&lt;/p&gt;
&lt;h5 id=&#34;调度器中全部线程已经冻结--xwup_pm_stage_allfrz-&#34;&gt;调度器中全部线程已经冻结 ( &lt;code&gt;XWUP_PM_STAGE_ALLFRZ&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断，
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照 &lt;a href=&#34;../Skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt; 中的约束，唤醒事件中断的优先级低于调度器服务中断，
因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复--xwup_pm_stage_suspending---xwup_pm_stage_resuming-&#34;&gt;正在暂停 —— 正在恢复 ( &lt;code&gt;XWUP_PM_STAGE_SUSPENDING - XWUP_PM_STAGE_RESUMING&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;当全部线程冻结后，调度器只能调度 &lt;strong&gt;空闲任务&lt;/strong&gt; ，调度器会在 &lt;strong&gt;空闲任务&lt;/strong&gt; 中执行用户的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数。
此时，如果出现唤醒事件，系统会在唤醒事件中断中将状态从 &lt;strong&gt;正在暂停&lt;/strong&gt; 切换为 &lt;strong&gt;正在恢复&lt;/strong&gt; ，并执行用户的 &lt;code&gt;resume()&lt;/code&gt; 回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt; 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt; 回调函数用于在唤醒之前执行与 &lt;code&gt;suspend()&lt;/code&gt; 回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时系统会关闭CPU总中断开关。如果正在执行 &lt;code&gt;suspend()&lt;/code&gt; 回调函数时出现了唤醒事件，
唤醒事件中断会挂起，直到 &lt;code&gt;suspend()&lt;/code&gt; 回调函数，系统打开CPU总中断开关时才被处理，然后执行 &lt;code&gt;resume()&lt;/code&gt; 回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;已经暂停--xwup_pm_stage_suspended-&#34;&gt;已经暂停 ( &lt;code&gt;XWUP_PM_STAGE_SUSPENDED&lt;/code&gt; )&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt; ：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt; ：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 &lt;strong&gt;空闲任务&lt;/strong&gt; 执行完上一阶段的 &lt;code&gt;suspend()&lt;/code&gt; 回调函数后，电源管理步骤切换到此阶段，并执行 &lt;code&gt;sleep()&lt;/code&gt; 回调函数。
SOC系统在 &lt;code&gt;sleep()&lt;/code&gt; 回调函数内部进入休眠状态，此时时钟停止，代码停止运行， &lt;code&gt;sleep()&lt;/code&gt; 回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将 &lt;code&gt;sleep()&lt;/code&gt; 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。
例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ &lt;code&gt;WFI&lt;/code&gt; ），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现， &lt;code&gt;wakeup()&lt;/code&gt; 回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数 &lt;code&gt;sleep()&lt;/code&gt; 与 &lt;code&gt;wakeup()&lt;/code&gt; 之间没有锁的保护，
因此 &lt;code&gt;sleep()&lt;/code&gt; 回调函数需要设计成能被 &lt;code&gt;wakeup()&lt;/code&gt; 回调函数打断。&lt;/p&gt;
&lt;h2 id=&#34;capi参考&#34;&gt;CAPI参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../../capi/group__xwos__pm.html&#34;&gt;&lt;strong&gt;头文件 &amp;lt;xwos/osal/pm.h&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 通用库</title>
      <link>/docs/TechRefManual/Xwlib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Xwlib/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: 系统间通讯机制</title>
      <link>/docs/TechRefManual/Isc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/Isc/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: C/C&#43;&#43;</title>
      <link>/docs/TechRefManual/C_C&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/TechRefManual/C_C&#43;&#43;/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
