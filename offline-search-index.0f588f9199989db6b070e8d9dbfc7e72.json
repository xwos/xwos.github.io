[{"body":"概述 XWOS的源码中，已包含了大部分ARM-Cortex-M架构的代码：\n架构描述层(ADL) ARMv7m: XWOS/xwcd/soc/arm/v7m ARMv6m: XWOS/xwcd/soc/arm/v6m CPU描述层(CDL) m0: XWOS/xwcd/soc/arm/v6m/m0 m0p: XWOS/xwcd/soc/arm/v6m/m0p m3: XWOS/xwcd/soc/arm/v7m/m3 m4: XWOS/xwcd/soc/arm/v7m/m4 m7: XWOS/xwcd/soc/arm/v7m/m7 SOC描述层(SDL) STM32: L0/F0: XWOS/xwcd/soc/arm/v7m/m0/stm32 L1/F1: XWOS/xwcd/soc/arm/v7m/m3/stm32 L4/F4: XWOS/xwcd/soc/arm/v7m/m4/stm32 F7/H7: XWOS/xwcd/soc/arm/v7m/m7/stm32 S32K: XWOS/xwcd/soc/arm/v7m/m4/s32k14x i.MX RT1052: XWOS/xwcd/soc/arm/v7m/m7/mimxrt1052 新的SOC芯片，只需在CPU文件夹中增加SOC文件夹，其中包括：\n初始化： soc_init.h 与 soc_init.c 中断： xwosimpl_irq.h 与 xwosimpl_irq.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/irq.h 中声明的函数的实现。 调度器： xwosimpl_skd.h 与 xwosimpl_skd.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/skd.h 中声明的函数的实现。 滴答定时器： xwosimpl_syshwt.h 与 xwosimpl_syshwt.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/syshwt.h 中声明的函数的实现。 .lds ：链接脚本 可以复制一个SDL文件夹（例如STM32）作为模板， 所有Cortex-M的单片机 XWOSIMPL 都是一样的。\n类型的定义 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_type.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_type.h 编译器的宏定义 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_compiler.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_compiler.h 无锁队列的实现 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_lfq.h XWOS/xwcd/soc/arm/v6m/xwosimpl_soc_lfq.c XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_lfq.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_lfq.c 自旋锁 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_spinlock.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_spinlock.h 架构指令 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_isa.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_isa.h 位操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwbop.h XWOS/xwcd/soc/arm/v6m/asmlib/xwbop/ XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwbop.h XWOS/xwcd/soc/arm/v7m/asmlib/xwbop/ XWOS/xwcd/soc/arm/v7m/asmlib/xwbmpop/ 8位原子操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwaop8.h XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xws8/ XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xwu8/ XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwaop8.h XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xws8/ XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xwu8/ 16位原子操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwaop16.h XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xws16/ XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xwu16/ XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwaop16.h XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xws16/ XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xwu16/ 32位原子操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwaop32.h XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xws32/ XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xwu32/ XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwaop32.h XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xws32/ XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xwu32/ 64位原子操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwaop64.h XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xws64/ XWOS/xwcd/soc/arm/v6m/asmlib/xwaop/xwu64/ XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwaop64.h XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xws64/ XWOS/xwcd/soc/arm/v7m/asmlib/xwaop/xwu64/ 位图原子操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_soc_xwbmpaop.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_xwbmpaop.h XWOS/xwcd/soc/arm/v7m/asmlib/xwbmpaop/ setjmp()/longjmp() XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v7m/xwosimpl_soc_setjmp.h XWOS/xwcd/soc/arm/v7m/xwosimpl_soc_setjmp.c C标准库中定义的 setjmp()/longjmp() 是可在不同函数之间跳转的 goto ， 有些libc的实现没有考虑浮点寄存器栈，因此XWOS重新实现了这两个函数。\n完整的栈结构如下： ----------------------------- sp+0x64 | s31 | | sp+0x60 | s30 | | sp+0x5C | s29 | | sp+0x58 | s28 | | sp+0x54 | s27 | | sp+0x50 | s26 | | sp+0x4C | s25 | FP | sp+0x48 | s24 | Frame | sp+0x44 | s23 | | sp+0x40 | s22 | | sp+0x3C | s21 | | sp+0x38 | s20 | | sp+0x34 | s19 | | sp+0x30 | s18 | | sp+0x2C | s17 | | sp+0x28 | s16 | | ----------------------------- sp+0x24 | r14 (lr) | | sp+0x20 | r13 (sp) | | sp+0x1C | r11 (fp) | | sp+0x18 | r10 (sl) | | sp+0x14 | r9 | Basic | sp+0x10 | r8 | Frame | sp+0x0C | r7 | | sp+0x08 | r6 | | sp+0x04 | r5 | | sp+0x00 | r4 | | ----------------------------- setjmp/longjmp寄存器栈结构 线程本地存储TLS TLS是C11标准开始引入的语言特性。XWOS支持TLS，Cortex-M的MCU采用统一实现：\nXWOS/xwcd/soc/arm/v6m/xwosimpl_tls.c XWOS/xwcd/soc/arm/v7m/xwosimpl_tls.c XWOS将TLS数据段放在线程栈内存起始的位置。\n------------------------ | Thread Stack Memmory | +----------------------+ SP ---\u003e | | | | | | | | | | | | | Stack Region | | | | | | | | | | | | | +----------------------+ | | | Stack Guard | | | +----------------------+ | | | TLS Region | | | ------------------------ 调度器 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_soc_skd.h XWOS/xwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_soc_skd.c XWOS/xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_soc_skd.h XWOS/xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_soc_skd.c 由于基于Cortex-M内核的单片机一致性比较好，所以不同的单片机最终都是调用下面文件中的函数来给出具体实现：\nXWOS/xwcd/soc/arm/v6m/arch_skd.h XWOS/xwcd/soc/arm/v6m/arch_skd.c XWOS/xwcd/soc/arm/v7m/arch_skd.h XWOS/xwcd/soc/arm/v7m/arch_skd.c 线程的栈 XWOS在ARMv6/7-m平台的实现上，使用 8字节对齐 的栈， 因此必须在芯片初始化的最早阶段将CCR寄存器中的STKALIGN设置为1： cm_scs.scb.ccr.bit.stkalign = 1; 使用满递减栈，即配置文件 cfg/xwos.h 中 XWMMCFG_FD_STACK 配置为 1 ： 当CPU中包含浮点单元时，开启浮点上下文自动保存与恢复，即 cm_scs.scb.fpu.fpccr.bit.aspen = 1; 线程的栈结构 C语言一般将寄存器分为两部分：易失性的(volatile)和非易失性的(non-volatile)。 当使用到易失性(volatile)寄存器时不需要保存值和恢复； 当使用到非易失性(non-volatile)寄存器时需要保存值和恢复。\n易失性(volatile)栈结构 ARMv6/v7-m的CPU，从线程模式进入中断模式时，会自动将易失性(volatile)寄存器保存到栈中。\n------------------------ | Prev Frame | +------------+---------+ sp+0x3C | | | sp+0x38 | FPSCR | | sp+0x3C | s15 | | sp+0x38 | s14 | | sp+0x34 | s13 | | sp+0x30 | s12 | | sp+0x2C | s11 | | sp+0x28 | s10 | | sp+0x24 | s9 | FP | sp+0x20 | s8 | Frame | sp+0x3C | s7 | | sp+0x38 | s6 | | sp+0x34 | s5 | | sp+0x30 | s4 | | sp+0x2C | s3 | | sp+0x28 | s2 | | sp+0x24 | s1 | | sp+0x20 | s0 | | ------------------------ sp+0x1C | xpsr | | sp+0x18 | pc | | sp+0x14 | lr | | sp+0x10 | r12 (ip) | Basic | sp+0x0C | r3 | Frame | sp+0x08 | r2 | | sp+0x04 | r1 | | sp+0x00 | r0 | | ------------------------ 易失性(volatile)寄存器栈结构 非易失性(non-volatile)栈结构 编译器能自动处理非易失性(non-volatile)寄存器，因此在同一个上下文中恢复环境，不需要 保存非易失性(non-volatile)寄存器。但当操作系统切换任务时，不同的任务的 非易失性(non-volatile)寄存器环境是不一样的，需要进行保存与恢复。\nXWOS在ARMv6/7-m平台上的非易失性(non-volatile)寄存器栈结构如下：\n----------------------------- | Volatile stack Frame | +-----------------+---------+ sp+0x64 | s31 | | sp+0x60 | s30 | | sp+0x5C | s29 | | sp+0x58 | s28 | | sp+0x54 | s27 | | sp+0x50 | s26 | | sp+0x4C | s25 | FP | sp+0x48 | s24 | Frame | sp+0x44 | s23 | | sp+0x40 | s22 | | sp+0x3C | s21 | | sp+0x38 | s20 | | sp+0x34 | s19 | | sp+0x30 | s18 | | sp+0x2C | s17 | | sp+0x28 | s16 | | ----------------------------- sp+0x24 | lr (EXC_RETURN) | | sp+0x20 | r11 (fp) | | sp+0x1C | r10 (sl) | | sp+0x18 | r9 | | sp+0x14 | r8 | Basic | sp+0x10 | r7 | Frame | sp+0x0C | r6 | | sp+0x08 | r5 | | sp+0x04 | r4 | | sp+0x00 | CONTROL | | ----------------------------- 非易失性(non-volatile)寄存器栈结构 中断 XWOS移植实现层的 Adaptee 位于：\nxwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_irq.h xwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_irq.c xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_irq.h xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_irq.c 滴答定时器 XWOS移植实现层的 Adaptee 位于：\nxwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_syshwt.h xwcd/soc/arm/v6m/[CPU]/[SOC]/xwosimpl_syshwt.c xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_syshwt.h xwcd/soc/arm/v7m/[CPU]/[SOC]/xwosimpl_syshwt.c ","categories":"","description":"","excerpt":"概述 XWOS的源码中，已包含了大部分ARM-Cortex-M架构的代码：\n架构描述层(ADL) ARMv7m: …","ref":"/docs/Note/SOC/ARM-M/","tags":"","title":"ARM-Cortex-M移植说明"},{"body":"概述 XWOS的源码中，已包含了大部分ARM64-Cortex-A架构的代码：\n架构描述层(ADL) ARMv8a: XWOS/xwcd/soc/arm/v8a CPU描述层(CDL) m0: XWOS/xwcd/soc/arm/v8a/a72 m0p: XWOS/xwcd/soc/arm/v8a/a76_a55 SOC描述层(SDL) UNISOC UIS7870: XWOS/xwcd/soc/arm/v8a/a76_a55/uis7870 树莓派4B SOC: XWOS/xwcd/soc/arm/v8a/a72/bcm2711 新的SOC芯片，只需在CPU文件夹中增加SOC文件夹，其中包括：\n初始化： soc_init.h 与 soc_init.c 中断： xwosimpl_irq.h 与 xwosimpl_irq.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/irq.h 中声明的函数的实现。 调度器： xwosimpl_skd.h 与 xwosimpl_skd.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/skd.h 中声明的函数的实现。 滴答定时器： xwosimpl_syshwt.h 与 xwosimpl_syshwt.c 其中需要给出XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/syshwt.h 中声明的函数的实现。 .lds ：链接脚本 类型的定义 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/type.h 要求SOC给出标准类型的定义：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_type.h 编译器的宏定义 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_compiler.h gcc: XWOS/xwcd/soc/arm/v8a/compiler/gcc.h llvm: XWOS/xwcd/soc/arm/v8a/compiler/llvm.h 无锁队列的实现 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_lfq.h XWOS/xwcd/soc/arm/v8a/xwosimpl_soc_lfq.c 自旋锁 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_spinlock.h 架构指令 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_isa.h 位操作 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwbop.h XWOS/xwcd/soc/arm/v8a/xwbop/ 8位原子操作 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/xwaop8.h 要求SOC在汇编指令层面给出单字节原子操作的实现：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwaop8.h XWOS/xwcd/soc/arm/v8a/xwaop/xwaops8.c XWOS/xwcd/soc/arm/v8a/xwaop/xwaopu8.c 16位原子操作 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/xwaop16.h 要求SOC在汇编指令层面给出双字节原子操作的实现：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwaop16.h XWOS/xwcd/soc/arm/v8a/xwaop/xwaops16.c XWOS/xwcd/soc/arm/v8a/xwaop/xwaopu16.c 32位原子操作 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/xwaop32.h 要求SOC在汇编指令层面给出4字节原子操作的实现：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwaop32.h XWOS/xwcd/soc/arm/v8a/xwaop/xwaops32.c XWOS/xwcd/soc/arm/v8a/xwaop/xwaopu32.c 64位原子操作 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/xwaop64.h 要求SOC在汇编指令层面给出8字节原子操作的实现：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwaop64.h XWOS/xwcd/soc/arm/v8a/xwaop/xwaop64.c XWOS/xwcd/soc/arm/v8a/xwaop/xwaopu64.c 位图原子操作 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/soc/xwbmpaop.h 要求SOC在汇编指令层面给出位图原子操作的实现：\nXWOS/xwcd/soc/arm/v8a/xwosimpl_soc_xwbmpaop.h XWOS/xwcd/soc/arm/v8a/xwbmpaop/ 系统初始化 SPSel 设置为 1 ，不同EL等级使用不同的SP寄存器\nSCTLR_EL1.EE = 0 ：选择小端格式\nSCTLR_EL1.SA = 1 ：开启stack对齐检测\nSCTLR_EL1.A = 0 ：关闭对齐检测，对齐检测经常导致进sync异常\nSCTLR_EL1.C = 1 ：开启数据缓存\nSCTLR_EL1.I = 1 ：开启指令缓存\nSCTLR_EL2.EE = 0 ：选择小端格式\nSCTLR_EL2.SA = 1 ：开启stack对齐检测\nSCTLR_EL2.A = 0 ：关闭对齐检测，对齐检测经常导致进sync异常\nSCTLR_EL2.C = 1 ：开启数据缓存\nSCTLR_EL2.I = 1 ：开启指令缓存\nCPACR_EL1.FPEN = 0b11 ：开启浮点单元\n暂时不启用虚拟化\nHCR_EL2.VM = 0 HCR_EL2.TGE = 0\n中断 XWOS移植实现层的 Adaptee 位于：\nXWOS/xwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_irq.h XWOS/xwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_irq.c 不在EL3响应异常 SCR_EL3.FIQ = 0 SCR_EL3.IRQ = 0 HCR_EL3.EA = 0 HCR_EL3.HCE = 1 开启 HVC 指令\nCPTR_EL3 中关闭trap\nCPTR_EL2 中关闭trap\n在EL2中处理中断\nHCR_EL2.AMO = 1 HCR_EL2.IMO = 1 HCR_EL2.FMO = 1\n注意：\nSync, FIQ，IRQ，SError全部在 EL1 执行； EL1中执行 HVC 指令时才会跑到 EL2\nHVC HVC 不能在EL0执行； HVC 不能在Secure的EL1中执行 SCR_EL3.HCE == 1 时才能使用 HVC SVC SVC 在EL0中执行时，在EL1处理异常 SVC 在EL1中执行时，在EL1处理异常 当 HCR_EL2.TGE == 1 时， SVC 无论在EL0还是EL1，都会升级到EL2执行； SMC SMC 不能在EL0中执行 HCR_EL2.TSC == 1 时， SMC 在EL2执行 SCR_EL3.SMD == 1 时， SMC 指令才能使用 调度器 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/skd.h 要求SOC给出调度器切换上下文等操作的实现，各个型号的MCU采用不同的实现：\nXWOS/xwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_soc_skd.h XWOS/xwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_soc_skd.c 由于基于Cortex-M内核的单片机一致性比较好，所以不同的单片机最终都是调用下面文件中的函数来给出具体实现：\nXWOS/xwcd/soc/arm/v8a/arch_skd.h XWOS/xwcd/soc/arm/v8a/arch_skd.c XWOS内核运行在EL2，使用sp_el2\n线程 线程运行在 EL1H ，不支持EL0的线程。\n栈 按照AAPCS64的要求，使用 16字节对齐 的 满递减 栈， 因此配置文件 cfg/xwos.h XWMMCFG_FD_STACK 配置为 1 XWMMCFG_ALIGNMENT 配置为 16U 栈结构 +------------+-----------------------------+ sp+0x31c | reserved | | sp+0x318 | reserved | | sp+0x314 | reserved | | sp+0x310 | FPSR | volatile (caller-saved) | +------------+-----------------------------+ sp+0x300 | q31 | volatile (caller-saved) | sp+0x2F0 | q30 | volatile (caller-saved) | sp+0x2E0 | q29 | volatile (caller-saved) | sp+0x2D0 | q28 | volatile (caller-saved) | sp+0x2C0 | q27 | volatile (caller-saved) | sp+0x2B0 | q26 | volatile (caller-saved) | sp+0x2A0 | q25 | volatile (caller-saved) | sp+0x290 | q24 | volatile (caller-saved) | sp+0x280 | q23 | volatile (caller-saved) | sp+0x270 | q22 | volatile (caller-saved) | sp+0x260 | q21 | volatile (caller-saved) | sp+0x250 | q20 | volatile (caller-saved) | sp+0x240 | q19 | volatile (caller-saved) | sp+0x230 | q18 | volatile (caller-saved) | sp+0x220 | q17 | volatile (caller-saved) | sp+0x210 | q16 | volatile (caller-saved) | +------------+-----------------------------+ sp+0x200 | q15 | non-volatile (callee-saved) | sp+0x1F0 | q14 | non-volatile (callee-saved) | sp+0x1E0 | q13 | non-volatile (callee-saved) | sp+0x1D0 | q12 | non-volatile (callee-saved) | sp+0x1C0 | q11 | non-volatile (callee-saved) | sp+0x1B0 | q10 | non-volatile (callee-saved) | sp+0x1A0 | q9 | non-volatile (callee-saved) | sp+0x190 | q8 | non-volatile (callee-saved) | +------------+-----------------------------+ sp+0x180 | q7 | volatile (caller-saved) | sp+0x170 | q6 | volatile (caller-saved) | sp+0x160 | q5 | volatile (caller-saved) | sp+0x150 | q4 | volatile (caller-saved) | sp+0x140 | q3 | volatile (caller-saved) | sp+0x130 | q2 | volatile (caller-saved) | sp+0x120 | q1 | volatile (caller-saved) | sp+0x110 | q0 | volatile (caller-saved) | +------------+-----------------------------+ sp+0x108 | pstate | volatile (caller-saved) | sp+0x100 | pc | volatile (caller-saved) | sp+0xF8 | sp | volatile (caller-saved) | sp+0xF0 | lr | volatile (caller-saved) | ---------+------------+-----------------------------+ sp+0xE8 | x29 | non-volatile (callee-saved) | sp+0xE0 | x28 | non-volatile (callee-saved) | sp+0xD8 | x27 | non-volatile (callee-saved) | sp+0xD0 | x26 | non-volatile (callee-saved) | sp+0xC8 | x25 | non-volatile (callee-saved) | sp+0xC0 | x24 | non-volatile (callee-saved) | sp+0xB8 | x23 | non-volatile (callee-saved) | sp+0xB0 | x22 | non-volatile (callee-saved) | sp+0xA8 | x21 | non-volatile (callee-saved) | sp+0xA0 | x20 | non-volatile (callee-saved) | sp+0x98 | x19 | non-volatile (callee-saved) | sp+0x90 | x18 | non-volatile (callee-saved) | ---------+------------+-----------------------------+ sp+0x88 | x17 | volatile (caller-saved) | sp+0x80 | x16 | volatile (caller-saved) | sp+0x78 | x15 | volatile (caller-saved) | sp+0x70 | x14 | volatile (caller-saved) | sp+0x68 | x13 | volatile (caller-saved) | sp+0x60 | x12 | volatile (caller-saved) | sp+0x58 | x11 | volatile (caller-saved) | sp+0x50 | x10 | volatile (caller-saved) | sp+0x48 | x9 | volatile (caller-saved) | sp+0x40 | x8 | volatile (caller-saved) | sp+0x38 | x7 | volatile (caller-saved) | sp+0x30 | x6 | volatile (caller-saved) | sp+0x28 | x5 | volatile (caller-saved) | sp+0x20 | x4 | volatile (caller-saved) | sp+0x18 | x3 | volatile (caller-saved) | sp+0x10 | x2 | volatile (caller-saved) | sp+0x08 | x1 | volatile (caller-saved) | sp+0x00 | x0 | volatile (caller-saved) | -------------------------------------------- 说明：x18寄存器按照官方手册描述，应该为 caller-saved ， 但Linux内核将此寄存器用作 ShadowCallStack 的指针（配置 CONFIG_SHADOW_CALL_STACK 为 y 时）， 此时x18应该为 callee-saved 的。 XWOS和Linux保持一致，因此x18也为 callee-saved 。 需要增加编译选项 -ffixed-x18 。 滴答定时器 XWOS内核移植层(XWOSPL) XWOS/xwos/ospl/syshwt.h 要求SOC给出滴答定时器的实现，各个型号的MCU采用不同的实现：\nxwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_soc_syshwt.h xwcd/soc/arm/v8a/[CPU]/[SOC]/xwosimpl_soc_syshwt.c ","categories":"","description":"","excerpt":"概述 XWOS的源码中，已包含了大部分ARM64-Cortex-A架构的代码：\n架构描述层(ADL) ARMv8a: …","ref":"/docs/Note/SOC/ARM64-A/","tags":"","title":"ARM-Cortex-M移植说明"},{"body":"概述 GD32V相关的代码：\n架构描述层(ADL)： XWOS/xwcd/soc/riscv/nuclei/gcc CPU描述层(CDL)： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee SOC描述层(SDL) GD32V： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v 启动流程 程序入口： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_boot 中断 采用 非向量模式 ，统一的入口： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_isr_entry 使用RISC-V标准寄存器 mscratch 来实现ARM-Cortex-M类似的双栈结构的工作方式 异常统一的入口 XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_esr_entry 源码： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_soc_irq.h XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.h XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.c XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S 调度 源码： XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.h XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.c XWOS/xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosasmimpl_skd.S 栈结构 RISC-V要求栈必须按 16字节 对齐； RISC-V只使用 满递减栈 ； RISC-V的ABI文档中将寄存器分为两类：caller-saved (即volatile)和callee-saved (即non-volatile) 。 caller-saved栈结构 从线程进入中断时，中断入口程序会自动将caller-saved寄存器保存到栈中：\n* __caller-saved (volatile) context__ * 19 * 4 t6 (x31) ---------- * 18 * 4 t5 (x30) | * 17 * 4 t4 (x29) | * 16 * 4 t3 (x28) | * 15 * 4 a7 (x17) | * 14 * 4 a6 (x16) | * 13 * 4 msubm --------+ | * 12 * 4 mepc | | * 11 * 4 mcause | | * 10 * 4 mscratch | | * 9 * 4 a5 (x15) | RV32I * 8 * 4 a4 (x14) | | * 7 * 4 a3 (x13) | | * 6 * 4 a2 (x12) RV32E | * 5 * 4 a1 (x11) | | * 4 * 4 a0 (x10) | | * 3 * 4 t2 (x7) | | * 2 * 4 t1 (x6) | | * 1 * 4 t0 (x5) | | * 0 * 4 ra (x1) | | * __caller-saved (volatile) context__ callee-saved栈结构 切换上下文时，需要保存与恢复callee-saved寄存器栈结构如下：\n* __callee-saved (non-volatile) context__ * 13 * 4 s11 (x27) | * 12 * 4 s10 (x26) | * 11 * 4 s9 (x25) | * 10 * 4 s8 (x24) | * 9 * 4 s7 (x23) | * 8 * 4 s6 (x22) | * 7 * 4 s5 (x21) RV32I * 6 * 4 s4 (x20) | * 5 * 4 s3 (x19) | * 4 * 4 s2 (x18) | * 3 * 4 mstatus ------+ | * 2 * 4 s1 (x9) | | * 1 * 4 s0 (x8) RV32E | * 0 * 4 tp (x4) | | * __callee-saved (non-volatile) context__ 滴答定时器 使用RISC-V标准中定义的定时器来产生滴答中断。 源码： xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.h xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.c TLS TLS是C11标准开始引入的语言特性。XWOS支持TLS：\nXWOS/xwcd/soc/riscv/nuclei/xwosimpl_tls.c XWOS将TLS数据段放在线程栈内存起始的位置。\n------------------------ | Thread Stack Memmory | +----------------------+ SP ---\u003e | | | | | | | | | | | | | Stack Region | | | | | | | | | | | | | +----------------------+ | | | Stack Guard | | | +----------------------+ | | | TLS Region | | | ------------------------ RISC-V有专门用于TLS的寄存器x4(tp)，在线程初始化时，需要让x4指向TLS的起始位置。 切换上下文时也要切换x4的值。\n","categories":"","description":"","excerpt":"概述 GD32V相关的代码：\n架构描述层(ADL)： XWOS/xwcd/soc/riscv/nuclei/gcc CPU描述层(CDL)： …","ref":"/docs/Note/SOC/RISC-V/GD32V/","tags":"","title":"GD32V移植说明"},{"body":"格式 # [标题] \u003ctype\u003e(\u003cscope\u003e): :emoji: \u003csubject\u003e # - type: feat, fix, perf, refactor, style, revert, docs, test, ci, # chore, milestone, release, revision, alpha, beta, rc # - scope: 可为空 # - subject: 以动词开始的短语，结尾无句号 # - 页眉只占一行 # - 每行总长度不超过72个字符（中文字符计2个字符） # # [正文] 描述 # - 为什么需要修改？ # - 如何定位问题？ # - 修改有什么副作用？ # - 每行总长度不超过72个字符（中文字符计2个字符） # # [脚注] \u003ctoken:\u003e \u003ctext\u003e # - 问题的ID或链接 # - BREAKING-CHANGE（破坏性修改） # - 每行总长度不超过72个字符（中文字符计2个字符） 参考：https://www.conventionalcommits.org/\ngit-commit-message格式规则 标题 标题信息必须以一个可选的 类别(type) 作为前缀， 类别(type) 后面可以跟一个可选的 范围描述词(scope) ， 范围描述词(scope) 需要放在英文的小括号内，之后可再跟一个可选的英文的 ! 表示有 BREAKING CHANGE 发生； 类别(type) 说明 feat: 新功能 emoji 新增 :sparkles: 移除 :fire: 配置相关 :wrench: 升级依赖 :arrow_up: 新增待改进的代码 :poop: 新增.o或.a文件 :package: fix: 修复BUG emoji 修复重大BUG :ambulance: 修复BUG :bug: 修复警告 :rotating_light: 修复安全问题 :lock: perf: 性能优化 emoji 性能优化 :zap: :racehorse: 移除死代码 :coffin: refactor: 重构代码 emoji 重大重构 :hammer: 新增 :sparkles: 重构 :recycle: 移除 :fire: 配置相关 :wrench: 破坏性修改 :boom: 增加log :loud_sound: 移除log :mute: 调整路径 :truck: 依赖的第三方软件更新导致的API更新 :alien: style: 格式调整（删除行尾空格等） emoji :art: revert: 回退提交 emoji 回退代码 :rewind: 降级依赖 :arrow_down: docs: 文档 emoji 增加文档 :memo: 修改.md文档 :book: 修改源码中的注释 :bulb: test: 测试 emoji 增加测试 :white_check_mark: 增加反向测试（导致错误的测试） :test_tube: ci: 系统集成 emoji :construction_worker: chore: 其他未归类的零碎事务 emoji 配置相关 :wrench: 分支合并 :twisted_rightwards_arrows: milestone: 发布大版本 emoji :bookmark: release: 发布小版本 emoji :bookmark: revision: 发布修订版 emoji :bookmark: alpha: 发布alpha版本 emoji :bookmark: beta: 发布beta版本 emoji :bookmark: rc: 发布rc版本 emoji :bookmark: 标题中的 主题(subject) 与 类别(type) 之间需要增加一个冒号 : 与一个空格 ，然后增加emoji符号，在间隔一个空格 ； 标题的最后不能有标点符号； 标题只能占一行； BREAKING CHANGE 是指 API原型修改 API删除 正文 正文与标题间需要空一行； 脚注 脚注与正文间需要空一行； 每一项脚注需要有一个单词作为 令牌(token) ， 格式可以是 令牌(token) 后面跟一个 : 和一个空格 作为间隔，例如： token: 格式也可以是 令牌(token) 后面跟一个空格 和 # 作为间隔，例如： token: 脚注可以有多行内容，直到遇到新的**令牌(token)**为止； 脚注的行与行之间无空行； 字符集规则 全部使用 utf-8 字符集。\n设置方法 增加环境变量 export LESSHARESET=utf-8 设置字符集 git config i18n.commitencoding utf-8 # 设置提交日志使用utf-8 git config i18n.logoutputencoding utf-8 # 设置输出日志时使用utf-8 git config core.quotepath false # 中文路径使用utf-8 git config gui.encoding utf-8 # 图形界面使用utf-8 行尾空格规则 原则上，使用 \\n（LF）作为换行符，但自动生成的代码可不遵守这个规则。\nWindows NTFS文件系统的文件权限问题 NTFS文件系统下，会导致文件的mode变为100644，且chmod无法修改， 可修改git配置忽略文件模式的变更。\ngit config core.filemode false ","categories":"","description":"XWOS的git-commit-msg规范\n","excerpt":"XWOS的git-commit-msg规范\n","ref":"/docs/Standard/GitMsg/","tags":"","title":"git-msg规范"},{"body":"XWOS/xwos 内核对libc的依赖 string.h：依赖 memset() 、 memcpy() ； stdlib.h 当配置了 XWOSCFG_SKD_THD_STDC_MM 、 XWOSCFG_SKD_SWT_STDC_MM 、 XWOSCFG_SYNC_SEM_STDC_MM 、 XWOSCFG_SYNC_COND_STDC_MM 、 XWOSCFG_SYNC_EVT_STDC_MM 或 XWOSCFG_LOCK_MTX_STDC_MM 时， 依赖 malloc() 和 free() 函数动态创建和删除对象； inttypes.h 、 stdint.h 、 stddef.h ：XWOS的基本类型基于标准C的基本类型进行定义； stdbool.h：依赖bool类型的定义； stdatomic.h：依赖原子操作内存屏障的定义； stdarg.h 若 XWLIBCFG_SC 配置为 1 ， xwos/lib/sc.h 需要使用变参函数； 若 XWLIBCFG_LOG 配置为 1， xwos/lib/xwlog.c 需要使用变参函数； stdio.h：若 XWLIBCFG_LOG 配置为 1， xwos/lib/xwlog.c 中格式化日志依赖 vsnprintf() 。 XWOS/xwmd 提供的对libc的支持 动态内存管理 stdlib.h malloc() free() cfree() realloc() calloc() memalign() aligned_alloc() valloc() pvalloc() 根据配置中选择的libc：\n当 XWCFG_LIBC 配置为 newlib 时，这些函数由 xwmd/libc/newlibac/mem.c 提供底层支持， 并覆盖了newlib中原有的实现。 xwmd/libc/newlibac/mem.c 中的实现是对 mempool 的封装， mempool 需要在 board_init() 中选择内存设备进行初始化后才可使用，并且需要提供 newlibac_mempool 定义才可使用 stdlib.h 的函数。 当 XWCFG_LIBC 配置为 picolibc 时，这些函数由 xwmd/libc/picolibcac/mem.c 提供底层支持， 并覆盖了picolibc中原有的实现。 xwmd/libc/picolibcac/mem.c 中的实现是对 mempool 的封装， mempool 需要在 board_init() 中选择内存设备进行初始化后才可使用，并且需要提供 picolibcac_mempool 定义才可使用 stdlib.h 的函数。 newlibac_mempool 或 picolibcac_mempool 需要BSP中提供定义，不同的工程情况不一致，XWOS项目组提供几个示例工程， 可以参考工程的 README.md 中的 libc 章节获得说明：\nATKSTM32F407ZXWOS：正点原子F407核心板 EmbedFireStm32H743XWOS：野火STM32H743-Pro开发板 AtkApolloH743XWOS：正点原子阿波罗STM32H743开发板 FK429M1XWOS：反客STM32F429-M1开发板 WeActMiniStm32H750XWOS：微行电子MiniStm32H750开发板 setjmp()/longjmp() setjmp() 和 longjmp() 函数对可实现在不同函数间的 goto 。 用户应该使用头文件 xwos/lib/setjmp.h 中代替标准C的头文件 setjmp.h ， 并且也应该使用 xwlib_setjmp() 与 xwlib_longjmp() 函数对代替 setjmp()/longjmp() 函数 setjmp() 和 longjmp() 函数对。\n此外，setjmp()/longjmp() 在 MISRA-C2012标准中被禁止使用。\nerrno XWOS重构了 errno 的实现，将 errno 改为每个线程的私有变量， 线程访问 errno 时，只会访问自己的 errno 。 用户应该使用 xwos/lib/errno.h 替代libc中的 errno.h 。\n根据配置中选择的libc：\n当 XWCFG_LIBC 配置为 newlib 时， errno 的实现位于 xwmd/libc/newlibac/errno.c ； 当 XWCFG_LIBC 配置为 picolibc 时， errno 的实现位于 xwmd/libc/picolibcac/errno.c 。 文件操作 头文件 stdio.h fopen() fclose() fread() fwrite() fseek() remove() rename() 根据配置中选择的libc：\n当 XWCFG_LIBC 配置为 newlib 时，这些函数由 xwmd/libc/newlibac/fops.c 提供底层支持， xwmd/libc/newlibac/fops.c 又依赖第三方软件 xwem/fs/fatfs ； 当 XWCFG_LIBC 配置为 picolibc 时，这些函数由 xwmd/libc/picolibcac/fops.c 提供底层支持， xwmd/libc/picolibcac/fops.c 又依赖第三方软件 xwem/fs/fatfs 。 FatFs需要BSP中提供对块设备操作的支持，不同的电路板对文件操作的支持情况不一致，XWOS项目组提供几个示例工程， 可以参考工程的 README.md 中的 FatFS 章节获得说明：\nATKSTM32F407ZXWOS：正点原子F407核心板 EmbedFireStm32H743XWOS：野火STM32H743-Pro开发板 AtkApolloH743XWOS：正点原子阿波罗STM32H743开发板 FK429M1XWOS：反客STM32F429-M1开发板 WeActMiniStm32H750XWOS：微行电子MiniStm32H750开发板 TLS TODO\nstdatomic TODO\n数学库 若SOC有FPU，并且配置 ARCHCFG_FPU 为 1 ，则支持 libm 。\n其他libc的功能 ctype: 字符类型 wchar: 多字节字符 iconv: 字符集转换 locale: 区域，暂时不支持 search: 查找 argz: 字符串数组 time: 时间，暂时不支持，需要底层提供RTC的驱动 ","categories":["XWOS"],"description":"","excerpt":"XWOS/xwos 内核对libc的依赖 string.h：依赖 memset() 、 memcpy() ； stdlib.h …","ref":"/docs/TechRefManual/C_C++/Libc/","tags":"","title":"Libc"},{"body":"编译配置 编译newlib时，需要增加配置 --enable-newlib-multithread 开启多线程的支持，默认是开启的。\n_reent结构体 Newlib中的头文件 reent.h 中，定义了结构体struct _reent ，用于支持多线程：\n默认情况下，Newlib定义了一个全局的结构体变量 impure_data ， 此结构体定义在 newlib/libc/reent/impure.c ，并使用宏 _REENT 表示它； struct _reent 定义了一些C标准的变量，例如 errno 、 stdin 、 stdout 、 stderr 等； 为了支持多线程访问各自的 errno 、 stdin 、 stdout 和 stderr 等，需要在 线程对象结构体中增加结构体 struct _reent 的成员； 由于 struct _reent 体积过大，玄武OS自己将实现 struct _reent ； Newlib中除了提供C标准中的函数，还定义带后缀 _r 版本的函数，例如 _read_r() ， 其中多一个参数 struct _reent * 用于区分不同的线程。 ","categories":"","description":"","excerpt":"编译配置 编译newlib时，需要增加配置 --enable-newlib-multithread 开启多线程的支持，默认是开启的。 …","ref":"/docs/Note/Newlib/MultiThread/","tags":"","title":"多线程"},{"body":"介绍 由于ST官方的STM32CubeMX能自动生成初始化芯片的代码，因此 XWOS中STM32的 架构描述层(ADL) 、 CPU描述层(CDL) 、 SOC描述层(SDL) 的代码几乎 是一致的，唯一区别是 链接脚本。\n链接脚本 STM32的链接脚本也是按照可复用的方式设计的，分为两部分：\nSDL中的链接脚本：描述各个段如何分布在镜像文件中 STM32F0：XWOS/xwcd/soc/arm/v7m/m0/stm32/f0.lds STM32G0：XWOS/xwcd/soc/arm/v7m/m0p/stm32/g0.lds STM32F1：XWOS/xwcd/soc/arm/v7m/m3/stm32/f1.lds STM32L1：XWOS/xwcd/soc/arm/v7m/m3/stm32/l1.lds STM32F4：XWOS/xwcd/soc/arm/v7m/m4/stm32/f4.lds STM32L4：XWOS/xwcd/soc/arm/v7m/m4/stm32/l4.lds STM32F7：XWOS/xwcd/soc/arm/v7m/m7/stm32/f7.lds STM32H7：XWOS/xwcd/soc/arm/v7m/m7/stm32/h7.lds 其他SOC还在持续增加中… 电路板目录中的链接脚本：只描述内存区域 WeActMiniStm32H750工程： XWOS/xwbd/WeActMiniStm32H750/cfg/brd.lds WeActMiniStm32H750Bootloader工程： XWOS/xwbd/WeActMiniStm32H750Bootloader/cfg/brd.lds 其他电路板还在持续增加中… 不同的电路板工程，只有Board中链接脚本中的Memory区域不同。\nlds的基本语法 定义存储器区域 名字 (属性): org = xxx, len = xxx o , org , ORIGIN : 表示定义存储器的起始地址 l , len , LENGTH : 表示定义存储器长度 ORIGIN(x) : 表示取存储器x的起始地址 LENGTH(x) : 表示取存储器x的长度 属性: r 表示读， w 表示写， a 表示可申请， x 表示可执行 xxx_ivt_lmr \u0026 xxx_ivt_vmr XWOS的中断向量表区域，其中 LMR 表示中断向量的加载地址区域， 也即是中断向量在Flash中的存储位置，VMR表示中断向量的运行地址区域， 也即是上电运行时的中断向量的地址。\n如果 LMR 与 VMR 都指向Flash，且起始地址(org)与大小(len)完全一致，表示加载地址 就是运行地址，XWOS在初始化阶段不会对中断向量执行拷贝操作； 如果 VMR 指向RAM的某个地址，XWOS会在初始化阶段把Flash中的中断向量表拷贝到 VMR 指定的RAM内，并设置ARM的VTOR寄存器； 需要注意ARM的VTOR寄存器低7位(0~6)必须保持为0，因此VMR的起始地址也必须满足 此规则。 firmware_info_mr 此段中包含镜像文件的一些基本信息，例如起始位置，结尾标志位置等，可用在升级固件功能中。\ncode_mr 存放代码和常量的地方。\nxwos_data_mr 存放xwos全局数据的地方，这些变量在定义时带有修饰符： __xwos_data ，此段可以 不存在，若不存在，需要在SDL中的链接脚本中将此段的数据放到 data_mr 中。\ndata_mr 存放全局变量的地方。当连接器ld安排完全局变量后，剩余的部分会交给XWOS 的默认的内核内存分配器进行管理，用于为动态创建内核对象的API提供动态内存申请的接口。\nxwos_stk_mr XWOS内核的栈内存，XWOS内核处理中断时会使用此内存作为函数的栈。\nSOC的初始化 STM32CubeMX生成的初始化代码，分别由 stm32cube_lowlevel_init() 与 stm32cube_init() 执行， 这两个函数在 启动流程中分别 被 xows_preinit 与 xwos_postinit() 调用。\nSTM32CubeMX STM32CubeMX工程是以 玄武模块 中的 电路板模块 的方式进行集成的， 详细可参考 构建系统。\n各个工程的STM32CubeMX工程如下（可在STM32CubeMX中打开）：\nWeActMiniStm32H750工程： XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube/WeActMiniStm32H750.ioc WeActMiniStm32H750Bootloader工程： XWOS/xwbd/WeActMiniStm32H750Bootloader/bm/stm32cube/WeActMiniStm32H750Bootloader.ioc 中断优先级 XWOS对中断优先级的要求： 切换上下文的中断为系统中最低优先级中断 切换上下文的中断 \u003c= 滴答定时器的中断 \u003c= 调度器服务中断 NVIC设置 设置 3 个抢占优先级位和 1 个子优先级位； SVC中断设置成 最高 优先级，即 Preemption Priority 为 0 ； PendSV中断设置成 最低 优先级，即 Preemption Priority 为 7 ； Systick中断设置成 最低 优先级，即 Preemption Priority 为 7 ； 系统Fault的优先级设置为 0 ； 其他中断的优先级只可在 1~6 之间。 中断向量表 STM32CubeMX生成的代码中断向量表是放在 startup.s 中，XWOS并不使用这个文件，因此需要 另外增加中断向量表。STM32型号太多，一个一个编辑工作量巨大，但观察STM32寄存器定义的 头文件（例如： stm32h750xx.h ），可以发现 IRQn_Type 这个枚举类型，其中列举了 所有的中断号，因此可使用脚本自动生成中断向量表的代码。\n本项目中提供了一个Emacs-Lisp脚本 XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube/Tools/stm32ivt/stm32ivt.el 来完成这项工作， 用法：\ncd XWOS/xwbd/WeActMiniStm32H750/bm/stm32cube stm32ivt/stm32ivt.el 脚本执行完成后，会生成 Core/Src/ivt.c 。 xwac 电路板模块 xwac 是适配性质的代码，是连接BSP与XWOS的纽带。 文件夹名中的 ac 是 Adaptation Code 的缩写。\nfatfs ：fatfs底层设备驱动 lua ：lua的内存池 newlib ：为标准C库newlib提供底层的支持 mem.c ： malloc() 系列函数的内存池 stdio.c ：定义 stdin 的输入设备， stdout 、 stderr 的输出设备 picolibc ：为标准C库picolibc提供底层的支持 mem.c ： malloc() 系列函数的内存池 stdio.c ：定义 stdin 的输入设备， stdout 、 stderr 的输出设备 xwds ：STM32的设备栈 xwlib ：为XWOS通用库提供底层硬件支持，例如使用硬件CRC模块加速CRC运算、定义Log的输出设备等 xwos ：XWOS内核的Hook函数 xwrust ：Rust的内存池 ","categories":"","description":"","excerpt":"介绍 由于ST官方的STM32CubeMX能自动生成初始化芯片的代码，因此 XWOS中STM32的 架构描述层(ADL) 、 CPU描述 …","ref":"/docs/Note/SOC/ARM-M/STM32/","tags":"","title":"STM32移植说明"},{"body":"概述 线程本地存储(TLS)是指线程私有的变量。\nC11标准开始支持线程本地存储，并引入 _Thread_local 关键字，C2X标准引入 thread_local 关键字。 gcc以及clang编译器还引入关键字 __thread 。\n当用以上关键字定义全局变量时，每个线程都会拷贝一份此全局变量的副本，然后各自访问各自的副本。\nTLS的模型 gcc以及clang对TLS的实现，有4种模型：\n-ftls-model=global-dynamic ：动态链接时使用，必须配合编译选项 -fpic 才有效，要求给出 __tls_get_addr() 的定义， 若不配合 -fpic ，实际会变成 -ftls-model=initial-exec ； -ftls-model=local-dynamic ：动态链接时使用，必须配合编译选项 -fpic 才有效，要求给出 __tls_get_addr() 的定义， 若不配合 -fpic ，实际会变成 -ftls-model=initial-exec ； -ftls-model=initial-exec ：静态链接时使用，要求给出 __aeabi_read_tp() 的定义，此函数会返回线程 .tdata 段的首地址。 然后从 .got 段中获取TLS变量的 OFFSET ， 即 OFFSET = GOT[name] 。最终，变量的地址为 __aeabi_read_tp() + OFFSET 。 -ftls-model=local-exec ：静态链接时使用，要求给出 __aeabi_read_tp() 的定义，此函数会返回线程 .tdata 段的首地址。 然后TLS变量的 OFFSET 是以立即数形式获取。最终，变量的地址为 __aeabi_read_tp() + OFFSET 。 相对于 -ftls-model=initial-exec 少了一次内存访问的操作，效率是4种模型中最高的。 XWOS TLS的实现 XWOS同时支持 -ftls-model=initial-exec 和 -ftls-model=local-exec，因此，需要在链接脚本中将 .got 段放入：\n.got : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) } \u003e code_mr AT\u003e code_mr ","categories":"","description":"","excerpt":"概述 线程本地存储(TLS)是指线程私有的变量。\nC11标准开始支持线程本地存储，并引入 _Thread_local 关键字，C2X …","ref":"/docs/Note/Picolibc/TLS/","tags":"","title":"线程本地存储"},{"body":"XWTC xwtc 是XWOS编译的工具集合，可以从百度网盘下载，按照内部 说明.md 安装就可。\nhttps://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ 提取码：xwos 其中包括：\narm-none-eabi-gcc armllvm riscv-nuclei-elf-gcc nxp gcc toolchain windows版本还包括\nwindows-build-tools，包括一些工具，例如 make , sed , emacs 等 Ubuntu 若用户使用 Ubuntu 作为开发环境，除了按照 说明.md 安装之外，需要额外安装一些工具：\nsudo dpkg-reconfigure dash # 选择“否” sudo apt install build-essential sudo apt-add-repository ppa:kelleyk/emacs sudo apt-get update sudo apt install emacs28 # 如果是无图形界面的服务器，改为emacs28-nox windows 若用户使用 Windows 作为开发环境，按照 说明.md 设置环境变量即可。\nXWTC工具链的一些改动 arm-none-eabi-gcc 增加了对TLS(Thread Loacl Storage)的支持 armllvm picolibc 使用正常的 stdio 而非 tinystdio ； 格式化字符串增加 %b, %lld, %Lf ； 将 __errno 设置为函数 ； 支持多字节字符。 ","categories":"","description":"XWOS编译工具链安装指南\n","excerpt":"XWOS编译工具链安装指南\n","ref":"/docs/UserManual/Env/XWTC/","tags":"","title":"XWOS编译工具链安装指南"},{"body":"编译流程概述 XWOS使用自己的 构建系统 进行构建， 构建是从 电路板目录 下执行命令 make 开始的，以 $(XWOS_BRD_DIR) 代表此目录。 编译流程简单说就是将各个模块单独编译为 静态库.a ，然后再链接为 ELF文件 。\narch.a : 由 arch.mk 描述如何编译； cpu.a : 由 cpu.mk 描述如何编译； soc.a : 由 soc.mk 描述如何编译； brd.a : 由 brd.mk 描述如何编译； xwos.a : 由 xwos.mk 描述如何编译； 其他模块均由 xwmo.mk 描述如何编译，称为 构建系统 ，包括： xwcd ：驱动模块 xwmd ：中间件模块 xwem ：第三方软件模块 xwam ：示例与应用模块 $(XWOS_BRD_DIR)/bm ：电路板模块 $(XWOS_BRD_DIR) 是 电路板目录 。 $(XWOS_OEM_DIR) ：OEM模块 XWOS_OEM_DIR 由配置文件 $(XWOS_BRD_DIR)/cfg/project.mk 中的 XWCFG_OEMPATH 进行配置 。 输出文件路径 编译的输出，全部位于 $(WKSPC) 目录，默认值在 $(XWOS_BRD_DIR)/makefile 定义，为 wkspc 。\n这个变量可以在编译前，由用户设置，例如：\nexport WKSPC=../../../Debug 编译后，将自动创建目录 $(XWOS_BRD_DIR)/../../../Debug ，并将所有编译的过程文件放入其中。\n查看编译过程 用户使用 make V=1 进行编译时可以查看完整的编译过程。 也可使用环境变量：\nexport V=1 make 设置优化等级 用户使用 make O=1 进行编译时可以设置编译时的优化等级为 1。 也可使用环境变量：\nexport O=0 # 不使用任何优化，最有利于调试 make 默认情况下，优化等级为 g 。\n","categories":"","description":"","excerpt":"编译流程概述 XWOS使用自己的 构建系统 进行构建， 构建是从 电路板目录 下执行命令 make 开始的， …","ref":"/docs/UserManual/App/Build/","tags":"","title":"编译"},{"body":"思路 通过 cargo 编译 staticlib ，再与XWOS进行链接； 由于XWOS支持ARM/PowerPC/RISC-V，因此需要通过 --target= 选项来进行多平台的交叉编译。 方案 XWOS启动一个独立线程，调用RUST的主函数，由此进入RUST的世界； RUST的主函数与中间件是一个独立编译的玄武模块； 由于RUST的编译依赖工具 cargo ，可设计一个新的玄武模块编译规则调用 cargo build ； RUST玄武模块以 staticlib 形式进行编译，最终与XWOS进行静态链接； 因为会使用一些 unstable 的特性，所以需安装nightly的RUST。 编译方案 应将 cargo build 目标设定为 PHONY ，即可每次 make 时都调用 cargo build ， 由 cargo 来管理 rust 源码的编译； 环境变量 $(RUST_TARGET) 在 cpu.mk 中定义； 其他编译选项，由 .cargo/config 或 build.rs 定义； cargo build 编译结束后，再将输出的.a文件拷贝到输出目录； 安装rust工具链 根据官方指导安装Rust； 切换镜像源 Ubuntu配置文件路径： ~/.cargo/config Windows配置文件路进： C:\\Users\\用户名\\.cargo\\config [source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = 'sjtu' [source.ustc] registry = \"http://mirrors.ustc.edu.cn/crates.io-index\" [source.sjtu] registry = \"http://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index\" Ubuntu安装unstable版本 rustup install nightly rustup +nightly target add thumbv8m.main-none-eabihf rustup +nightly target add thumbv8m.main-none-eabi rustup +nightly target add thumbv8m.base-none-eabi rustup +nightly target add thumbv7m-none-eabi rustup +nightly target add thumbv7em-none-eabihf rustup +nightly target add thumbv7em-none-eabi rustup +nightly target add thumbv6m-none-eabi rustup +nightly target add riscv32imac-unknown-none-elf rustup +nightly component add rust-src Windows安装unstable版本 注意：Windows只支持使用 gnu 版的工具链\nrustup install nightly-x86_64-pc-windows-gnu rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabihf rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.base-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv7m-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabihf rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv6m-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add riscv32imac-unknown-none-elf rustup +nightly-x86_64-pc-windows-gnu component add rust-src RUST中间件模板 目录结构： XWOS └── xwmd └── rust └── xwos ├── Cargo.lock ├── Cargo.toml ├── .cargo │ └── config ├── src │ └── lib.rs └── xwmo.mk Cargo.toml [package] name = \"xwos\" version = \"1.0.0\" edition = \"2021\" [lib] name = \"xwos\" crate-type = [\"staticlib\"] [dependencies] .cargo/config.toml [unstable] build-std = [\"core\", \"alloc\", \"std\", \"panic_abort\"] src/lib.rs #![feature(restricted_std)] #[no_mangle] pub unsafe extern \"C\" fn xwrust_main() { } xwmo.mk include $(XWOS_WKSPC_DIR)/XWOS.cfg include xwbs/functions.mk include xwbs/xwmo.rust.mk 编译规则 xwbs/xwmo.rust.mk ","categories":"","description":"","excerpt":"思路 通过 cargo 编译 staticlib ，再与XWOS进行链接； 由于XWOS支持ARM/PowerPC/RISC-V，因此需要通 …","ref":"/docs/Note/Rust/Build/","tags":"","title":"集成与编译"},{"body":"安装环境 Lua URL: lua 安装 make INSTALL_TOP=安装路径 install 包管理器Luarocks URL: luarocks 安装 ./configure --prefix=安装路径 make install 文档生成工具 URL: LDoc 安装 修改 Makefile 中的 LUA_SHAREDIR 为 $(LUA_PREFIX)/share/lua/5.4\nluarocks install penlight make install ","categories":"","description":"","excerpt":"安装环境 Lua URL: lua 安装 make INSTALL_TOP=安装路径 install 包管理器Luarocks URL: …","ref":"/docs/Note/Lua/env/","tags":"","title":"Lua开发环境"},{"body":"安装XWOS的编译环境 参考 XWTC安装指南\nSTM32CubeIDE URL： STM32CubeIDE Ubuntu中需要安装JRE： sudo apt install openjdk-11-jdk 安装其他调试器插件 菜单： \"Help\" -\u003e \"Install New Software...\" -\u003e \"Add...\" 仓库： http://mirrors.ustc.edu.cn/eclipse/embed-cdt/updates/v6/ 插件 J-Link Debugging ：JLink + Segger的JLinkGDBServer OpenOCD Debugging ：DAPLink/JLink + OpenOCD PyOCD Debugging ：DAPLink/JLink/STLink + PyOCD STM32CubeMX STM32工程的 .ioc 文件需要使用 STM32CubeMX 打开并进行配置。 STM32CubeIDE 只作为编译调试的环境，不进行驱动的配置以及源码的生成。\nURL：STM32CubeMX Rust开发环境 STM32支持使用Rust语言开发，参考 Rust开发环境指南 。\nSTM32CubeID的Rust插件 注意不要选择最新版本的插件：\n菜单： \"Help\" -\u003e \"Install New Software...\" -\u003e \"Add...\" 仓库： http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/ 插件： Corrosion: Rust edition in Eclipse IDE ","categories":["STM32"],"description":"STM32开发环境搭建指南\n","excerpt":"STM32开发环境搭建指南\n","ref":"/docs/UserManual/Board/STM32/Env/","tags":["STM32"],"title":"开发环境"},{"body":"开发XWOS时，需要先安装开发环境：\n","categories":"","description":"开发环境搭建指南\n","excerpt":"开发环境搭建指南\n","ref":"/docs/UserManual/Env/","tags":"","title":"开发环境"},{"body":"XWOS在设计时就充分考虑了代码的复用性、移植性以及与第三方软件的兼容性， 代码被架构成多层结构：构建系统、BSP、操作系统内核、中间件和应用。\nXWOS架构图 Photo: xwos.tech / CC-BY-SA-4.0\n构建系统 xwbs : 构建系统 BSP xwcd : 编译器、CPU、SOC、外设驱动相关的代码 xwcd/ds : 玄武设备栈，XWOS的驱动框架 xwcd/perpheral : 基于玄武设备栈，实现的各种外设驱动，代码可被不同SOC共享 xwcd/soc : 不同SOC的XWOS移植实现层的代码 xwbd : 不同电路板的工程配置、调试脚本、链接脚本、驱动与应用。电路板目录还可以放在其他位置。 操作系统内核 xwos : 内核 xwos/osal : 操作系统抽象层，统一的内核API，不区分操作系统的具体实现 xwos/ospl : 操作系统移植层，其中定义了内核提供给BSP的回调函数以及BSP需要提供给内核的函数 xwos/lib : 基本C函数库，包括原子操作库、位操作库、数据结构等 xwos/mm : 内存管理 xwos/mp : 多核(mp)内核 xwos/up : 单核(up)内核 中间件 xwmd : 中间件 xwmd/isc : 系统间的通讯机制 xwmd/isc/xwcq : 线程间的循环队列 xwmd/isc/xwmq : 线程间的消息队列 xwmd/isc/xwssc : SOC与SOC间的点对点通讯协议 xwmd/libc : 标准C库的适配代码 xwmd/xwrust : XWOS RUST框架 xwem : 第三方开源软件 xwem/fs : 各种开源的文件系统 xwem/serializing : 序列化与反序列化 xwem/serializing/nanopb : protocol-buffer xwem/vm : 虚拟机 xwem/vm/lua : Lua语言虚拟机 应用 xwam : 参考代码以及应用代码 文档 xwxr : API文档生成配置 ","categories":["XWOS"],"description":"XWOS的目录结构\n","excerpt":"XWOS的目录结构\n","ref":"/docs/TechRefManual/Architecture/","tags":"","title":"软件架构"},{"body":"位操作 XWOS提供了位操作模板库， 基本类型 中定义的 各种 非函数指针类型 都可使用位操作。位操作函数模板包括：\nxwbop_s1m() ：将数据掩码部分的位全部置1 xwbop_c0m() ：将数据掩码部分的位全部清0 xwbop_x1m() ：将数据掩码部分的位全部翻转 xwbop_rbit() ：将数据的位镜面翻转 xwbop_re() ：将数据的大小端翻转 xwbop_ffs() ：在数据中从最低位起查找第一个被置1的位 xwbop_fls() ：在数据中从最高位起查找第一个被置1的位1的位 xwbop_ffz() ：在数据中从最低位起查找第一个被清0的位 xwbop_flz() ：在数据中从最高位起查找第一个被清0的位 xwbop_weight() ：统计数据中1的个数 所有位操作函数的第一个参数均为 基本类型 ， 第二个参数是数据或数据的指针，例如：\nxwssq_t idx; /* 从最低位开始查找\"xwu32_t\"类型的数据\"0\"中第一个被置1的位，结果为-1 */ idx = xwbop_ffs(xwu32_t, 0); /* 从最低位开始查找\"xwu32_t\"类型的数据\"0xF0\"中第一个被置1的位，结果为4 */ idx = xwbop_ffs(xwu32_t, 0xF0); /* 将\"xwu32_t\"类型的数据\"0xAA\"进行镜像翻转，结果为0x55 */ xwu32_t rdata = xwbop_rbit(xwu32_t, 0xAA); 位图操作 XWOS提供了基本类型 xwbmp_t ，用于定义位图，位图是 xwbmp_t 的数组。 用户可以声明任意位数的位图，XWOS提供了函数集方便用户操作位图：\nxwbmpop_declare() ：声明位图 xwbmpop_assign() ：赋值 xwbmpop_cmp() ：比较两个位图 xwbmpop_s1all() ：所有位置 1 xwbmpop_c0all() ：所有位清 0 xwbmpop_s1i() ：将位图中某位置 1 xwbmpop_s1m() ：将位图中掩码部分置 1 xwbmpop_c0i() ：将位图中某位清 0 xwbmpop_c0m() ：将位图中掩码部分清 0 xwbmpop_x1i() ：将位图中某位翻转 xwbmpop_x1m() ：将位图中掩码部分翻转 xwbmpop_t1i() ：测试位图中的某位是否为 1 xwbmpop_t1ma() ：测试位图中掩码部分是否全部为 1 xwbmpop_t1ma_then_c0m() ：测试位图中掩码部分是否全部为1，如果是，就将掩码部分全部清 0 xwbmpop_t1mo() ：测试位图中掩码部分是否至少有一位为 1 xwbmpop_t1mo_then_c0m() ：测试位图中掩码部分是否至少有一位为1，如果是，就将掩码部分全部清 0 xwbmpop_t0ma() ：测试位图中掩码部分是否全部为 0 xwbmpop_t0ma_then_s1m() ：测试位图中掩码部分是否全部为 0 ，如果是，就将掩码部分全部置 1 xwbmpop_t0mo() ：测试位图中掩码部分是否至少有一位为 0 xwbmpop_t0mo_then_s1m() ：测试位图中掩码部分是否至少有一位为 0 ，如果是，就将掩码部分全部置 1 xwbmpop_not() ：非运算 xwbmpop_and() ：与运算 xwbmpop_or() ：或运算 xwbmpop_xor() ：异或运算 xwbmpop_ffs() ：从最低位起查找第一个被置1的位 xwbmpop_fls() ：从最高位起查找第一个被置1的位 xwbmpop_ffz() ：从最低位起查找第一个被清0的位 xwbmpop_flz() ：从最高位起查找第一个被清0的位 xwbmpop_weight() ：统计 1 的个数 API参考 头文件 \u003cxwos/lib/xwbop.h\u003e ","categories":["XWOS"],"description":"XWOS的位操作库\n","excerpt":"XWOS的位操作库\n","ref":"/docs/TechRefManual/Xwlib/Xwbop/","tags":"","title":"位操作库"},{"body":"概述 XWOS的消息队列（xwmq）采用双循环链表实现。\nflowchart LR Head --\u003e Msg1 --\u003e Head Msg1 --\u003e Msg2 --\u003e Msg1 Msg2 --\u003e Msg3 --\u003e Msg2 Msg3 --\u003e Msg4 --\u003e Msg3 Msg4 --\u003e Msg5 --\u003e Msg4 Msg5 --\u003e Msg6 --\u003e Msg5 Msg6 --\u003e Msg7 --\u003e Msg6 Msg7 --\u003e Head --\u003e Msg7 消息可发送到队列的头部，也可以发送到队列的尾部。 消息可以从队列的头部接收，也可以从队列的尾部接收。\n消息队列的消息 消息队列的每个节点是 struct xwmq_msg 。\nstruct xwmq_msg { void * data; xwsq_t topic; struct xwlib_bclst_node node; }; data ：消息的数据，只能传递一个指针长度的数据 topic ：消息的主题，由用户自定义主题的含义 node ：链表节点 消息槽 消息槽 是消息队列初始化时，用户定义的消息数组。消息队列中的消息数量最多等于消息槽的数量。\n消息队列对象与对象描述符描述符 消息队列对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，消息队列对象也用 消息队列对象描述符 xwmq_d 来解决有效性和身份合法性的问题。\n消息队列对象描述符由 消息队列对象的指针 和 标签 组成：\ntypedef struct { struct xwmq * mq; /**\u003c 消息队列对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwmq_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n局限性 消息队列的消息只能发送一个和指针长度一样的数据。 如果需要发送比较大的数据，只能将数据的缓冲区的首地址发送出去。 若数据缓冲区是通过向动态内存管理申请而来，用户需要特别小心，数据缓冲区不能被意外地释放掉。\n消息队列的静态初始化、销毁 静态初始化： xwmq_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 初始化消息队列时，需要预先定义消息数组作为消息槽。 struct xwmq brd_mq; struct xwmq_msg brd_mq_txq[16]; // 最多16个消息 xwer_t brd_init_xwmq(void) { return xwmq_init(\u0026brd_mq, brd_mq_txq, xw_array_size(brd_mq_txq)); } 销毁静态初始化的信号量： xwmq_fini() 消息队列的动态创建、删除 XWOS并未提供基于动态内存管理的创建与删除CAPI。\n发送消息 入队 入队 是指将消息发送到消息队列的 尾端 ，发送之前需要获取一个可用的消息槽。\nxwmq_eq() ：等待消息槽，只能在 线程 上下文使用 xwmq_eq_to() ：限时等待消息槽，只能在 线程 上下文使用 xwmq_eq_unintr() ：不可中断地等待消息槽，只能在 线程 上下文使用 xwmq_tryeq() ：尝试获取消息槽，可在 任意 上下文使用 插队 插队 是指将消息发送到消息队列的 首端 ，发送之前需要获取一个可用的消息槽。\nxwmq_jq() ：等待消息槽，只能在 线程 上下文使用 xwmq_jq_to() ：限时等待消息槽，只能在 线程 上下文使用 xwmq_jq_unintr() ：不可中断地等待消息槽，只能在 线程 上下文使用 xwmq_tryjq() ：尝试获取消息槽，可在 任意 上下文使用 接收消息 首端离队 首端离队 是指从消息队列的 首端 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。\nxwmq_dq() ：等待消息，只能在 线程 上下文使用 xwmq_dq_to() ：限时等待消息，只能在 线程 上下文使用 xwmq_dq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwmq_trydq() ：尝试获取消息，可在 任意 上下文使用 尾端离队 尾端离队 是指从消息队列的 尾端 接收消息。接收之后会释放一个消息槽。如果有发送线程正在等待消息槽，将唤醒发送线程。\nxwmq_rq() ：等待消息，只能在 线程 上下文使用 xwmq_rq_to() ：限时等待消息，只能在 线程 上下文使用 xwmq_rq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwmq_tryrq() ：尝试获取消息，可在 任意 上下文使用 消息队列对象的生命周期管理 消息队列对象的基类是 XWOS对象 struct xwos_object 。 消息队列对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwmq_grab() ：增加引用计数。 xwmq_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwmq_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwmq_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwmd/isc/xwmq.h\u003e ","categories":["XWOS"],"description":"","excerpt":"概述 XWOS的消息队列（xwmq）采用双循环链表实现。\nflowchart LR Head --\u003e Msg1 --\u003e Head Msg1 …","ref":"/docs/TechRefManual/Isc/Xwmq/","tags":"","title":"消息队列"},{"body":"概述 信号量是操作系统比较底层的同步机制，是一个带有 等待队列 的计数器。\n信号量中包含一个整数计数器：\n当信号量的值等于 0 时，线程们就在 等待队列 中等待信号量的值大于 0 ； 当信号量的值大于 0 时，可以唤醒一个正在等待的线程。线程被唤醒后会取走一个值，信号量的值减少 1 ； 当信号量的值小于 0 ，信号量处于 冻结 状态，理论中的信号量不存在此状态，这是XWOS的扩张。 任意上下文都可增加信号量的值，这个操作被称为 发布 。\n信号量常常用于在中断中唤醒一个线程，并将耗时较长的操作放在线程中执行。可减少中断上下文的执行时间，增加中断吞吐量，降低中断延迟。\nXWOS内核的信号量有两种：\n管道信号量(PipelineSemaphore)：对所有阻塞在其等待队列中的线程按照先进先出(FIFO)的策略调度， 即当信号量可用时，最先进入等待队列中的线程将优先获得信号量。 实时信号量(ReltimeSemaphore)：对所有阻塞在其等待队列中的线程按照优先级进行调度，即高优先级 的线程总是最先获得信号量，同优先级的线程按先进先出(FIFO)的策略调度。 操作系统抽象层(OSAL)的CAPI只封装了一种信号量，当系统配置文件中同时配置了管道信号量与实时信号量时， 优先使用实时信号量 。\n信号量对象与对象描述符描述符 信号量对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，信号量对象也用 信号量对象描述符 xwos_sem_d 来解决有效性和身份合法性的问题。\n信号量对象描述符由 信号量对象的指针 和 标签 组成：\ntypedef struct { struct xwos_sem * sem; /**\u003c 信号量对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_sem_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n信号量的初始化、销毁与动态创建、删除 信号量创建时需要指定两个参数： 初始值 和 最大值 。\n静态初始化、销毁 静态初始化： xwos_sem_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的信号量： xwos_sem_fini() 动态创建、删除 动态创建： xwos_sem_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的信号量： xwos_sem_delete() 发布信号量 可以通过 xwos_sem_post() 在 任意 上下文增加信号量的值。 当信号量的值大与 0 时，会唤醒信号量等待队列中的一个线程。被唤醒的线程会取走一个值，使得信号量的计数器减1。\n等待信号量 当信号量的值大于 0 时，可以直接取走一个，此时信号量的值减 1 ； 当信号量的值等于 0 时，获取信号量的线程就只能阻塞等待，XWOS提供四种方式：\nxwos_sem_wait() ：等待并获取信号量，只能在 线程 上下文使用 xwos_sem_wait_to() ：限时等待并获取信号量，只能在 线程 上下文使用 xwos_sem_wait_unintr() ：不可中断等待并获取信号量，只能在 线程 上下文使用 xwos_sem_trywait() ：尝试获取信号量，可在 任意 上下文使用 读取信号量的状态 信号量中计数器的最大值可以通过 xwos_sem_get_max() 读取。这个最大值是在信号量初始化或创建时设置的。 信号量中计数器的值可以通过 xwos_sem_get_value() 读取。此CAPI只读取，不会改变信号量的值，也不会等待信号量。 冻结与解冻 冻结 信号量可以使用 xwos_sem_freeze() 进行 冻结， 被冻结的信号量的值为负数，不影响对信号量的 等待 操作。但不能 发布 信号量。\n解冻 通过 xwos_sem_thaw() 可将已经冻结的信号量 解冻 。 信号量 解冻 后，值被重置为0，此时可重新开始发布信号量。\n绑定与解绑信号选择器 可以通过 xwos_sem_bind() 将信号量绑定到 信号选择器 上。 当 发布 信号量时，信号量会向 信号选择器 发送一个 选择信号 。此时 信号选择器 会唤醒正在等待的线程。\n绑定后的信号量可以通过 xwos_sem_unbind() 解绑。\n信号量对象的生命周期管理 信号量对象的基类是 XWOS对象 struct xwos_object 。 信号量对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_sem_grab() ：增加引用计数。 xwos_sem_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_sem_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_sem_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwos/osal/sync/sem.h\u003e ","categories":["XWOS"],"description":"XWOS的信号量\n","excerpt":"XWOS的信号量\n","ref":"/docs/TechRefManual/Sync/Sem/","tags":"","title":"信号量"},{"body":"CAPI参考 头文件 \u003cxwos/osal/sync/sem.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/sync/sem.h\u003e ","ref":"/docs/UserManual/App/Sync/Sem/","tags":"","title":"信号量"},{"body":"","categories":"","description":"XWOS的用户手册\n","excerpt":"XWOS的用户手册\n","ref":"/docs/UserManual/","tags":"","title":"用户手册"},{"body":"概述 自旋锁是多核系统中为防止多个处理器同时访问公共的内存区域（称为临界区）而引入的一种锁。 当一个CPU获得自旋锁并访问临界区时，其他CPU只能 自旋 等待锁。 所谓 自旋 ，是指不断循环测试 锁 是否已经解开。\n自旋锁只是为SMP的场景设计的一种锁机制。在单核(UP)系统中，并不需要自旋锁。 但为了软件接口的统一，实现了虚假的自旋锁，只是对关闭抢占、中断底半部或中断的封装。\n自旋锁还伴随其他操作：内存屏障，关闭调度器的抢占，关闭中断底半部，关闭中断等。\n局限性 自旋锁内包含内存内存屏障操作，内存屏障会降低CPU的性能； 自旋锁不区分读和写的情况。 使用自旋锁 自旋锁的初始化 自旋锁是基于原子操作指令实现的，自旋锁结构体很小，核心数据是一个CPU指令能操作的基本数据类型，因此不提供动态创建和删除方法。 用户可以通过 xwos_splk_init() 初始化自旋锁。\n多锁 当使用 多个 自旋锁保护临界区时，上锁和解锁顺序必须 保持一致 ，否则会导致死锁。\n锁模式 临界区只对 线程 上下文是安全的。临界区内，只会关闭抢占。 可以理解为在线程层面，临界区内的操作是 原子的 。临界区内的数据只能被 线程 上下文访问。 临界区内不能发生 调度 ，用户不可在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock() ：上锁，关闭抢占，进入临界区 xwos_splk_trylock() ：尝试上锁，关闭抢占，尝试进入临界区 xwos_splk_unlock() ：解锁，开启抢占，退出临界区 xwos_splk_lock(\u0026lock); /* 临界区 */ xwos_splk_unlock(\u0026lock); 临界区对 任意 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在临界区内的操作是 原子的 ，临界区内的数据能被 任意 上下文访问。 临界区内不会发生中断，也不可能发生 调度 ，但用户依然不能在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock_cpuirq() ：上锁，关闭抢占、CPU中断，进入临界区 xwos_splk_trylock_cpuirq() ：尝试上锁，关闭抢占、CPU中断，尝试进入临界区 xwos_splk_unlock_cpuirq() ：解锁，开启抢占、CPU中断，退出临界区 xwos_splk_lock_cpuirq(\u0026lock); /* 临界区 */ xwos_splk_unlock_cpuirq(\u0026lock); 当使用 多个 自旋锁时，嵌套的临界区对 任意 上下文都是安全的。临界区内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在临界区内的操作是 原子的 ，临界区内的数据只能被 任意 上下文访问。 临界区内不会发生中断，也不可能发生 调度 ，但用户依然不能在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock_cpuirqsv() ：上锁，关闭抢占，保存CPU中断标志并关闭，进入临界区 xwos_splk_trylock_cpuirqsv() ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入临界区 xwos_splk_unlock_cpuirqrs() ：解锁，开启抢占，恢复CPU中断，退出临界区 xwos_splk_lock_cpuirqsv(\u0026lock1, \u0026cpuirq1); /* 临界区1 */ xwos_splk_lock_cpuirqsv(\u0026lock2, \u0026cpuirq2); /* 临界区2 */ xwos_splk_unlock_cpuirqrs(\u0026loc2, cpuirq2); /* 临界区1 */ xwos_splk_unlock_cpuirqrs(\u0026loc1, cpuirq1); 临界区对 线程 、 指定的外设中断 是安全的。临界区内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面，临界区内的操作是 原子的 ，临界区内的数据只能被 线程 和 指定的外设中断 上下文访问。 临界区内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock_irqs() ：上锁，关闭抢占，关闭部分中断，进入临界区 xwos_splk_trylock_irqs() ：尝试上锁，关闭抢占，关闭部分中断，尝试进入临界区 xwos_splk_unlock_irqs() ：解锁，开启抢占、开启部分中断，退出临界区 xwos_splk_lock_irqs(\u0026lock, irq_array, num); /* 临界区 */ xwos_splk_unlock_irqs(\u0026lock, irq_array, num); 当使用 多个 自旋锁时，嵌套的临界区对 线程 、 指定的外设中断 是安全的。临界区内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面，临界区内的操作是 原子的 ，临界区内的数据只能被 线程 和 指定的外设中断 上下文访问。 临界区内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock_irqssv() ：上锁，关闭抢占，保存部分中断标志并关闭，进入临界区 xwos_splk_trylock_irqssv() ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入临界区 xwos_splk_unlock_irqsrs() ：解锁，开启抢占、恢复部分中断，退出临界区 xwos_splk_lock_irqssv(\u0026lock1, irq_array, flag1_array, num); /* 临界区1 */ xwos_splk_lock_irqssv(\u0026lock2, irq_array, flag2_array, num); /* 临界区2 */ xwos_splk_unlock_irqsrs(\u0026lock2, irq_array, flag2_array, num); /* 临界区1 */ xwos_splk_unlock_irqsrs(\u0026lock1, irq_array, flag1_array, num); 临界区对 线程 、 中断底半部 是安全的。临界区内，只关闭抢占和中断底半部。 可以理解为在线程和中断底半部层面，临界区内的操作是 原子的 ，临界区内的数据只能被 线程 和 中断底半部 上下文访问。 临界区内不会发生 调度 ，但用户依然不能在临界区内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_lock_bh() ：上锁，关闭抢占、中断底半部，进入临界区 xwos_splk_trylock_bh() ：尝试上锁，关闭抢占、中断底半部，尝试进入临界区 xwos_splk_unlock_bh() ：解锁，开启抢占、中断底半部，退出临界区 xwos_splk_lock_bh(\u0026lock); /* 临界区 */ xwos_splk_unlock_bh(\u0026lock); 为什么没有 保存与恢复抢占 和 保存与恢复中断底半部 形式的CAPI ？ 因为 关闭与打开抢占 和 保存与恢复中断底半部 是一种可重入的的 锁 ， 关闭 了多少次，对应的就要 打开 多少次。 CAPI参考 头文件 \u003cxwos/osal/lock/spinlock.h\u003e ","categories":["XWOS"],"description":"XWOS的自旋锁\n","excerpt":"XWOS的自旋锁\n","ref":"/docs/TechRefManual/Lock/Spinlock/","tags":"","title":"自旋锁"},{"body":"CAPI参考 头文件 \u003cxwos/osal/lock/spinlock.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/lock/spinlock.h\u003e ","ref":"/docs/UserManual/App/Lock/Spinlock/","tags":"","title":"自旋锁"},{"body":"Rust的std库 RUST的标准库包括：\n在嵌入式系统中，比较有用的是 core 与 alloc 。\n虽然在嵌入式环境中，可以通过 #![feature(restricted_std)] 强行使用Rust的std库， 但随着功能的增加，问题也会越来越多，故转向使用 #![no_std] 。\n编译 在 .cargo/config.toml 增加编译：\n[unstable] build-std = [\"core\", \"alloc\"] global_allocator 可用来实现自己的内存分配函数的属性，可参考文档std::alloc。\n在lib.rs上可以搜索到newlib-alloc，可直接用。\n在 Cargo.toml 中增加\n[dependencies] libc = \"0.2\" newlib-alloc = \"0.1\" libc-print = \"0.1\" 编译libc时需要条件选择 newlib ，在 .cargo/config 增加：\n[build] rustflags = [ \"--cfg\", \"unix\", \"--cfg\", \"target_env=\\\"newlib\\\"\", ] 编写测试代码 #![no_std] #![feature(alloc_error_handler)] use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026PanicInfo) -\u003e ! { loop {} } use newlib_alloc; #[global_allocator] static GLOBAL_ALLOCATOR: newlib_alloc::Alloc = newlib_alloc::Alloc; #[alloc_error_handler] fn alloc_error_handler(_layout: core::alloc::Layout) -\u003e ! { loop {} } use libc_print::std_name::println; extern crate alloc; use alloc::vec::Vec; #[no_mangle] pub unsafe extern \"C\" fn rust_main() { let mut v = Vec::new(); v.push(1); v.push(2); v.push(3); v.push(4); println!(\"RUST XWOS!\"); for x in v.iter() { println!(\"x: {}\", x); } } 串口终端输出 调试过程 测试环境 硬件环境 WeActMiniStm32H750 MCU：STM32H750 说明：此工程已对接好newlib(如 malloc() 、 printf() 等标准函数)，可为Rust的库提供底层支持。 调试环境 IDE：STM32CubeIDE 需要增加Rust插件：Corrosion: Rust edition in Eclipse IDE 实验代码 代码仓库： git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750.git commit cd XWOS git pull git checkout -b rust-bringup f8fcad24daa4912e4de0886c30e02343b6045dab ","categories":"","description":"","excerpt":"Rust的std库 RUST的标准库包括：\n在嵌入式系统中，比较有用的是 core 与 alloc 。\n虽然在嵌入式环境中， …","ref":"/docs/Note/Rust/Bringup/","tags":"","title":"Rust方案初验证"},{"body":"XWOS内核是使用纯C语言开发的，不依赖C++的标准库。 用户可在线程中使用C++语言以及C++标准库，C++标准库由编译器提供，不完全功能清单如下：\ng++, libstdc++, libsupc++ new, delete, new[], delete[], placement new, aligned new (C++17) 容器 array vector deque map, multimap, unordered_map, unordered_multimap set, multiset, unordered_set, unordered_multiset list, forward_list stack, queue, priority_queue I/O stream string atomic RTTI exception unwind chrono thread mutex condition_variable llvm(clang++), libc++, libc++abi new, delete, new[], delete[], placement new, aligned new (C++17) 容器 array vector deque map, multimap, unordered_map, unordered_multimap set, multiset, unordered_set, unordered_multiset list, forward_list stack, queue, priority_queue I/O stream string atomic RTTI exception unwind chrono thread mutex condition_variable ","categories":["XWOS"],"description":"","excerpt":"XWOS内核是使用纯C语言开发的，不依赖C++的标准库。 用户可在线程中使用C++语言以及C++标准库，C++标准库由编译器提供，不完全功能 …","ref":"/docs/TechRefManual/C_C++/C++/","tags":"","title":"C++"},{"body":"说明 XWOS不使用Newlib提供的动态内存管理的算法。使用的是内存池算法： 移植方法 重写Newlib的函数： void * _malloc_r(struct _reent * r, size_t n); void * _realloc_r(struct _reent * r, void * p, size_t n); void * _calloc_r(struct _reent * r, size_t elem_nr, size_t elem_sz); void * _memalign_r(struct _reent * r, size_t alignment, size_t n); void * _valloc_r(struct _reent * r, size_t n); void * _pvalloc_r(struct _reent * r, size_t n); void _free_r(struct _reent * r, void * p); 源码路径： xwmd/libc/newlibac/mem.c\n还没实现的函数：\nmallopt malloc_usable_size malloc_stats mallinfo ","categories":"","description":"","excerpt":"说明 XWOS不使用Newlib提供的动态内存管理的算法。使用的是内存池算法： 移植方法 重写Newlib的函数： void * …","ref":"/docs/Note/Newlib/MM/","tags":"","title":"动态内存管理"},{"body":"说明 XWOS不使用picolibc提供的动态内存管理的算法。使用的是内存池算法： 移植方法 源码路径：xwmd/libc/picolibcac/mem.c 重写picolibc的函数： void * malloc(size_t n); void * realloc(void * p, size_t n); void * calloc(size_t elem_nr, size_t elem_sz); void * memalign(size_t alignment, size_t n); void * valloc(size_t n); void * pvalloc(size_t n); void free(void * p); int getpagesize(void); 无需重写的函数： int posix_memalign(void ** memptr, size_t align, size_t size); // picolibc提供基于memalign实现 void * aligned_alloc(size_t alignment, size_t size); // picolibc提供基于memalign实现 还没实现的函数： mallopt malloc_usable_size malloc_stats mallinfo ","categories":"","description":"","excerpt":"说明 XWOS不使用picolibc提供的动态内存管理的算法。使用的是内存池算法： 移植方法 源码路 …","ref":"/docs/Note/Picolibc/MM/","tags":"","title":"动态内存管理"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/Note/SOC/RISC-V/","tags":"","title":"RISC-V移植说明"},{"body":"Rust的开发工具 根据官方指导安装 RUST ； 切换镜像源 Ubuntu配置文件路径： ~/.cargo/config Windows配置文件路进： C:\\Users\\用户名\\.cargo\\config [source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = \"ustc\" [source.ustc] registry = \"http://mirrors.ustc.edu.cn/crates.io-index\" [source.tuna] registry = \"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\" [source.sjtu] registry = \"http://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index\" Ubuntu安装unstable版本 rustup install nightly rustup +nightly target add thumbv8m.main-none-eabihf rustup +nightly target add thumbv8m.main-none-eabi rustup +nightly target add thumbv8m.base-none-eabi rustup +nightly target add thumbv7m-none-eabi rustup +nightly target add thumbv7em-none-eabihf rustup +nightly target add thumbv7em-none-eabi rustup +nightly target add thumbv6m-none-eabi rustup +nightly target add riscv32imac-unknown-none-elf rustup +nightly target add aarch64-unknown-none rustup +nightly component add rust-src Windows安装unstable版本 注意：Windows只支持使用 gnu 版的工具链\nrustup install nightly-x86_64-pc-windows-gnu rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabihf rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.main-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv8m.base-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv7m-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabihf rustup +nightly-x86_64-pc-windows-gnu target add thumbv7em-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add thumbv6m-none-eabi rustup +nightly-x86_64-pc-windows-gnu target add riscv32imac-unknown-none-elf rustup +nightly-x86_64-pc-windows-gnu target add aarch64-unknown-none rustup +nightly-x86_64-pc-windows-gnu component add rust-src 安装LSP LSP（Language Server Protocol，语言服务协议）是新一代查看源码的工具。 Rust语言的LSP推荐使用 rust-analyzer 。\n有两种安装方法：\n通过命令安装，可获得稳定版 rustup +nightly component add rust-src 通过源码安装，可获得最新版本 git clone https://github.com/rust-analyzer/rust-analyzer.git cd rust-analyzer cargo xtask install ","categories":"","description":"XWOS RUST编译工具安装指南\n","excerpt":"XWOS RUST编译工具安装指南\n","ref":"/docs/UserManual/Env/Rust/","tags":"","title":"Rust开发环境指南"},{"body":"基本类型 XWOS的所有可以确定位宽的数据类型被称为 基本数据类型 ，定义如下：\nxwu8_t 8位无符号整数 xws8_t 8位有符号整数 xwu16_t 16位无符号整数 xws16_t 16位有符号整数 xwu32_t 32位无符号整数 xws32_t 32位有符号整数 xwu64_t 64位无符号整数 xws64_t 64位有符号整数 xwsz_t 大小值（无符号） xwssz_t 大小值（有符号） xwstk_t 栈帧（无符号），必须与指针位宽一致 xwptr_t 指针的整数值（无符号），必须与指针位宽一致 xwreg_t 寄存器（无符号），必须与指针位宽一致 xwsreg_t 寄存器（有符号），必须与指针位宽一致 xwer_t 错误码（有符号），必须与指针位宽一致 xwsq_t 序列值/位置/偏移（无符号），必须与指针位宽一致 xwssq_t 序列值/位置/偏移（有符号），必须与指针位宽一致 xwsid_t ID（有符号），必须与指针位宽一致 xwid_t ID（无符号），必须与指针位宽一致 typedef void (* xwisr_f)(void) 中断向量（函数指针） xwirq_t 中断号（有符号），负的中断号表示系统异常，正的中断号表示外部中断 xwpr_t 优先级（有符号） xwbmp_t 位图（无符号） xwtm_t 时间（64位有符号整数，单位：纳秒） xwlfq_t 无锁队列 typedef void (* ctor_f)(void * /*obj*/) 构造函数 typedef void (* dtor_f)(void * /*obj*/) 析构函数 typedef xws64_t (* xwsc_f)(void * /*arg*/, ...) 系统调用 数据类型命名习惯 用户在阅读XWOS源码时，要注意以下几个命名习惯的隐含意义：\n对于比较小的数据结构，XWOS会通过 typedef 定义成一种类型。这种类型就像基本数据类型一样， 在函数间传递参数时是直接传递，不会使用 type * 去传递指针，除非是返回数据。 命名通常是 type_t 的形式，函数指针则为 type_f 的形式，对象描述符 则为 xwobj_d 。 对于比较大的结构体，XWOS使用关键字 struct 定义。XWOS代码中不会省略关键字 struct 。 目的是提醒读者这是一个结构体，将它作为参数传递时是通过传递指针来引用数据。 原子类型 所有基本数据类型增加前缀 atomic_ 表示此类型的原子类型。例如： _Atomic xwsq_t 等价于 __xwcc_atomic xwsq_t 等价于 atomic_xwsq_t。 原子类型的变量可以使用XWOS的 原子操作库 来操作，也可以使用标准C头文件 \u003cstdatomic.h\u003e 中定义的函数来操作。\n系统位数 XWOS内核支持32位与64位两种CPU。\n时间 XWOS内核使用64位有符号整数 xwtm_t 表示时间，单位为纳秒。并提供一系列操作函数。\n详细参考头文件 xwos/osal/time.h 。\n对象 xwos_object 是XWOS所有对象的父类。\n对象描述符 对象描述符 是XWOS为了解决对象野指针问题而引入的机制。\n调度器 XWOS会为每个CPU创建独立的 调度器，每个调度器 独立调度线程，且都有一个私有的滴答定时器。\n滴答定时器 为调度器产生固定频率中断的硬件定时器。\n线程 调度器内的基本调度单位为 线程 ，因此线程是与调度器绑定的。\n软件定时器 基于调度器的滴答定时器实现的 软件定时器 也是与调度器绑定的。\n锁 XWOS的锁机制有：\n互斥锁 ：防止两个 线程 竞争内存数据的锁。 自选锁 ：可防止任意上下文竞争内存数据的锁。 顺序锁 ：自选锁的改良锁，可分为读锁和写锁，读锁可共享，写锁独占。 同步机制 XWOS的 基本同步机制 ：\n信号量 条件量 事件标志 线程栅栏 信号选择器 通讯机制 基于 基本同步机制 ，XWOS的中间件XWMD提供了线程间的通讯机制：\n消息队列 循环队列 内存管理 XWOS的内核提供了多种动态 内存管理 的方法。\n电源管理 XWOS的内核为 电源管理 ，提供了一套基本的流程。\n","categories":["XWOS"],"description":"XWOS的基本类型、概念、习惯\n","excerpt":"XWOS的基本类型、概念、习惯\n","ref":"/docs/TechRefManual/XwosStd/","tags":"","title":"XWOS标准"},{"body":"XWOS的顶级头文件为 #include \u003cxwos/standard.h\u003e ，其中包括了基本的类型定义、宏定义等。 详细可参考 XWOS标准 。\n","categories":"","description":"","excerpt":"XWOS的顶级头文件为 #include \u003cxwos/standard.h\u003e ，其中包括了基本的类型定义、宏定义等。 详细可参考 XWOS标 …","ref":"/docs/UserManual/App/XwosStd/","tags":"","title":"XWOS标准"},{"body":"版本号 XWOS从V3.0.0开始遵循 Semantic Versioning 规范：\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当做了不兼容的API修改，也被称为里程碑版本； 次版本号：当做了向下兼容的功能性新增，也被称为稳定版本； 修订号：当做了向下兼容的问题修正。 分支 main* 分支: 主分支； 版本号 分支: 稳定版本与里程碑版本的分支。 ","categories":"","description":"XWOS的分支与版本号规范\n","excerpt":"XWOS的分支与版本号规范\n","ref":"/docs/Standard/VersionBranch/","tags":"","title":"分支与版本号规范"},{"body":"","categories":["XWOS"],"description":"XWOS的技术参考手册\n","excerpt":"XWOS的技术参考手册\n","ref":"/docs/TechRefManual/","tags":"","title":"技术参考手册"},{"body":"","categories":"","description":"各种SOC平台的XWOS示例工程\n","excerpt":"各种SOC平台的XWOS示例工程\n","ref":"/docs/UserManual/Board/","tags":"","title":"开发板"},{"body":"概述 顺序锁是对 自旋锁 改良后的锁。主要是对读和写的情况进行区分。 顺序锁中包含一个自旋锁和一个顺序值。顺序锁将临界区分为三种：\n独占写：任何对顺序锁临界区的 写 操作都是独占的，每次 写 操作时，会先上锁自旋锁， 然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 偶数 。 非独占读：如果多个CPU进行的是 只读 操作，它们可以同时进入 非独占读临界区 。 CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 偶数 ，并记录此时的顺序值。 当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较： 如果相等，表示读的结果有效； 如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。 独占读：如果希望读临界区不会被写操作无效掉，可以使用独占读的方式， 独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥非独占读， 其他CPU依然可以进入非独占读临界区。 局限性 顺序锁有个缺陷： 写 者将数据写为空指针时，有可能导致 非独占读 者引用空指针而崩溃。\n使用顺序锁 顺序锁的初始化 同自旋锁一样，顺序锁结构体很小，不提供动态创建和删除方法。 用户可以通过 xwos_sqlk_init() 初始化顺序锁。\n多锁 当使用 多个 自旋锁保护 写临界区 或 独占读临界区 时，上锁和解锁顺序必须 保持一致 ，否则会导致死锁。\n非独占读临界区 如果多个CPU进行的是 只读 操作，它们可以同时进入 非独占读临界区 。 CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为 偶数，并记录此时的顺序值。 此操作可通过 xwos_sqlk_rd_begin() 来完成。\n当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较。 此操作可通过 xwos_sqlk_rd_retry() 完成。\n如果相等，表示读的结果有效； 如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。 seq = xwos_sqlk_rd_begin(\u0026lock); /* 进入临界区前先获取顺序值 */ do { /* 非独占读临界区 */ } while (xwos_sqlk_rd_retry(\u0026lock， seq)); /* 测试顺序值是否发生了变化 */ 用户也可以通过 xwos_sqlk_get_seq() 读取顺序值，自行比较。\n写临界区 任何对顺序锁临界区的 写 操作都是独占的，每次进入 写临界区 时，会先上锁自旋锁， 然后增加顺序值，离开临界区时也会再次增加顺序值。言外之意，顺序值增加两次，顺序值增加的次数是 偶数 。\n写临界区 只对 线程 上下文是安全的。 写临界区 内，只会关闭抢占。 可以理解为在线程层面， 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 线程 上下文访问。 写临界区 内不能发生 调度 ，用户不可在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock() ：上锁，关闭抢占，进入写临界区 xwos_splk_wr_trylock() ：尝试上锁，关闭抢占，尝试进入写临界区 xwos_splk_wr_unlock() ：解锁，开启抢占，退出写临界区 xwos_splk_wr_lock(\u0026lock); /* 写临界区 */ xwos_splk_wr_unlock(\u0026lock); 写临界区 对 任意 上下文都是安全的。 写临界区 内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 任意 上下文访问。 写临界区 内不会发生中断，也不可能发生 调度 ，但用户依然不能在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock_cpuirq() ：上锁，关闭抢占、CPU中断，进入写临界区 xwos_splk_wr_trylock_cpuirq() ：尝试上锁，关闭抢占、CPU中断，尝试进入写临界区 xwos_splk_wr_unlock_cpuirq() ：解锁，开启抢占、CPU中断，退出写临界区 xwos_splk_wr_lock_cpuirq(\u0026lock); /* 写临界区 */ xwos_splk_wr_unlock_cpuirq(\u0026lock); 当使用 多个 顺序锁时，嵌套的 写临界区 对 任意 上下文都是安全的。 写临界区 内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 线程 上下文访问。 写临界区 内不会发生中断，也不可能发生 调度 ，但用户依然不能在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock_cpuirqsv() ：上锁，关闭抢占，保存CPU中断标志并关闭，进入写临界区 xwos_splk_wr_trylock_cpuirqsv() ：尝试上锁，关闭抢占，保存CPU中断标志并关闭，尝试进入写临界区 xwos_splk_wr_unlock_cpuirqrs() ：解锁，开启抢占，恢复CPU中断，退出写临界区 xwos_splk_wr_lock_cpuirqsv(\u0026lock1, \u0026cpuirq1); /* 写临界区1 */ xwos_splk_wr_lock_cpuirqsv(\u0026lock2, \u0026cpuirq2); /* 写临界区2 */ xwos_splk_wr_unlock_cpuirqrs(\u0026loc2, cpuirq2); /* 写临界区1 */ xwos_splk_wr_unlock_cpuirqrs(\u0026loc1, cpuirq1); 写临界区 对 线程 、 指定的外设中断 是安全的。写临界区 内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面， 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 线程 和 指定的外设中断 上下文访问。 写临界区 内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock_irqs() ：上锁，关闭抢占，关闭部分中断，进入写临界区 xwos_splk_wr_trylock_irqs() ：尝试上锁，关闭抢占，关闭部分中断，尝试进入写临界区 xwos_splk_wr_unlock_irqs() ：解锁，开启抢占、开启部分中断，退出写临界区 xwos_splk_wr_lock_irqs(\u0026lock, irq_array, num); /* 写临界区 */ xwos_splk_wr_unlock_irqs(\u0026lock, irq_array, num); 当使用 多个 顺序锁时，嵌套的 写临界区 对 线程 、 指定的外设中断 是安全的。 写临界区 内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面， 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 线程 和 指定的外设中断 上下文访问。 写临界区 内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock_irqssv() ：上锁，关闭抢占，保存部分中断标志并关闭，进入写临界区 xwos_splk_wr_trylock_irqssv() ：尝试上锁，关闭抢占，保存部分中断标志并关闭，尝试进入写临界区 xwos_splk_wr_unlock_irqsrs() ：解锁，开启抢占、恢复部分中断，退出写临界区 xwos_splk_wr_lock_irqssv(\u0026lock1, irq_array, flag1_array, num); /* 写临界区1 */ xwos_splk_wr_lock_irqssv(\u0026lock2, irq_array, flag2_array, num); /* 写临界区2 */ xwos_splk_wr_unlock_irqsrs(\u0026lock2, irq_array, flag2_array, num); /* 写临界区1 */ xwos_splk_wr_unlock_irqsrs(\u0026lock1, irq_array, flag1_array, num); 写临界区 对 线程 、 中断底半部 是安全的。 写临界区 内，只关闭抢占和中断底半部。 可以理解为在线程和中断底半部层面， 写临界区 内的操作是 原子的 ， 写临界区 内的数据只能被 线程 和 中断底半部 上下文访问。 写临界区 内不会发生 调度 ，但用户依然不能在 写临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_wr_lock_bh() ：上锁，关闭抢占、中断底半部，进入写临界区 xwos_splk_wr_trylock_bh() ：尝试上锁，关闭抢占、中断底半部，尝试进入写临界区 xwos_splk_wr_unlock_bh() ：解锁，开启抢占、中断底半部，退出写临界区 xwos_splk_wr_lock_bh(\u0026lock); /* 写临界区 */ xwos_splk_wr_unlock_bh(\u0026lock); 独占读临界区 如果希望读临界区不会被写操作无效掉，可以使用独占读的方式， 独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥 非独占读 ， 其他CPU依然可以进入非独占读临界区。\n独占读临界区 只对 线程 上下文是安全的。 独占读临界区 内，只会关闭抢占。 可以理解为在线程层面， 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 线程 上下文访问。 独占读临界区 内不能发生 调度 ，用户不可在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock() ：上锁，关闭抢占 xwos_splk_rdex_trylock() ：尝试上锁，关闭抢占 xwos_splk_rdex_unlock() ：解锁，开启抢占 xwos_splk_rdex_lock(\u0026lock); /* 独占读临界区 */ xwos_splk_rdex_unlock(\u0026lock); 独占读临界区 对 任意 上下文都是安全的。 独占读临界区 内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 任意 上下文访问。 独占读临界区 内不会发生中断，也不可能发生 调度 ，但用户依然不能在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock_cpuirq() ：上锁，关闭抢占、CPU中断 xwos_splk_rdex_trylock_cpuirq() ：尝试上锁，关闭抢占、CPU中断 xwos_splk_rdex_unlock_cpuirq() ：解锁，开启抢占、CPU中断 xwos_splk_rdex_lock_cpuirq(\u0026lock); /* 独占读临界区 */ xwos_splk_rdex_unlock_cpuirq(\u0026lock); 当使用 多个 顺序锁时，嵌套的 独占读临界区 对 任意 上下文都是安全的。 独占读临界区 内，不但会关闭抢占，还会把CPU中断也关了。 可以理解为在 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 线程 上下文访问。 独占读临界区 内不会发生中断，也不可能发生 调度 ，但用户依然不能在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock_cpuirqsv() ：上锁，关闭抢占，保存CPU中断标志并关闭 xwos_splk_rdex_trylock_cpuirqsv() ：尝试上锁，关闭抢占，保存CPU中断标志并关闭 xwos_splk_rdex_unlock_cpuirqrs() ：解锁，开启抢占，恢复CPU中断 xwos_splk_rdex_lock_cpuirqsv(\u0026lock1, \u0026cpuirq1); /* 独占读临界区1 */ xwos_splk_rdex_lock_cpuirqsv(\u0026lock2, \u0026cpuirq2); /* 独占读临界区2 */ xwos_splk_rdex_unlock_cpuirqrs(\u0026loc2, cpuirq2); /* 独占读临界区1 */ xwos_splk_rdex_unlock_cpuirqrs(\u0026loc1, cpuirq1); 独占读临界区 对 线程 、 指定的外设中断 是安全的。独占读临界区 内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面， 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 线程 和 指定的外设中断 上下文访问。 独占读临界区 内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock_irqs() ：上锁，关闭抢占，关闭部分中断 xwos_splk_rdex_trylock_irqs() ：尝试上锁，关闭抢占，关闭部分中断 xwos_splk_rdex_unlock_irqs() ：解锁，开启抢占、开启部分中断 xwos_splk_rdex_lock_irqs(\u0026lock, irq_array, num); /* 独占读临界区 */ xwos_splk_rdex_unlock_irqs(\u0026lock, irq_array, num); 当使用 多个 顺序锁时，嵌套的 独占读临界区 对 线程 、 指定的外设中断 是安全的。 独占读临界区 内，只关闭抢占和指定的中断。 可以理解为在线程和指定的中断函数层面， 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 线程 和 指定的外设中断 上下文访问。 独占读临界区 内不会发生指定的中断，也不会发生 调度 ，但用户依然不能在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock_irqssv() ：上锁，关闭抢占，保存部分中断标志并关闭 xwos_splk_rdex_trylock_irqssv() ：尝试上锁，关闭抢占，保存部分中断标志并关闭 xwos_splk_rdex_unlock_irqsrs() ：解锁，开启抢占、恢复部分中断 xwos_splk_rdex_lock_irqssv(\u0026lock1, irq_array, flag1_array, num); /* 独占读临界区1 */ xwos_splk_rdex_lock_irqssv(\u0026lock2, irq_array, flag2_array, num); /* 独占读临界区2 */ xwos_splk_rdex_unlock_irqsrs(\u0026lock2, irq_array, flag2_array, num); /* 独占读临界区1 */ xwos_splk_rdex_unlock_irqsrs(\u0026lock1, irq_array, flag1_array, num); 独占读临界区 对 线程 、 中断底半部 是安全的。 独占读临界区 内，只关闭抢占和中断底半部。 可以理解为在线程和中断底半部层面， 独占读临界区 内的操作是 原子的 ， 独占读临界区 内的数据只能被 线程 和 中断底半部 上下文访问。 独占读临界区 内不会发生 调度 ，但用户依然不能在 独占读临界区 内使用会导致 睡眠 与 阻塞 的CAPI。 xwos_splk_rdex_lock_bh() ：上锁，关闭抢占、中断底半部 xwos_splk_rdex_trylock_bh() ：尝试上锁，关闭抢占、中断底半部 xwos_splk_rdex_unlock_bh() ：解锁，开启抢占、中断底半部 xwos_splk_rdex_lock_bh(\u0026lock); /* 独占读临界区 */ xwos_splk_rdex_unlock_bh(\u0026lock); CAPI参考 头文件 \u003cxwos/osal/lock/seqlock.h\u003e ","categories":["XWOS"],"description":"XWOS的顺序锁\n","excerpt":"XWOS的顺序锁\n","ref":"/docs/TechRefManual/Lock/Seqlock/","tags":"","title":"顺序锁"},{"body":"CAPI参考 头文件 \u003cxwos/osal/lock/seqlock.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/lock/seqlock.h\u003e ","ref":"/docs/UserManual/App/Lock/Seqlock/","tags":"","title":"顺序锁"},{"body":"概述 条件量是操作系统比较底层的同步机制，可以同时阻塞多个线程。当条件成立，条件量可以唤醒一个或所有正在等待的线程。\n操作系统或语言库都提供了条件量的功能，例如：\nPOSIX的 pthread_cond_t C++的 std::condition_variable Java的 java.util.concurrent.locks.Condition Python的 threading.Condition Rust的 std::sync::condvar 线程需要在持有 互斥锁 的情况下去等待条件量， 条件量阻塞线程时会同步释放 互斥锁 。当条件成立，线程被唤醒时，条件量会自动上锁 互斥锁 。 等待条件量发生错误时，条件量也会自动上锁 互斥锁 后再返回。\nXWOS的条件量的功能类似，主要包括以下操作：\n线程 A 等待条件量的 条件成立 而阻塞； 另一个线程 B 或中断上下文或其他上下文通过 单播 或 广播 使 条件成立 ，并唤醒条件量上阻塞的线程 A 。 线程 A 持有 锁 的情况下去等待条件量，会自动解锁； 线程 A 持有 锁 的情况下去等待条件量，当等到 条件成立 时，会自动上锁； 线程 A 持有 锁 的情况下去等待条件量，当发生错误返回时， 不会 自动上锁； 支持多种锁类型： 互斥锁 自旋锁 顺序锁 自定义的加锁与解锁函数 支持没有伴生锁的情况下操作。 条件量对象与对象描述符描述符 条件量对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，条件量对象也用 条件量对象描述符 xwos_cond_d 来解决有效性和身份合法性的问题。\n条件量对象描述符由 条件量对象的指针 和 标签 组成：\ntypedef struct { struct xwos_cond * cond; /**\u003c 条件量对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_cond_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n条件量的初始化、销毁与动态创建、删除 静态初始化、销毁 静态初始化： xwos_cond_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的条件量： xwos_cond_fini() 动态创建、删除 动态创建： xwos_cond_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的条件量： xwos_cond_delete() 单播 xwos_cond_unicast() 可用来在 任意 上下文使得条件量的条件成立，但只唤醒一个线程。 单播不会产生 选者信号 。\n广播 xwos_cond_broadcast() 可用来在 任意 上下文使得条件量的条件成立，唤醒全部线程。 广播 还会使得条件量向绑定的 信号选择器 发送 选择信号 。\n等待条件量 xwos_cond_wait() ：等待条件量，只能在 线程 上下文使用 xwos_cond_wait_to() ：限时等待条件量，只能在 线程 上下文使用 xwos_cond_wait_unintr() ：不可中断等待条件量，只能在 线程 上下文使用 当使用了带附作用的上锁函数时，例如：\nxwos_splk_lock_cpuirq() xwos_splk_lock_cpuirqsv() xwos_splk_lock_irqs() xwos_splk_lock_bh() xwos_sqlk_wr_lock_cpuirq() xwos_sqlk_wr_lock_cpuirqsv() xwos_sqlk_wr_lock_irqs() xwos_sqlk_wr_lock_bh() xwos_sqlk_rdex_lock_cpuirq() xwos_sqlk_rdex_lock_cpuirqsv() xwos_sqlk_rdex_lock_irqs() xwos_sqlk_rdex_lock_bh() 等待条件量 不会管理调度器开关、中断开关以及中断底半部开关。 等待之前是什么状态，无论返回值是 XWOK 还是错误码，等待之后还是什么状态。\nXWOS的条件量与 pthread_cond_t 不同：\nXWOS的条件量， 等待条件量 返回值为 XWOK 时才会对锁进行上锁，如果返回错误码，是否上锁不确定。 pthread_cond_wait() 无论如何都会等待互斥锁被上锁时才返回。 冻结与解冻 冻结 条件量可以使用 xwos_cond_freeze() 进行 冻结， 被冻结的条件量不能被 单播 和 广播 ，但不影响 等待 操作。\n解冻 通过 xwos_cond_thaw() 可将已经冻结的条件量 解冻 。 条件量 解冻 后，可重新 单播 和 广播 。\n绑定与解绑信号选择器 可以通过 xwos_cond_bind() 将条件量绑定到 信号选择器 上。 当 广播 条件量时，条件量会向 信号选择器 发送一个 选择信号 。此时 信号选择器 会唤醒正在等待的线程。此外， 单播 不会产生 选者信号 。\n绑定后的条件量可以通过 xwos_cond_unbind() 解绑。\n条件量对象的生命周期管理 条件量对象的基类是 XWOS对象 struct xwos_object 。 条件量对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_cond_grab() ：增加引用计数。 xwos_cond_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_cond_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_cond_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 API参考 头文件 \u003cxwos/osal/sync/cond.h\u003e ","categories":["XWOS"],"description":"XWOS的条件量\n","excerpt":"XWOS的条件量\n","ref":"/docs/TechRefManual/Sync/Cond/","tags":"","title":"条件量"},{"body":"API参考 头文件 \u003cxwos/osal/sync/cond.h\u003e ","categories":"","description":"","excerpt":"API参考 头文件 \u003cxwos/osal/sync/cond.h\u003e ","ref":"/docs/UserManual/App/Sync/Cond/","tags":"","title":"条件量"},{"body":" 玄武操作系统（XWOS®）开发于2015年，是一款运行在嵌入式微控制器上的通用实时操作系统， 主要面向可靠、实时、安全的应用领域，包括汽车、物联网、工控等。\nXWOS的源码遵循 MISRA-C:2012 标准，已经在汽车行业有越来越多的量产项目。\n","categories":"","description":"","excerpt":" 玄武操作系统（XWOS®）开发于2015年，是一款运行在嵌入式微控制器上的通用实时操作系统， 主要面向可靠、实时、安全的应用领域，包括汽 …","ref":"/docs/","tags":"","title":"文档"},{"body":"概述 XWOS的循环队列（xwcq）是由 NUM 个大小为 SIZE 的数据缓冲区组成的队列。 这些缓冲区首尾相连，形成一个环。\npie title 循环队列 \"数据缓冲区0\" : 1 \"数据缓冲区1\" : 1 \"数据缓冲区2\" : 1 \"数据缓冲区3\" : 1 \"数据缓冲区4\" : 1 \"数据缓冲区5\" : 1 \"数据缓冲区6\" : 1 \"数据缓冲区7\" : 1 消息可发送到队列的头部，也可以发送到队列的尾部。 消息可以从队列的头部接收，也可以从队列的尾部接收。\n循环队列对象与对象描述符描述符 循环队列对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，循环队列对象也用 循环队列对象描述符 xwcq_d 来解决有效性和身份合法性的问题。\n循环队列对象描述符由 循环队列对象的指针 和 标签 组成：\ntypedef struct { struct xwcq * cq; /**\u003c 循环队列对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwcq_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n局限性 循环队列有自己数据缓冲区，用户的消息会被拷贝到数据缓冲区内，用户不必额外申请动态内存。 但循环队列缓冲区大小是固定的，用户只能发送小于等于缓冲区大小的数据。\n循环队列的静态初始化、销毁 静态初始化： xwcq_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 初始化循环队列时，需要预先定义数据缓冲区。 #define BRDCQ_SIZE 64 #define BRDCQ_NUM 8 XWCQ_DEF_MEMPOOL(brdcq_mempool, BRDCQ_SIZE, BRDCQ_NUM); struct xwcq brdcq; xwer_t brd_init_xwcq(void) { return xwcq_init(\u0026brdcq, BRDCQ_SIZE, BRDCQ_NUM, brdcq_mempool); } 销毁静态初始化的信号量： xwcq_fini() 循环队列的动态创建、删除 XWOS并未提供基于动态内存管理的创建与删除CAPI。\n发送消息 入队 入队 是指将消息发送到循环队列的 尾端 。 如果循环队列数据已被填满，循环队列会循环回队列 首端 的位置，覆盖掉原数据。\nxwcq_eq() ：可在 任意 上下文使用 插队 插队 是指将消息发送到循环队列的 首端 。 如果循环队列数据已被填满，循环队列会循环回队列 尾端 的位置，覆盖掉原数据。\nxwcq_jq() ：可在 任意 上下文使用 接收消息 接收消息 是指从循环队列中 取走 消息，消息取走后不再存在于循环队列。\n首端接收 xwcq_dq() ：等待消息，只能在 线程 上下文使用 xwcq_dq_to() ：限时等待消息，只能在 线程 上下文使用 xwcq_dq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwcq_trydq() ：尝试获取消息，可在 任意 上下文使用 尾端离队 xwcq_rq() ：等待消息，只能在 线程 上下文使用 xwcq_rq_to() ：限时等待消息，只能在 线程 上下文使用 xwcq_rq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwcq_tryrq() ：尝试获取消息，可在 任意 上下文使用 拷贝消息 拷贝消息 是指从循环队列中 拷贝 消息，不会从循环队列中删除消息。\n首端拷贝 xwcq_pfq() ：等待消息，只能在 线程 上下文使用 xwcq_pfq_to() ：限时等待消息，只能在 线程 上下文使用 xwcq_pfq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwcq_trypfq() ：尝试获取消息，可在 任意 上下文使用 尾端拷贝 xwcq_prq() ：等待消息，只能在 线程 上下文使用 xwcq_prq_to() ：限时等待消息，只能在 线程 上下文使用 xwcq_prq_unintr() ：不可中断地等待消息，只能在 线程 上下文使用 xwcq_tryprq() ：尝试获取消息，可在 任意 上下文使用 清空循环队列 用户可以通过 xwcq_flush() 将循环队列恢复到初始化状态。\n获取循环队列容量 用户可以通过 xwcq_get_capacity() 获取循环队列的容量。 循环队列的容量是指数据缓冲区中数据槽的数量，也即是 xwcq_init() 的第三个参数。\n获取循环队列单个数据槽的大小 用户可以通过 xwcq_get_size() 获取单个数据槽的大小。 也即是 xwcq_init() 的第二个参数。\n获取循环队列中有效数据槽的数量 用户可以通过 xwcq_get_availability() 获取循环队列中有效数据槽的数量。 有效数据槽是指包含了可被接收数据的数据槽。\n循环队列对象的生命周期管理 循环队列对象的基类是 XWOS对象 struct xwos_object 。 循环队列对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwcq_grab() ：增加引用计数。 xwcq_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwcq_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwcq_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwmd/isc/xwcq.h\u003e ","categories":["XWOS"],"description":"","excerpt":"概述 XWOS的循环队列（xwcq）是由 NUM 个大小为 SIZE 的数据缓冲区组成的队列。 这些缓冲区首尾相连，形成一个环。\npie …","ref":"/docs/TechRefManual/Isc/Xwcq/","tags":"","title":"循环队列"},{"body":"内存模型 与标准库一样，XWOS的原子操作分为6种内存模型：\nxwaop_mo_relaxed 松散序，不作任何内存屏障操作。\nxwaop_mo_consume 消费序，会在读操作之间增加 Data dependency barrier 。 这个屏障并不常见，对于常见的x86/ARM都是自动处理 Data dependency barrier 的。 据作者所知，目前只有Alpha架构的CPU需要程序员关注 Data dependency barrier 。 Rust语言干脆连这个内存序都不提供。\nxwaop_mo_acquire 获得序，常常与配合读一起使用，形成 load-acquire 。\nxwaop_mo_release 释放序，常常与配合写一起使用，形成 store-release 。\nxwaop_mo_acq_rel 获得释放序，加载时是 acquire 的，回写时是 release 的。通常用于 读-改-回写 这种原子操作。\nxwaop_mo_seq_cst 一致序，表明CPU对内存的访问顺序是严格按照程序代码（编译后的）的顺序所进行的。这在期刊文献中被称为 Sequential Consistency 。\n原子操作 XWOS提供了原子操作模板库， 基本类型 中定义的各种 基本类型 都可使用原子操作。 XWOS的原子操作库，可以与标准库 \u003cstdatomic.h\u003e 中的原子操作混合使用。\n原子操作函数模板包括：\n读 xwaop_load() ：加载 可以指定6种内存序 xwaop_read() ：读 内存序： xwaop_mo_acquire 写 xwaop_store() ：存储 可以指定6种内存序 xwaop_write() ：写 内存序： xwaop_mo_release 读-改-写 基本运算 xwaop_add() ：加 xwaop_sub() ：减 xwaop_rsb() ：反向减法 内存序： xwaop_mo_acq_rel 位运算 xwaop_and() ：与 xwaop_or() ：或 xwaop_xor() ：异或 内存序： xwaop_mo_acq_rel 位操作 xwaop_s1m() ：将数据掩码部分的位全部置1 xwaop_c0m() ：将数据掩码部分的位全部清0 xwaop_x1m() ：将数据掩码部分的位全部翻转 内存序： xwaop_mo_acq_rel 读-测试-改-写 所有名称匹配正则表达式 xwaop_t.+_then_.+ 的函数 分为两种情况 测试成功，继续执行“改-写”操作，此时内存序为 xwaop_mo_acq_rel 测试失败，相当于读操作，此时内存序为 xwaop_mo_consume 所有原子操作函数的第一个参数均为 基本类型 ，第二个参数是原子数据的指针，例如：\nxwer_t rc; xwsq_a refcnt = v; xwsq_t nv, ov; /* * 测试refcnt是否为0： * + ture: refcnt增加1，nv返回refcnt增加以后的新值，ov返回refcnt增加以前的旧值， * 内存序：acq_rel，rc为返回值XWOK； * + false: nv与ov都返回refcnt的值，内存序：consume，rc为返回值-EACCES； */ rc = xwaop_teq_then_add(xwsq_t, \u0026refcnt, 0, 1, \u0026nv, \u0026ov); 位图原子操作 位图（ xwbmp_t 数组）可进行原子操作，XWOS提供了基本函数库：\n声明 xwbmpaop_define() ：声明原子位图 读 xwbmpaop_t1i() ：测试位图中的某位是否被置1 内存序： consume 写 xwbmpaop_s1all() ：将位图所有位置1 xwbmpaop_c0all() ：将位图所有位清0 内存序： acq_rel 读-改-写 xwbmpaop_s1i() ：将位图中某位置1 xwbmpaop_c1i() ：将位图中某位清0 xwbmpaop_x1i() ：将位图中某位翻转 内存序： acq_rel 读-测试-改-写 所有名字匹配正则表达式 xwbmpaop_.+_then_.+ 的函数 xwbmpaop_t0i_then_s1i() ：测试位图中某位是否为0，如果是，就将它置1 xwbmpaop_t1i_then_c0i() ：测试位图中某位是否为1，如果是，就将它清0 xwbmpaop_fls_then_c0i() ：从最高位起查找位图中第一个为1的位并将它清0 xwbmpaop_flz_then_s1i() ：从最高位起查找位图中第一个为0的位并将它置1 xwbmpaop_ffs_then_c0i() ：从最低位起查找位图中第一个为1的位并将它清0 xwbmpaop_ffz_then_s1i() ：从最低位起查找位图中第一个为0的位并将它置1 分为两种情况 测试成功，继续执行“改-写”操作，此时内存序为 xwaop_mo_acq_rel 测试失败，相当于读操作，此时内存序为 xwaop_mo_consume API参考 原子操作\n头文件 \u003cxwos/lib/xwaop.h\u003e 位图原子操作\n头文件 \u003cxwos/lib/xwbmpaop.h\u003e ","categories":["XWOS"],"description":"XWOS的原子操作库\n","excerpt":"XWOS的原子操作库\n","ref":"/docs/TechRefManual/Xwlib/Xwaop/","tags":"","title":"原子操作库"},{"body":"基于Eclipse的IDE（例如：STM32CubeIDE、S32DS、NucleiStudio等）的设置方法相似。\n编译设置 菜单： Project –\u003e Properties\n选择卡： C/C++ Build\nBuild Settings\n关闭Eclipse自动生成 Makefile 的功能； 设置 buid directory 为 电路板目录 ，使用XWOS自带的编译系统。 Build Behavior 设置 build 的目标为 all 或置空； 设置 clean 的目标为 d 。 环境变量设置 菜单 Project –\u003e Properties 选择卡 C/C++ Build –\u003e Environment 设置 WKSPC ：编译时输出文件的路径； V : 设置为 1 可在编译时显示指令； D 设置为 1 时，编译器的优化不会影响调试； 设置为 0 时，编译器的优化会影响调试。 Rust插件 菜单： \"Help\" -\u003e \"Install New Software...\" -\u003e \"Add...\" 仓库： http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/ 插件： Corrosion: Rust edition in Eclipse IDE 不同版本的Eclipse与插件存在兼容性问题，需要尝试不同版本的插件。 一般选择 1.2.3 版本的插件即可，不要选择最新的 1.2.4 版本的插件。\n","categories":"","description":"基于Eclipse的IDE的设置指南\n","excerpt":"基于Eclipse的IDE的设置指南\n","ref":"/docs/UserManual/Env/Eclipse/","tags":"","title":"基于Eclipse的IDE设置指南"},{"body":"安装LSP LSP(Language Server Protocol，语言服务协议)是新一代查看源码的神器。 Rust语言的LSP推荐使用rust-analyzer。\ngit clone https://github.com/rust-analyzer/rust-analyzer.git cd rust-analyzer cargo xtask install VScode VSCode需要在安装完成VSCode之后再安装 rust-analyzer 。安装完成后，VSCode是开箱即用的。\nSTM32CubeIDE STM32CubeIDE是基于Eclipse的，因此只需要安装Rust插件。\nRust插件 需要安装版本较新的Rust插件，否则无法支持rust-analyzer。\n菜单： \"Help\" -\u003e \"Install New Software...\" -\u003e \"Add...\" 仓库： http://mirrors.ustc.edu.cn/eclipse/corrosion/releases/1.2.3/ 插件： Corrosion: Rust edition in Eclipse IDE Rust设置 点击 Window -\u003e Rust 检查一下 rustup ， cargo ， rust-analyzer 等的路径是否正确。\n调试 和调试C的代码一样，使用STLink可在STM32CubeIDE中给Rust的代码设置断点。\n已知问题 [2023-04-25] 高版本的STM32CubeIDE(\u003e=1.9.0)安装成功后无法启动插件。 解决方法：不要安装最新(1.2.4)版本的Rust插件，安装1.2.3的插件。 ","categories":"","description":"","excerpt":"安装LSP LSP(Language Server Protocol，语言服务协议)是新一代查看源码的神器。 Rust语言的LSP推荐使 …","ref":"/docs/Note/Rust/Env/","tags":"","title":"Rust开发环境安装笔记"},{"body":"说明 Newlib中，标准头文件 \u003cerrno.h\u003e 的 errno 是一个宏： /* \u003cerrno.h\u003e */ #define errno (*__errno()) extern int *__errno (void); int * __errno() { return \u0026_REENT-\u003e_errno; } Newlib的底层代码对errno的处理非常奇怪，会将errno undef掉，然后重新定义成一个 变量 ， 并要求libgloss中提供 变量 定义： /* \u003cnewlib/libc/reent/readr.c\u003e */ #undef errno extern int errno; _ssize_t _read_r (struct _reent *ptr, int fd, void *buf, size_t cnt) { _ssize_t ret; errno = 0; if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 \u0026\u0026 errno != 0) ptr-\u003e_errno = errno; return ret; } /* \u003clibgloss/libnosys/read.c\u003e */ #undef errno extern int errno; int _read (int file, char *ptr, int len) { errno = ENOSYS; return -1; } libgloss提供与平台相关的启动代码、I/O支持、系统函数等，其中libnosys是一个空实现； 移植方法 XWOS在每个线程对象结构体中定义了一个 __errno 变量，并重新覆盖实现了 int * __errno(void) 函数， 返回 当前 线程对象的 __errno 的地址： int * __errno(void) { xwos_thd_d thdd = xwos_cthd_self(); return \u0026thdd.thd-\u003eosthd.libc.error_number; } 当使用 \u003cerrno.h\u003e 中的 errno 宏时，就可获取线程自身的 __errno ，不再依赖libgloss。 ","categories":"","description":"","excerpt":"说明 Newlib中，标准头文件 \u003cerrno.h\u003e 的 errno 是一个宏： /* \u003cerrno.h\u003e */ #define errno …","ref":"/docs/Note/Newlib/errno/","tags":"","title":"errno"},{"body":"移植方法 设置Picolibc的配置 newlib-global-errno 为 true ，不使用 TLS 机制来实现 errno ； 设置Picolibc的配置 errno-function 为 '__errno' ； XWOS在每个线程对象结构体中定义了一个 __errno 变量，并重新覆盖实现了 int * __errno(void) 函数， 返回 当前 线程对象的 __errno 的地址： int * __errno(void) { xwos_thd_d thdd = xwos_cthd_self(); return \u0026thdd.thd-\u003eosthd.libc.error_number; } 当使用 \u003cerrno.h\u003e 中的 errno 宏时，就可获取线程自身的 __errno ，不再依赖libgloss。 ","categories":"","description":"","excerpt":"移植方法 设置Picolibc的配置 newlib-global-errno 为 true ，不使用 TLS 机制来实现 errno ； 设 …","ref":"/docs/Note/Picolibc/errno/","tags":"","title":"errno"},{"body":"C语言 风格：KR 缩进：8空格（不使用TAB） C++语言 风格：Google 缩进：2空格（不使用TAB） Makefile TODO\nShell TODO\nEmacsLisp TODO\nRust语言 TODO\nLua语言 TODO\n","categories":["XWOS"],"description":"XWOS的的代码风格\n","excerpt":"XWOS的的代码风格\n","ref":"/docs/TechRefManual/CodeStyle/","tags":"","title":"代码风格"},{"body":"概述 互斥锁是用来保证不同线程正确访问共享数据的机制。访问共享数据的代码片段被称为临界区。 互斥锁 不可 用在 除线程以外 的其他上下文(Context)。\n当线程等待互斥锁时，线程会被阻塞，并让出CPU的使用权。 互斥锁存在优先级反转问题：\nXWOS互斥锁的优先级反转问题 Photo: xwos.tech / CC-BY\n优先级策略 XWOS内核采取优先级天花板和优先级继承的混会策略解决此问题：\n线程和互斥锁都拥有优先级，它们在创建时需要指定一个 静态优先级 ， 当线程持有互斥锁时，线程可以获取互斥锁的优先级作为 动态优先级 ， 当互斥锁被线程等待时，互斥锁可以获取线程的优先级作为 动态优先级 ， 最终的优先级取 静态优先级 和 动态优先级 较大的一个； 假设线程A优先级低，线程B的优先级中，线程C的优先级高。 线程A已经获得锁的情况下，线程C等待锁。线程C的优先级会传递给锁， 锁的优先级再传递给线程A。线程A的优先级被临时提高至和线程C的优先级一样，线程A不会被线程B抢占。 优先级可以无限继承：假设线程A的优先级最低，线程 T1、T2、...、Tn 的优先级依次递增。 系统中有互斥锁 L、M1、M2、...、Mn 。 假设A持有L，T1持有M1去等待L，T2持有M2去等待M1，T3持有M3去等待M2，以此类推，Tn持有Mn去等待Mn-1。 由此形成优先级传递链： Tn-\u003eMn-1-\u003eTn-1-\u003e...-\u003eM3-\u003eT3-\u003eM2-\u003eT2-\u003eM1-\u003eT1-\u003eL-\u003eA ， Tn的优先级将会依次传递到 Mn-1、Tn-1、... 、M3、T3、M2、T2、M1、T1、L、A 。 互斥锁树与实时等待队列 如何寻找互斥锁与线程的 动态优先级 ，是寻找最大值的问题，因此可以采用与 时间树 类似的方法，使用红黑树解决此问题。 节点为互斥锁并查找最大优先级算法被称为 互斥锁树 ；节点为线程并查找最大优先级算法被称为 实时等待队列 。\n带有最大值指针的红黑树 Photo: xwos.tech / CC-BY\n使用一个 rightmost 指针指向最大值，可直接从 rightmost 快速获取最大值，时间复杂度为 O(1) ； rightmost 从红黑树中删除时，按照二叉树的性质，下一任 rightmost 是前任的左孩子（即前驱）。 如果前任的前驱为叶子，下一任 rightmost 一定是前任的父节点，算法时间复杂度为 O(1) ； 删除 rightmost 在系统中是一个高频次的操作，但由于 rightmost 缺少右子树，根据红黑树性质，左子树也不可能太复杂， 意味着删除 rightmost 后，调整红黑树的代价不会太大； 插入操作需要遍历树，时间复杂度为 O(logn) ； 红黑树中不允许存在关键字相等的节点，因此拥有相同优先级的节点相互连接成链表； 互斥锁解锁时，从等待队列中选择最高优先级的线程获取互斥锁，若最高优先级的线程不止一个，按照先进先出的方法选取线程。 互斥锁对象与对象描述符描述符 互斥锁对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，互斥锁对象也用 互斥锁对象描述符 xwos_mtx_d 来解决有效性和身份合法性的问题。\n互斥锁对象描述符由 互斥锁对象的指针 和 标签 组成：\ntypedef struct { struct xwos_mtx * mtx; /**\u003c 互斥锁对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_mtx_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n使用互斥锁 静态初始化和销毁互斥锁 静态初始化： xwos_mtx_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的互斥锁： xwos_mtx_fini() 动态创建和删除互斥锁 动态创建： xwos_mtx_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的互斥锁： xwos_mtx_delete() 上锁 xwos_mtx_lock() 等待并上锁互斥锁，只能在 线程 上下文使用 xwos_mtx_trylock() 尝试上锁互斥锁，不会阻塞调用线程，只能在 线程 上下文使用 xwos_mtx_lock_to() 限时等待上锁互斥锁，只能在 线程 上下文使用 xwos_mtx_lock_unintr() 等待并上锁互斥锁，且等待不可被中断，只能在 线程 上下文使用 解锁 xwos_mtx_unlock() 解锁互斥锁，只能在 线程 上下文使用 获取锁的状态 xwos_mtx_get_lkst() 获取锁的状态 互斥锁对象的生命周期管理 互斥锁对象的基类是 XWOS对象 struct xwos_object 。 互斥锁对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_mtx_grab() ：增加引用计数。 xwos_mtx_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_mtx_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_mtx_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwos/osal/lock/mtx.h\u003e ","categories":["XWOS"],"description":"XWOS的互斥锁\n","excerpt":"XWOS的互斥锁\n","ref":"/docs/TechRefManual/Lock/Mutex/","tags":"","title":"互斥锁"},{"body":"CAPI参考 头文件 \u003cxwos/osal/lock/mtx.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/lock/mtx.h\u003e ","ref":"/docs/UserManual/App/Lock/Mutex/","tags":"","title":"互斥锁"},{"body":"XWOS所有配置文件都集中于 电路板名称/cfg ，以XWOS内置的工程 WeActMiniStm32H750 为例， 电路板名称 为 XWOS/xwbd/WeActMiniStm32H750 ， 配置 位于 XWOS/xwbd/WeActMiniStm32H750/cfg 。\n配置的详细说明，参考 技术参考手册/配置 。\nXWOS的配置使用C语言的头文件和宏定义来实现。\n","categories":"","description":"","excerpt":"XWOS所有配置文件都集中于 电路板名称/cfg ，以XWOS内置的工程 WeActMiniStm32H750 为例， …","ref":"/docs/UserManual/App/Cfg/","tags":"","title":"配置"},{"body":"概述 XWOS提供了日志框架，用户可以输出带有等级的日志：\nVERBOSE，等级1，冗长 DEBUG，等级2，调试 INFO，等级3，信息 NOTICE，等级4，提醒 WARNING，等级5，警告 ERR，等级6，错误 CRIT，等级7，危险 EMERG，等级8，紧急 用户可以通过配置 XWLIBCFG_XWLOG_LEVEL 来控制各种等级的日志是否输出：\n当等级大于等于 XWLIBCFG_XWLOG_LEVEL 的日志才会输出， 当 XWLIBCFG_XWLOG_LEVEL 配置为 0 将关闭所有日志。 XWOS的日志框架需要用户在BSP中提供后端驱动接口，以决定日志最终输出到串口、SD卡、还是别的设备：\n当配置 SOCCFG_LOG 为 1 时，BSP中需要提供函数 soc_log_write() ； 当配置 BRDCFG_LOG 为 1 时，BSP中需要提供函数 board_log_write() ； 当配置 SOCCFG_LOG 与配置 BRDCFG_LOG 同时为 1 时， SOCCFG_LOG 具有更高优先级； API参考 头文件 \u003cxwos/lib/xwlog.h\u003e ","categories":["XWOS"],"description":"XWOS的日志\n","excerpt":"XWOS的日志\n","ref":"/docs/TechRefManual/Xwlib/Log/","tags":"","title":"日志"},{"body":"概述 当系统需要处理很多事件，如果每个事件都绑定一个特定的条件量， 每个条件量又由一个线程进行等待处理，会导致系统需要大量内存来创建条件量和线程。\n事件标志使用位图来管理一组事件，位图中的每个位代表一个事件， 当一个或多个事件状态发生变化时，事件对应的位也会发生变化，并唤醒正在等待的线程。 线程唤醒后，就可从事件位图中获取事件的状态。\n线程可以等待位图中的事件位被置 1 ，也可以等待事件位被清 0 。 线程可以等待位图中的事件位同时被置 1 （事件与事件之间是逻辑 与 的关系），也可以等待其中任意一个位被置 1 （事件与事件之间是逻辑 或 的关系）。 线程可以等待位图中的事件位同时被清 0 （事件与事件之间是逻辑 与 的关系），也可以等待其中任意一个位被清 0 （事件与事件之间是逻辑 或 的关系）。 线程可以选择是否 消费 事件。 消费 事件是指，当事件到来，线程被唤醒时，可以选择是否 清除 事件。 线程可以等待事件标志位发生 翻转 ， 翻转 是指事件标志位由 1 变为 0 ，或由 0 变为 1 。 事件标志对象与对象描述符描述符 事件标志对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，事件标志对象也用 事件标志对象描述符 xwos_flg_d 来解决有效性和身份合法性的问题。\n事件标志对象描述符由 事件标志对象的指针 和 标签 组成：\ntypedef struct { struct xwos_flg * flg; /**\u003c 事件标志对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_flg_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n事件标志的初始化、销毁与动态创建、删除 静态初始化、销毁 静态初始化： xwos_flg_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的事件标志 xwos_flg_fini() 动态创建、删除 动态创建： xwos_flg_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的事件标志 xwos_flg_delete() 产生事件 XWOS提供6个CAPI产生触发事件：\nxwos_flg_s1m() ：同时设置多个事件标志位，可在 任意 上下文使用 xwos_flg_s1i() ：设置单个事件标志位，可在 任意 上下文使用 xwos_flg_c0m() ：同时清除多个事件标志位，可在 任意 上下文使用 xwos_flg_c0i() ：清除单个事件标志位，可在 任意 上下文使用 xwos_flg_x1m() ：同时翻转多个事件标志位，可在 任意 上下文使用 xwos_flg_x1i() ：翻转单个事件标志位，可在 任意 上下文使用 这些CAPI除了会修改事件标志位图的状态，还会通过 广播 唤醒所有正在等待的线程。 然后，线程通过比对位图状态，确定事件是否已经满足触发条件。 若满足触发条件，就退出等待；若未满足触发条件，重新进入阻塞等待状态。\n获取事件的状态 xwos_flg_get_num() 获取事件标志中总共有多少个事件 xwos_flg_read() 直接读取事件的位图状态。此函数立即返回，不会阻塞 等待事件 xwos_flg_wait() ：等待事件，只能在 线程 上下文使用 xwos_flg_wait_to() ：限时等待事件，只能在 线程 上下文使用 xwos_flg_trywait() ：检查事件，可在 任意 上下文使用 触发条件 当调用等待事件的CAPI时，需要指定触发条件（参数： trigger ）。触发条件分为 电平触发 和 边沿触发 。\n电平触发 电平触发 源于数字电路，是一种类比概念，是指事件位的特定的状态（ 1 或 0 ）所产生的触发信号，下面的触发条件均为电平触发：\nXWOS_FLG_TRIGGER_SET_ALL ：所有事件位被置 1 XWOS_FLG_TRIGGER_SET_ANY ：任意事件位被置 1 XWOS_FLG_TRIGGER_CLR_ALL ：所有事件位被清 0 XWOS_FLG_TRIGGER_CLR_ANY ：任意事件位被清 0 边沿触发 边沿触发 源于数字电路，是一种类比概念，是指事件状态发生改变（ 1 变 0 或 0 变 1 ）时产生的唤醒信号，下面的触发条件为边沿触发：\nXWOS_FLG_TRIGGER_TGL_ALL ：所有事件位发生翻转 XWOS_FLG_TRIGGER_TGL_ANY ：任意事件位发生翻转 边沿触发时，必须要有一个初始状态，就像数字电路一样：\n当位的初始值为 0 (低电平)，然后跳变到 1 (高电平)的瞬间被称为上升沿。此时触发的事件被称为上升沿触发。 当位的初始值为 1 (高电平)，然后跳变到 0 (低电平)的瞬间被称为下降沿。此时触发的事件被称为下降沿触发。 清除事件 当采用 电平触发 时，需要在读取事件位图后 清除 事件标志位，否则事件会一直处于触发状态。 可以在调用CAPI时，指定参数 action 为 XWOS_FLG_ACTION_CONSUMPTION 。 清除 的含义是： 当线程等待的是位图中的事件位被置 1 ， 清除 是指将这些位清 0 ； 当线程等待的是位图中的事件位被清 0 ， 清除 是指将这些位置 1 ； 当采用 边沿触发 时，不需要 清除 事件的触发条件。 绑定与解绑信号选择器 可以通过 xwos_flg_bind() 将事件标志绑定到 信号选择器 上。 当等待的事件发生时，事件标志会向 信号选择器 发送一个 选择信号 。此时 信号选择器 会唤醒正在等待的线程。\n绑定后的事件标志可以通过 xwos_flg_unbind() 解绑。\n事件标志对象的生命周期管理 事件标志对象的基类是 XWOS对象 struct xwos_object 。 事件标志对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_flg_grab() ：增加引用计数。 xwos_flg_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_flg_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_flg_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 API参考 头文件 \u003cxwos/osal/sync/flg.h\u003e ","categories":["XWOS"],"description":"XWOS的事件标志\n","excerpt":"XWOS的事件标志\n","ref":"/docs/TechRefManual/Sync/Flg/","tags":"","title":"事件标志"},{"body":"API参考 头文件 \u003cxwos/osal/sync/flg.h\u003e ","categories":"","description":"","excerpt":"API参考 头文件 \u003cxwos/osal/sync/flg.h\u003e ","ref":"/docs/UserManual/App/Sync/Flg/","tags":"","title":"事件标志"},{"body":"","categories":"","description":"XWOS的应用手册\n","excerpt":"XWOS的应用手册\n","ref":"/docs/UserManual/App/","tags":"","title":"应用手册"},{"body":"API参考 CRC8\n头文件 \u003cxwos/lib/crc8.h\u003e CRC32\n头文件 \u003cxwos/lib/crc32.h\u003e ","categories":["XWOS"],"description":"XWOS的CRC算法库\n","excerpt":"XWOS的CRC算法库\n","ref":"/docs/TechRefManual/Xwlib/Crc/","tags":"","title":"CRC"},{"body":"局限性 开发XWOS RUST的过程中，需要将库与应用的代码分离在不同的crate中，在实践过程中， 发现RUST有如下局限：\n不能将两个crate都编译成staticlib，staticlib的crate不可列举在 [dependencies] ， 说明staticlib是用来给C/C++调用的； 只有rlib的crate列举在 [dependencies] ，编译staticlib时， 所有 [dependencies] 内的crates都会打包在staticlib内； 与C/C++代码链接时，不可存在两个以上的staticlib，除非这些staticlib的依赖完全 无关系（事实上这很难实现），否则会出现重复定义的链接错误。 方案 通过实践，研究出解决方案：\n将 xwrust_main() 移动到一个电路板模块 bm/rustapp 中，此模块编译成staticlib； 所有RUST的应用只能集中在rustapp内； 其他crates只作为 rustapp的 [dependencies] ； 其他crate设置为 crate-type = [\"rlib\"] ，并删除 xwmo.mk ，不再使用XWOS的编译系统进行编译。 实验代码 代码仓库：git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750.git commit cd XWOS git pull git checkout -b rust-multicrates 4d0837bfe227a6316288e4f1fa60a15276504159 ","categories":"","description":"","excerpt":"局限性 开发XWOS RUST的过程中，需要将库与应用的代码分离在不同的crate中，在实践过程中， 发现RUST有如下局限：\n不能将两 …","ref":"/docs/Note/Rust/MultiCrates/","tags":"","title":"支持多个单元包"},{"body":"概述 线程本地存储(TLS)是指线程私有的变量。\nC11标准开始支持线程本地存储，并引入 _Thread_local 关键字，C2X标准引入 thread_local 关键字。 gcc以及clang编译器还引入关键字 __thread 。\n当用以上关键字定义全局变量时，每个线程都会拷贝一份此全局变量的副本，然后各自访问各自的副本。\nTLS的模型 gcc以及clang对TLS的实现，有4种模型：\n-ftls-model=global-dynamic ：动态链接时使用，必须配合编译选项 -fpic 才有效，要求给出 __tls_get_addr() 的定义， 若不配合 -fpic ，实际会变成 -ftls-model=initial-exec ； -ftls-model=local-dynamic ：动态链接时使用，必须配合编译选项 -fpic 才有效，要求给出 __tls_get_addr() 的定义， 若不配合 -fpic ，实际会变成 -ftls-model=initial-exec ； -ftls-model=initial-exec ：静态链接时使用，要求给出 __aeabi_read_tp() 的定义，此函数会返回线程 .tdata 段的首地址。 然后从 .got 段中获取TLS变量的 OFFSET ， 即 OFFSET = GOT[name] 。最终，变量的地址为 __aeabi_read_tp() + OFFSET 。 -ftls-model=local-exec ：静态链接时使用，要求给出 __aeabi_read_tp() 的定义，此函数会返回线程 .tdata 段的首地址。 然后TLS变量的 OFFSET 是以立即数形式获取。最终，变量的地址为 __aeabi_read_tp() + OFFSET 。 相对于 -ftls-model=initial-exec 少了一次内存访问的操作，效率是4种模型中最高的。 XWOS TLS的实现 XWOS同时支持 -ftls-model=initial-exec 和 -ftls-model=local-exec，因此，需要在链接脚本中将 .got 段放入：\n.got : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) } \u003e code_mr AT\u003e code_mr ","categories":"","description":"","excerpt":"概述 线程本地存储(TLS)是指线程私有的变量。\nC11标准开始支持线程本地存储，并引入 _Thread_local 关键字，C2X …","ref":"/docs/Note/Newlib/TLS/","tags":"","title":"线程本地存储"},{"body":"","categories":"","description":"各种SOC平台移植XWOS的说明\n","excerpt":"各种SOC平台移植XWOS的说明\n","ref":"/docs/UserManual/Soc/","tags":"","title":"XWOS移植说明"},{"body":"配置 XWOS所有配置文件都集中于 电路板名称/cfg 文件夹中：\ncfg/project.h ：工程配置文件 cfg/arch.h ：ARCH配置 cfg/cpu.h ：CPU配置 cfg/soc.h ：SOC配置 cfg/board.h ：电路板配置 cfg/xwos.h ：内核配置 cfg/xwmd.h ：中间件配置 cfg/xwcd.h ：芯片与外设配置 cfg/xwem.h ：第三方组件配置 cfg/xwam.h ：应用配置 cfg/oem.h ：OEM模块配置 cfg/autogen.h ：自动生成的配置 配置说明 XWOS在设计之初曾考虑过使用现成的配置生成工具，例如Linux内核的Kconfig工具。 但为了降低跨平台开发的工作量和难度，最终选择使用C语言的头文件来描述所有配置。\nproject.h ：工程配置文件 ARCH XWCFG_ARCH ：架构，可在 xwcd/soc/ 中选择 架构文件夹 XWCFG_SUBARCH ：子架构，可在 架构文件夹 中选择 子架构文件夹 XWCFG_COMPILER ：编译器 gcc ：选择gcc作为编译器 llvm / clang ：选择clang作为编译器 XWCFG_LIBC ：标准C库，目前支持 newlib ：选择newlib作为C库 picolibc ：选择picolibc作为C库 n ：不链接到C库 XWCFG_LDSCRIPT ：链接脚本的的相对路径，相对于 电路板文件夹 CPU XWCFG_CPU ：CPU子集，可在 架构文件夹 中选择 CPU文件夹 SOC XWCFG_SOC ：片上系统，可在 CPU文件夹 中选择 SOC文件夹 电路板 XWCFG_BOARD ：电路板，可在 xwbd/ 中选择 电路板文件夹 内核配置 XWCFG_CORE ：单核与多核的选择，可选择编译 xwos/ 下的哪种内核 mp ：多核 up ：单核 XWCFG_XWCD ：是否需要引用芯片、驱动库，路径 xwcd/ ，取值： 1 或 0 XWCFG_XWMD ：是否需要引用中间件库，路径 xwmd/ ，取值： 1 或 0 XWCFG_XWEM ：是否需要引用第三方组件库，路径 xwem/ ，取值： 1 或 0 XWCFG_XWAM ：是否需要引用应用组件库，路径 xwam/ ，取值： 1 或 0 XWCFG_OEMPATH ：OEM模块的搜索路径 可以是相对路径，相对于 $(XWOS_BRD_DIR) 可以为绝对路径 路径可指向XWOS根目录之外 arch.h ：ARCH配置 数据大小端选择，只可选择一种配置为 1 ： ARCHCFG_LITTLE_ENDIAN ：小端 ARCHCFG_BIG_ENDIAN ：大端 架构位宽，只可选择一种配置为 1 ： ARCHCFG_32BIT ：32位 ARCHCFG_64BIT ：64位 浮点单元 ARCHCFG_FPU ：是否包含浮点单元，取值： 1 或 0 C标准库 ARCHCFG_COMPILER_ERRNO ：是否使用libc的 errno.h 中定义的错误码，取值： 1 或 0 位操作与原子操作 ARCHCFG_LIB_XWBOP_\u003cOP\u003e ：是否使用汇编实现的位操作函数\u003cOP\u003e，取值： 1 或 0 ARCHCFG_LIB_XWBMPOP_\u003cOP\u003e ：是否使用汇编实现的位图操作函数\u003cOP\u003e，取值： 1 或 0 ARCHCFG_LIB_XWAOP_\u003cOP\u003e ：是否使用汇编实现的原子操作函数集\u003cOP\u003e，取值： 1 或 0 ARCHCFG_LIB_XWBMPAOP_\u003cOP\u003e ：是否使用汇编实现的位图原子操作函数集\u003cOP\u003e，取值： 1 或 0 cpu.h ：CPU配置 CPUCFG_CPU_NUM ：CPU数量，仅仅对SMP的系统有效 CPUCFG_L1_CACHELINE_SIZE ：L1缓存的CacheLine大小，仅对有1级缓冲的SOC有效 soc.h ：SOC配置 ARM-M SOCCFG_EXC_NUM ：SOC异常数量，固定为16 SOCCFG_IRQ_NUM ：SOC外设中断数量 SOCCFG_NVIC_PRIO_BITNUM ：ARM-M中断优先级寄存器的位数 SOCCFG_NVIC_SUBPRIO_BITIDX ：ARM-M子中断优先级从第几位开始 SOCCFG_BUG ：SOC是否提供 soc_bug() 的定义，取值： 1 或 0 SOCCFG_CRC32 ：SOC是否提供 CRC32 计算单元，取值： 1 或 0 SOCCFG_CRC8 ：SOC是否提供 CRC8 计算单元，取值： 1 或 0 nuclei RISC-V bumblebee (rv32imac) SOCCFG_EXC_NUM ：SOC异常数量，固定为16 SOCCFG_IRQ_NUM ：SOC外设中断数量 SOCCFG_BUG ：SOC是否提供 soc_bug() 的定义，取值： 1 或 0 SOCCFG_CRC32 ：SOC是否提供CRC32计算单元，取值： 1 或 0 SOCCFG_CRC8 ：SOC是否提供CRC8计算单元，取值： 1 或 0 EPPC (e200z0) SOCCFG_EXC_NUM ：SOC异常数量，固定为9 SOCCFG_IRQ_NUM ：SOC外设中断数量 SOCCFG_SYSHWT_SRCCLK ：滴答定时器的频率 SOCCFG_SYSHWT_CHANNEL ：滴答定时器的通道 SOCCFG_CLK_FXOSC ：是有启用外部快速晶振 SOCCFG_CLK_FXOSC_VALUE ：外部快速晶振的频率 SOCCFG_CLK_FXOSC_DIV ：外部快速晶振的分频系数 SOCCFG_CLK_FIRC ：是否启用内部的快速RC振荡器 SOCCFG_CLK_FIRC_VALUE ：内部快速RC振荡器的频率 SOCCFG_CLK_FIRC_DIV ：内部快速RC振荡器的频率 SOCCFG_CLK_SCOSC ：是否启用外部慢速晶振 SOCCFG_CLK_SCOSC_VALUE ：外部慢速晶振的频率 SOCCFG_CLK_SCOSC_DIV ：外部慢速晶振的分频系数 SOCCFG_CLK_SIRC_VALUE ：内部慢速RC振荡器的频率 SOCCFG_CLK_SIRC_DIV ：内部慢速RC振荡器的分频系数 SOCCFG_CLK_FMPLL_VALUE ：锁相环的频率 SOCCFG_BUG ：SOC是否提供 soc_bug() 的定义，取值： 1 或 0 SOCCFG_BKUP ：是否启用备用RAM区域，取值： 1 或 0 SOCCFG_CRC32 ：SOC是否提供CRC32计算单元，取值： 1 或 0 SOCCFG_CRC8 ：SOC是否提供CRC8计算单元，取值： 1 或 0 board.h ：电路板配置 XWOS HOOK BRDCFG_XWSKD_IDLE_HOOK ：是否使用空闲任务HOOK，取值： 1 或 0 当取值 1 时，需要提供 void board_xwskd_idle_hook(struct xwospl_skd *) 的定义 BRDCFG_XWSKD_PRE_SWCX_HOOK ：是否使用任务切换前HOOK，取值： 1 或 0 当取值 1 时，需要提供 void board_xwskd_pre_swcx_hook(struct xwospl_skd *) 的定义 BRDCFG_XWSKD_POST_SWCX_HOOK ：是否使用任务切换后HOOK，取值： 1 或 0 当取值 1 时，需要提供 void board_xwskd_post_swcx_hook(struct xwospl_skd *) 的定义 BRDCFG_XWSKD_SYSHWT_HOOK ：是否使用系统滴答定时器中断HOOK，取值： 1 或 0 当取值 1 时，需要提供 void board_xwskd_syshwt_hook(struct xwospl_skd *) 的定义 BRDCFG_XWSKD_THD_STACK_POOL ：是否提供了线程栈的内存池，取值： 1 或 0 当取值 1 时，需要提供 xwer_t board_thd_stack_pool_alloc(xwsz_t , xwstk_t **) 与 xwer_t board_thd_stack_pool_free(xwstk_t *) 的定义 BRDCFG_XWSKD_THD_POSTINIT_HOOK ：是否使用线程初始化后HOOK，取值： 1 或 0 当取值 1 时，需要提供 void board_thd_postinit_hook(struct xwospl_thd *) BRDCFG_LOG ：是否支持日志打印，取值： 1 或 0 。取值为 1 时需要提供 board_log_write() 的定义，用于log字符串的输出。 BRDCFG_DCACHE ：是否支持DCACHE，取值： 1 或 0 BRDCFG_ICACHE ：是否支持ICACHE，取值： 1 或 0 二进制标记 BRDCFG_FIRMWARE_TAILFLAG ：定义编译后的bin文件尾的标记字符串，可用于升级功能检查文件是否完整 电路板模块的配置： BMCFG_\u003cmodule\u003e 电路板模块的路径需要按照 构建系统 的规则转换为配置宏，取值： 1 或 0 xwos.h ：内核配置 操作系统相关的配置\nXWKNCFG_CHECK_PARAMETERS ：是否开启API参数检查，取值： 1 或 0 XWKNCFG_BUG ：是否启用BUG调试，取值： 1 或 0 玄武C库： 日志 XWLIBCFG_LOG ：是否启用Log调试，取值： 1 或 0 XWLIBCFG_XWLOG_LEVEL ：最低日志等级； XWLIBCFG_XWLOG_BUFSIZE ：日志格式化缓冲区大小； 系统调用 XWLIBCFG_SC ：是否启用系统调用，取值： 1 或 0 原子操作 XWLIBCFG_XWAOP8 ：是否启用8位原子操作库，取值： 1 或 0 XWLIBCFG_XWAOP16 ：是否启用16位原子操作库，取值： 1 或 0 XWLIBCFG_XWAOP32 ：是否启用32位原子操作库，取值： 1 或 0 XWLIBCFG_XWAOP64 ：是否启用64位原子操作库，取值： 1 或 0 XWLIBCFG_XWBMPAOP ：是否启用位图原子操作库，取值： 1 或 0 数据结构 XWLIBCFG_MAP ：是否启用键值对，取值： 1 或 0 CRC XWLIBCFG_CRC32 ：是否启用CRC32，取值： 1 或 0 XWLIBCFG_CRC32_0X04C11DB7 ：是否启用CRC32多项式0x04C11DB7，取值： 1 或 0 XWLIBCFG_CRC32_0XEDB88320 ：是否启用CRC32多项式0xEDB88320，取值： 1 或 0 XWLIBCFG_CRC8 ：是否启用CRC8，取值： 1 或 0 XWLIBCFG_CRC8_0X07 ：是否启用CRC8多项式0x07，取值： 1 或 0 XWLIBCFG_CRC8_0X31 ：是否启用CRC8多项式0x31，取值： 1 或 0 XWLIBCFG_CRC8_0X9B ：是否启用CRC8多项式0x9B，取值： 1 或 0 长跳转 XWLIBCFG_SETJMP ：是否启用 setjmp()/longjmp() ，取值： 1 或 0 内存管理 XWMMCFG_ALIGNMENT ：内存管理对齐的字节数，通常设置为8字节 XWMMCFG_STACK_ALIGNMENT ：线程栈对齐的字节数，通常设置为8字节 XWMMCFG_STACK_SIZE_DEFAULT ：栈内存的默认大小 XWMMCFG_STACK_SIZE_MIN ：栈内存大小的最小值 XWMMCFG_STACK_GUARD_SIZE_DEFAULT ：栈的默认警戒线位置 XWMMCFG_STACK_CHK_SWCX ：是否在切换上下文时检查栈溢出，取值： 1 或 0 栈的类型，只可选择一种配置为 1 ： XWMMCFG_FD_STACK ：满递减栈 XWMMCFG_ED_STACK ：空递减栈 XWMMCFG_FA_STACK ：满递增栈 XWMMCFG_EA_STACK ：满递增栈 XWMMCFG_MEMSLICE ：是否启用内存切片算法，取值： 1 或 0 XWMMCFG_BMA ：是否启用伙伴算法，取值： 1 或 0 XWMMCFG_MEMPOOL ：是否启用内存池，取值： 1 或 0 内核配置 调度器 XWOSCFG_SYSHWT_PERIOD ：硬件定时器周期，单位纳秒 XWOSCFG_SKD_PRIORITY_RT_NUM ：调度器实时优先级数量，数量越小越省内存 XWOSCFG_SKD_IDLE_STACK_SIZE ：空闲任务栈大小 XWOSCFG_SKD_IDLE_TLS ：是否启用空闲任务的TLS(线程本地私有变量)，取值： 1 或 0 XWOSCFG_SKD_BH ：是否启用中断底半部，取值： 1 或 0 XWOSCFG_SKD_BH_STACK_SIZE ：中断底半部栈大小 XWOSCFG_SKD_BH_TLS ：是否启用中断底半部任务的TLS(线程本地私有变量)，取值： 1 或 0 XWOSCFG_SKD_PM ：是否启用电源管理，此配置只对单核系统有效，多核系统不可关闭电源管理。取值： 1 或 0 XWOSCFG_SKD_THD_PRIVILEGED_DEFAULT ：线程是否默认为特权线程，取值： 1 或 0 XWOSCFG_SKD_THD_MEMPOOL ：是否启用mempool线程对象缓存，取值： 1 或 0 XWOSCFG_SKD_THD_MEMSLICE ：是否启用memslice线程对象缓存，取值： 1 或 0 XWOSCFG_SKD_THD_SMA ：是否启用sma线程对象缓存，取值： 1 或 0 XWOSCFG_SKD_THD_STDC_MM ：是否启用C标准库中的 malloc() 来动态创建线程对象，取值：1 或 0 XWOSCFG_SKD_THD_LOCAL_DATA_NUM ：线程私有数据的数量 XWOSCFG_SKD_THD_EXIT ：是否启用线程退出，取值： 1 或 0 XWOSCFG_SKD_SWT ：是否启用软件定时器，取值： 1 或 0 XWOSCFG_SKD_SWT_MEMPOOL ：是否启用mempool软件定时器对象缓存，取值： 1 或 0 XWOSCFG_SKD_SWT_MEMSLICE ：是否启用memslice软件定时器对象缓存，取值： 1 或 0 XWOSCFG_SKD_SWT_SMA ：是否启用sma软件定时器对象缓存，取值： 1 或 0 XWOSCFG_SKD_SWT_STDC_MM ：是否启用C标准库中 malloc() 来动态创建定时器对象，取值： 1 或 0 同步 XWOSCFG_SYNC_PLSEM ：是否启用管道信号量，取值： 1 或 0 XWOSCFG_SYNC_RTSEM ：是否启用实时信号量，取值： 1 或 0 XWOSCFG_SYNC_SEM_MEMPOOL ：是否启用mempool信号量对象缓存，取值： 1 或 0 XWOSCFG_SYNC_SEM_MEMSLICE ：是否启用memslice信号量对象缓存，取值： 1 或 0 XWOSCFG_SYNC_SEM_SMA ：是否启用sma信号量对象缓存，取值： 1 或 0 XWOSCFG_SYNC_SEM_STDC_MM ：是否启用C标准库中 malloc() 来动态创建信号量对象，取值： 1 或 0 XWOSCFG_SYNC_COND ：是否启用条件量，取值： 1 或 0 XWOSCFG_SYNC_COND_MEMPOOL ：是否启用mempool条件量对象缓存，取值：1 或 0 XWOSCFG_SYNC_COND_MEMSLICE ：是否启用memslice条件量对象缓存，取值：1 或 0 XWOSCFG_SYNC_COND_SMA ：是否启用memslice条件量对象缓存，取值：1 或 0 XWOSCFG_SYNC_COND_STDC_MM ：是否启用C标准库中 malloc() 来动态创建条件量对象，取值： 1 或 0 XWOSCFG_SYNC_EVT ：是否启用事件，取值： 1 或 0 XWOSCFG_SYNC_EVT_MEMPOOL ：是否启用mempool事件对象缓存，取值：1 或 0 XWOSCFG_SYNC_EVT_MEMSLICE ：是否启用memslice事件对象缓存，取值：1 或 0 XWOSCFG_SYNC_EVT_SMA ：是否启用sma事件对象缓存，取值：1 或 0 XWOSCFG_SYNC_EVT_STDC_MM ：是否启用C标准库中 malloc() 来动态创建事件对象，取值： 1 或 0 锁 XWOSCFG_LOCK_MTX ：是否启用互斥锁，取值： 1 或 0 XWOSCFG_LOCK_MTX_MEMPOOL ：是否启用mempool互斥锁对象缓存，取值： 1 或 0 XWOSCFG_LOCK_MTX_MEMSLICE ：是否启用memslice互斥锁对象缓存，取值： 1 或 0 XWOSCFG_LOCK_MTX_SMA ：是否启用sma互斥锁对象缓存，取值： 1 或 0 XWOSCFG_LOCK_MTX_STDC_MM ：是否启用C标准库中 malloc() 来动态创建互斥锁对象，取值：1 或 0 XWOSCFG_LOCK_FAKEMTX ：是否启用虚假互斥锁，取值： 1 或 0 xwmd.h ：中间件配置 XWMDCFG_CHECK_PARAMETERS ：是否开启API参数检查，取值： 1 或 0 XWMDCFG_isc_xwssc ：是否启用点对点通讯协议，取值： 1 或 0 XWMDCFG_isc_xwssc_LOG ：是否开启日志，取值： 1 或 0 XWMDCFG_isc_xwssc_PORT_NUM ：消息通道的数量 XWMDCFG_isc_xwssc_PRI_NUM ：消息优先级的数量 XWMDCFG_isc_xwssc_RETRY_PERIOD ：重发消息的周期 XWMDCFG_isc_xwssc_RETRY_NUM ：重发消息的最大次数 XWMDCFG_isc_xwssc_MEMBLK_SIZE ：用于发送与接收的单位内存块的大小 XWMDCFG_isc_xwssc_MEMBLK_ODR ：单位内存块的数量，以2的n次方形式表示，此处配置的是指数n XWMDCFG_isc_xwssc_RXTHD_PRIORITY ：接收线程的优先级 XWMDCFG_isc_xwssc_TXTHD_PRIORITY ：发送线程的优先级 XWMDCFG_isc_xwmq ：是否启用消息队列，取值： 1 或 0 XWMDCFG_isc_xwcq ：是否启用循环队列，取值： 1 或 0 XWMDCFG_libc ：是否启用libc的适配代码，取值： 1 或 0 XWMDCFG_xwrust_ffi ：是否启用XWOS RUST的底层C语言接口，取值： 1 或 0 xwcd.h：芯片与外设配置 XWCDCFG_CHECK_PARAMETERS ：是否开启API参数检查，取值： 1 或 0 XWCDCFG_ds ：是否启用玄武设备栈，取值： 1 或 0 XWCDCFG_ds_LITE ：是否启用LITE版的玄武设备栈，取值： 1 或 0 XWCDCFG_ds_PM ：是否启用电源管理，取值： 1 或 0 XWCDCFG_ds_SOC ：是否启用SOC，取值： 1 或 0 XWCDCFG_ds_SOC_CLK ：是否启用SOC的Clock，取值： 1 或 0 XWCDCFG_ds_SOC_PWR ：是否启用SOC的Power，取值： 1 或 0 XWCDCFG_ds_SOC_GPIO ：是否启用SOC的GPIO，取值： 1 或 0 XWCDCFG_ds_SOC_EIRQ ：是否启用SOC的外部IO中断，取值： 1 或 0 XWCDCFG_ds_SOC_EIRQ_ROISRT ：SOC外部IO中断向量表是否为 const 的，取值： 1 或 0 XWCDCFG_ds_SOC_DMA ：是否启用SOC的DMA，取值： 1 或 0 XWCDCFG_ds_SOC_DMA_ROCBT ：SOC外部DMA回调函数表是否为 const 的，取值： 1 或 0 XWCDCFG_ds_UART ：是否启用UART，取值： 1 或 0 XWCDCFG_ds_UART_RXQ_SIZE ：UART接收队列的大小 XWCDCFG_ds_I2C_MASTER ：是否启用I2C总线控制器，取值： 1 或 0 XWCDCFG_ds_I2C_PERIPHERAL ：是否启用I2C外设，取值： 1 或 0 XWCDCFG_ds_SPI_MASTER ：是否启用SPI总线控制器，取值： 1 或 0 XWCDCFG_ds_SPI_PERIPHERAL ：是否启用SPI外设，取值： 1 或 0 XWCDCFG_ds_LIN ：是否启用LIN总线，取值： 1 或 0 XWCDCFG_ds_LINID ：是否启用LIN总线的ID校验表，取值： 1 或 0 XWCDCFG_ds_CAN ：是否启用CAN总线，取值： 1 或 0 XWCDCFG_ds_CAN_CONTROLLER ：是否启用CAN控制器，取值： 1 或 0 XWCDCFG_ds_CAN_CONTROLLER_ROCBT ：CAN控制器的回调函数表是否为只读，取值： 1 或 0 XWCDCFG_ds_CAN_CONTROLLER_SDU_MAXSIZE ：CAN消息数据的最大数量 XWCDCFG_ds_CAN_CONTROLLER_RXQNUM ：CAN接收队列的最大数量 XWCDCFG_ds_CAN_CONTROLLER_I2CP ：CAN控制器是否为I2C外设，取值： 1 或 0 XWCDCFG_ds_CAN_CONTROLLER_SPIP ：CAN控制器是否为SPI外设，取值： 1 或 0 XWCDCFG_ds_CAN_TRANSCEIVER ：是否启用CAN接收器，取值： 1 或 0 XWCDCFG_ds_CAN_TRANSCEIVER_I2CP ：CAN接收器是否为I2C外设，取值： 1 或 0 XWCDCFG_ds_CAN_TRANSCEIVER_SPIP ：CAN接收器是否为SPI外设，取值： 1 或 0 XWCDCFG_ds_MISC ：是否启用MISC设备，取值： 1 或 0 XWCDCFG_peripheral_i2c_eeprom ：是否启用I2C EEPROM的驱动，取值： 1 或 0 XWCDCFG_peripheral_spi_flash_w25qxx ：是否启用SPI FLASH W25Q的驱动，取值： 1 或 0 XWCDCFG_peripheral_spi_lcd_st7735 ：是否启用SPI LCD ST7735的驱动，取值： 1 或 0 XWCDCFG_peripheral_can_transceiver_tja1042 ：是否启用CAN收发器TJA1042的驱动，取值： 1 或 0 xwem.h：第三方软件配置 XWEMCFG_serializing_nanopb ：是否启用protobuf-nanopb，取值： 1 或 0 XWEMCFG_fs_fatfs ：是否启用FatFs，取值： 1 或 0 XWEMCFG_fs_littlefs ：是否启用littlefs，取值：1 或 0 XWEMCFG_fs_spiffs ：是否启用spiffs，取值： 1 或 0 XWEMCFG_fs_dhara ：是否启用dhara，取值： 1 或 0 XWEMCFG_vm_lua ：是否启用Lua语言，取值： 1 或 0 XWEMCFG_vm_lua_INT_TYPE ：Lua语言中整数类型 XWEMCFG_vm_lua_FLOAT_TYPE ：Lua语言中浮点类型 XWEMCFG_vm_lua_THD_STACK_SIZE ：Lua交互式解释器线程的栈大小 XWEMCFG_vm_lua_BRDLIBS ：是否启用BSP中Lua库，取值：1 或 0 xwam.h：应用配置 XWAMCFG_example_xwobj ：是否启用示例 玄武对象 ，取值： 1 或 0 XWAMCFG_example_thd_new ：是否启用示例 线程的创建 ，取值： 1 或 0 XWAMCFG_example_thd_exit ：是否启用示例 线程的退出 ，取值： 1 或 0 XWAMCFG_example_thd_sleep ：是否启用示例 线程的睡眠 ，取值： 1 或 0 XWAMCFG_example_swt ：是否启用示例 软件定时器 ，取值： 1 或 0 XWAMCFG_example_lock_cpuirq ：是否启用示例 CPU中断 ，取值： 1 或 0 XWAMCFG_example_lock_mtx ：是否启用示例 互斥锁 ，取值： 1 或 0 XWAMCFG_example_lock_spinlock ：是否启用示例 自旋锁 ，取值： 1 或 0 XWAMCFG_example_lock_seqlock ：是否启用示例 顺序锁 ，取值： 1 或 0 XWAMCFG_example_sync_sem ：是否启用示例 信号量 ，取值： 1 或 0 XWAMCFG_example_sync_cond ：是否启用示例 条件量 ，取值： 1 或 0 XWAMCFG_example_sync_br ：是否启用示例 线程栅栏 ，取值： 1 或 0 XWAMCFG_example_sync_flg ：是否启用示例 事件标志 ，取值： 1 或 0 XWAMCFG_example_sync_sel ：是否启用示例 信号选择器 ，取值： 1 或 0 XWAMCFG_example_mm_sma ：是否启用示例 简单内存分配器 ，取值： 1 或 0 XWAMCFG_example_mm_memslice ：是否启用示例 内存切片分配器 ，取值： 1 或 0 XWAMCFG_example_mm_bma ：是否启用示例 伙伴算法分配器 ，取值： 1 或 0 XWAMCFG_example_xwlib_crc ：是否启用示例 CRC计算 ，取值： 1 或 0 XWAMCFG_example_cxx ：是否启用示例 C++ ，取值： 1 或 0 XWAMCFG_example_isc_xwmq ：是否启用示例 消息队列 ，取值： 1 或 0 XWAMCFG_example_isc_xwcq ：是否启用示例 循环队列 ，取值： 1 或 0 XWAMCFG_application_w25qrpt ：是否启用应用 W25Q读写工具 ，取值： 1 或 0 XWAMCFG_application_ramcode ：是否启用应用 RAMCODE ，取值： 1 或 0 ","categories":["XWOS"],"description":"XWOS的配置\n","excerpt":"XWOS的配置\n","ref":"/docs/TechRefManual/Cfg/","tags":"","title":"配置"},{"body":"概述 XWOS的线程栅栏是用于协调多个线程并行工作的同步机制。\n线程栅栏在创建时，会指明有多少个线程槽。 当线程到达线程栅栏时会阻塞并等待，直到指定数量的线程都达到线程栅栏，所有线程被同时唤醒。\n线程栅栏对象与对象描述符描述符 线程栅栏对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，线程栅栏对象也用 线程栅栏对象描述符 xwos_br_d 来解决有效性和身份合法性的问题。\n线程栅栏对象描述符由 线程栅栏对象的指针 和 标签 组成：\ntypedef struct { struct xwos_br * br; /**\u003c 线程栅栏对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_br_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n线程栅栏的初始化、销毁与动态创建、删除 静态初始化、销毁 静态初始化： xwos_br_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的线程栅栏： xwos_br_fini() 动态创建、删除 动态创建： xwos_br_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的线程栅栏： xwos_br_delete() 通过线程栅栏同步线程 xwos_br_wait() ：等待所有线程到达栅栏，只能在 线程 上下文使用 xwos_br_wait_to() ：限时等待所有线程到达栅栏，只能在 线程 上下文使用 绑定与解绑信号选择器 可以通过 xwos_br_bind() 将线程栅栏绑定到 信号选择器 上。 当指定数量的线程抵达线程栅栏时，线程栅栏会向 信号选择器 发送一个 选择信号 。此时 信号选择器 会唤醒正在等待的线程。\n绑定后的线程栅栏可以通过 xwos_br_unbind() 解绑。\n线程栅栏对象的生命周期管理 线程栅栏对象的基类是 XWOS对象 struct xwos_object 。 线程栅栏对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_br_grab() ：增加引用计数。 xwos_br_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_br_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_br_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 API参考 头文件 \u003cxwos/osal/sync/br.h\u003e ","categories":["XWOS"],"description":"XWOS的线程栅栏\n","excerpt":"XWOS的线程栅栏\n","ref":"/docs/TechRefManual/Sync/Br/","tags":"","title":"线程栅栏"},{"body":"API参考 头文件 \u003cxwos/osal/sync/br.h\u003e ","categories":"","description":"","excerpt":"API参考 头文件 \u003cxwos/osal/sync/br.h\u003e ","ref":"/docs/UserManual/App/Sync/Br/","tags":"","title":"线程栅栏"},{"body":"CAPI参考 头文件 \u003cxwos/osal/irq.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/irq.h\u003e ","ref":"/docs/UserManual/App/Irq/","tags":"","title":"中断"},{"body":"","categories":"","description":"第三方软件移植说明\n","excerpt":"第三方软件移植说明\n","ref":"/docs/UserManual/Em/","tags":"","title":"第三方软件移植说明"},{"body":" 俗话说：工欲善其事，必先利其器。 一切美好的想法都需要合适的开发环境来实践。\n概述 XWOS构建系统基于 make 编写，特点：\n支持纯命令行方式编译，可用于持续集成环境中； 可跨平台使用，支持linux、Windows、MACOS； 支持基于Eclipse的IDE； 为了方便集成第三方软件，XWOS参考了Android的构建系统的 Android.mk 设计出 xwmo.mk ， 称为 玄武模块 。 构建流程 flowchart TD make(\"make\") --\u003e cfg cfg[\"生成配置\"] --\u003e arch arch[\"编译arch.a\"] --\u003e cpu cpu[\"编译cpu.a\"] --\u003e soc soc[\"编译soc.a\"] --\u003e brd brd[\"编译brd.a\"] --\u003e xwos xwos[\"编译XWOS内核\"] --\u003e xwmd xwmd[\"编译中间件模块\"] --\u003e xwcd xwcd[\"编译设备模块\"] --\u003e bm bm[\"编译电路板模块\"] --\u003e xwem xwem[\"编译第三方软件模块\"] --\u003e xwam xwam[\"编译应用模块\"] --\u003e oem oem[\"编译OEM模块\"] --\u003e elf elf[\"链接ELF文件\"] --\u003e bin bin[\"生成bin文件\"] 开始 XWOS的构建是从 电路板描述层目录 下执行命令 make 开始的，以 $(XWOS_BRD_DIR) 代表此目录。 执行 make 时，可传递参数：\nWKSPC=output-dir ：配置输出文件的路径，可为相对于 电路板描述层目录 的路径，也可为绝对路径； XWOS=topdir ：配置XWOS的根路径，可为相对于 电路板描述层目录 的路径，也可为绝对路径。 生成配置 构建系统调用脚本 XWOS/xwbs/util/el/mkcfg.el 处理 $(XWOS_BRD_DIR)/cfg 下的所有配置文件， 将它们转化成三个文件：\n$(XWOS_WKSPC_DIR)/XWOS.cfg ， makefile 环境变量，之后被 makefile 引入。 其中包含一些关键的路径信息，不同的SOC通过这些路径找到各自的编译配置： $(XWOS_PATH) ： XWOS源码的根目录 $(XWOS_ARCH_DIR) ：架构相关的源码路径； $(XWOS_CPU_DIR) ：CPU相关的源码路径； $(XWOS_SOC_DIR) ：SOC相关的源码路径； $(XWOS_BRD_DIR) ：电路板相关的源码路径，此路经也是最开始执行make的地方； $(XWOS_BM_DIR) ：电路板相关的玄武模块路径； $(XWOS_OEM_DIR) ：OEM相关的玄武模块路径，通常为私有代码； $(XWOS_OBJ_DIR) ： $(XWOS_WKSPC_DIR)/obj ，编译输出的目录； $(XWOS_BRD_DIR)/cfg/autogen.h ，自动生成的头文件，被顶级头文件 xwos/standard.h 包含 $(XWOS_WKSPC_DIR)/XWOS.cfg.rs ：Rust语言的配置 $(XWOS_WKSPC_DIR)/env.rc ， shell 环境变量脚本，可通过 source 命令引入这个文件，使得 辅助功能 生效。 编译 arch.a 构建系统会根据编译规则 $(XWOS_ARCH_DIR)/arch.mk 编译架构描述层(Arch Description Layer)的源码。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。编译后输出静态库 $(XWOS_OBJ_DIR)/$(XWOS_ARCH_DIR)/arch.a 。\n编译 cpu.a 构建系统会根据编译规则 $(XWOS_CPU_DIR)/arch.mk 编译CPU描述层(CPU Description Layer)的源码， 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。编译后输出静态库 $(XWOS_OBJ_DIR)/$(XWOS_CPU_DIR)/cpu.a 。\n编译 soc.a 构建系统会根据编译规则 $(XWOS_SOC_DIR)/soc.mk 编译SOC描述层(SOC Description Layer)的源码， 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。编译后输出静态库 $(XWOS_OBJ_DIR)/$(XWOS_SOC_DIR)/soc.a 。\n编译 brd.a 构建系统会根据编译规则 $(XWOS_BRD_DIR)/brd.mk 编译电路板描述层(Board Description Layer)的源码， 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。编译后输出静态库 $(XWOS_OBJ_DIR)/$(XWOS_BRD_DIR)/brd.a 。\n编译XWOS内核 构建系统会根据编译规则 xwos/xwos.mk 编译XWOS内核的源码， 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。编译后输出静态库 $(XWOS_OBJ_DIR)/$(XWOS_XWOS_DIR)/xwos.a 。\n编译中间件模块 构建系统会递归扫描 xwmd/ 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR) 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/xwmd.h 中都有一个编译开关 XWMDCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 编译设备模块 构建系统会递归扫描 xwcd/ 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR) 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/xwcd.h 中都有一个编译开关 XWCDCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 编译电路板模块 构建系统会递归扫描 $(XWOS_BM_DIR) 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR) 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/board.h 中都有一个编译开关 BMCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 编译第三方软件模块 构建系统会递归扫描 xwem/ 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR) 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/xwem.h 中都有一个编译开关 XWEMCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 编译应用模块 构建系统会递归扫描 xwam/ 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR) 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/xwam.h 中都有一个编译开关 XWAMCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 编译OEM模块 OEM文件夹路径由位于配置文件 $(XWOS_BRD_DIR)/cfg/XWOS.h 中的 配置 XWCFG_OEMPATH 指定： 可以是相对于 $(XWOS_BRD_DIR) 的相对路径； 可以是绝对路径； 路径可指向XWOS根目录之外。 配置工具 xwbs/util/el/mkcfg.el 会根据此配置生成变量 $(XWOS_OEM_DIR) ； 构建系统会递归扫描 $(XWOS_OEM_DIR) 文件夹以及子文件下的所有 xwmo.mk 文件，生成模块列表， 依次将它们编译成 .a 静态库，输出到 $(XWOS_OBJ_DIR)/oem 目录下。 编译时头文件搜索的起始目录为 $(XWOS_PATH) 。 每个 xwmo.mk 文件代表了一个模块，构建系统会另启一个子进程 make 对其进行编译， 其中定义了的参数：源代码列表、附加编译选项、头文件路径等对每个编译模块的子进程都是相互独立。 每个中间件模块在 $(XWOS_BRD_DIR)/cfg/oem.h 中都有一个编译开关 OEMCFG_ 的宏定义： 1 时表示编译这个模块； 0 或 未定义 表示排除这个模块。 编译开关的命名规则参考 模块编译开关的命名规则 。 链接ELF文件 构建系统最终会将以上生成的所有 .a 静态库链接成 XWOS.elf 文件， 连接脚本由位于配置文件 $(XWOS_BRD_DIR)/cfg/XWOS.h 中的 XWCFG_LDSCRIPT 指定。\n生成bin文件 构建系统会将 XWOS.elf 文件转换成 .bin 文件以及 .hex 文件。\n构建选项 V 作用：输出完整的编译过程。 取值： 1: 开启选项 0: 关闭选项（默认值） 用法： make V=1 D 作用：优化编译，输出体积较小的二进制，但不利于调试。 取值： 1: 开启选项（默认值） 0: 关闭选项 用法： make D=0 玄武模块 XWOS的设备模块、中间件模块、第三方软件模块、电路板模块、以及OEM模块， 都是使用 xwmo.mk 来描述编译规则的，将它们统一称为 玄武模块(XWMO) 。\n每个 xwmo.mk 文件代表了一个 玄武模块 ，其原理类似于Android系统中的 Android.mk 。 构建系统会另启一个进程 make 对其进行编译， 其中源代码列表、附加编译选项、头文件路径等对每个编译玄武模块的子进程都是独立的。\n示例， xwam/example/cxx 的 xwmo.mk ：\ninclude $(XWOS_WKSPC_DIR)/XWOS.cfg # 包含环境变量 include xwbs/functions.mk # 包含xwbs定义的Makefile函数 XWMO_CSRCS := mif.c # 指定C源文件 XWMO_CFLAGS := # 指定附加的C编译选项 XWMO_CXXSRCS := task.cxx # 指定C++源文件 XWMO_CXXSRCS += test/vector.cxx # 增加C++源文件 XWMO_CXXSRCS_gcc += test/literal.cxx test/exception.cxx # 增加仅对gcc生效的C++源文件 XWMO_CXXFLAGS := -Wno-unused-value # 指定C++编译选项 XWMO_CXXFLAGS_gcc += -fexceptions # 增加仅对gcc生效的C++编译选项 XWMO_INCDIRS := $(call getXwmoDir) # 指定附加的头文件搜索路径，其中使用函数getXwmoDir获得当前xwmo的路径 include xwbs/xwmo.mk # 引用包含编译规则的Makefile 模块路径命名规则 由于模块路径需要对应于C语言中的一个宏定义作为编译开关， 因此模块路径需要符合C语言标识符的规则，但可以包含几个特殊符号：\n路径各级目录命名要符合C语言命名规则； 路径中每级目录以 / 隔开； 路径中可包含 . ，但不能出现 ../ 和 ./ ； 路径中可包含 - ； 模块编译开关的命名规则 模块必须要有一个与路径对应的宏开关，并被配置为 1 ，才能被编译：\n模块路径只需要转换相对路径部分： 中间件模块：取 xwmd/ （不含）之后的路径； 设备驱动模块：取 xwcd/ （不含）之后的路径； 电路板模块：取 $(XWOS_BRD_DIR)/bm/ （不含）之后的路径； 第三方软件模块：取 xwem/ （不含）之后的路径； 应用模块：取 xwam/ （不含）之后的路径； OEM模块：取 OEM文件夹/ （不含）之后的路径。 路径中的 _ ，需要两个 _ 来表示； 路径中的 / 被转换成 _ ； 路径中的 . 被转换成 _ ； 路径中的 - 被转换成 _ ； 增加前缀： 中间件模块： XWMDCFG_ 设备模块： XWCDCFG_ 电路板模块： BMCFG_ 第三方软件模块： XWEMCFG_ 应用模块： XWAMCFG_ OEM模块： OEMCFG_ 示例： 中间件模块： xwmd/isc/xwpcp –\u003e XWMDCFG_isc_xwpcp ； 设备驱动模块： xwcd/perpheral/ds/i2c/eeprom –\u003e XWCDCFG_perpheral_ds_i2c_eeprom ； 电路板模块： xwbd/WeActMiniStm32H750/bm/stm32_cube –\u003e BMCFG_stm32__cube ； 第三方软件模块： xwem/vm/l__u_a-5.4.6 –\u003e XWEMCFG_vm_l____u__a_5_4_6 ； 应用模块： xwam/example/cxx –\u003e XWAMCFG_example_cxx ； OEM模块： oem/app –\u003e OEMCFG_app ； 可以借助 辅助功能 中的 xwmc 命令生成编译开关的宏标识符。 增加模块 中间件模块 模块位于 xwmd/ 目录中； 宏编译开关位于文件 $(XWOS_BRD_DIR)/cfg/xwmd.h ，定义为 1 表示编译模块。 设备驱动模块 模块位于 xwcd/ 目录中； 宏编译开关位于文件 $(XWOS_BRD_DIR)/cfg/xwcd.h ，定义为 1 表示编译模块。 电路板模块 模块位于 $(XWOS_BRD_DIR)/bm/ 目录中； 宏编译开关位于文件 $(XWOS_BRD_DIR)/cfg/board.h ，定义为 1 表示编译模块。 第三方软件模块 模块位于 xwem/ 目录中； 宏编译开位于文件 $(XWOS_BRD_DIR)/cfg/xwem.h ，定义为 1 表示编译模块。 应用模块 模块位于 xwam/ 目录中； 宏编译开关位于文件 $(XWOS_BRD_DIR)/cfg/xwam.h ，定义为 1 表示编译模块。 OEM模块 模块位于OEM文件夹内； 宏编译开关位于文件 $(XWOS_BRD_DIR)/cfg/oem.h ，定义为 1 表示编译模块。 xwmo.mk 语法说明 xwmo.mk 是 makefile 的一部分，其中语法简化为定义几个特殊的变量即可完成编译。\nC/C++ include $(XWOS_WKSPC_DIR)/XWOS.cfg # 包含配置文件 include xwbs/functions.mk # 包含xwbs定义的Makefile函数 XWMO_ASRCS := # 汇编源文件 XWMO_ASRCS_gcc := # 只对gcc起作用的汇编源文件 XWMO_ASRCS_llvm := # 只对llvm起作用的汇编源文件 XWMO_AFLAGS := # 汇编编译选项 XWMO_AFLAGS_gcc := # 只对gcc起作用的汇编编译选项 XWMO_AFLAGS_llvm := # 只对llvm起作用的汇编编译选项 XWMO_CSRCS := # C源文件 XWMO_CSRCS_gcc := # 只对gcc起作用的C源文件 XWMO_CSRCS_llvm := # 只对llvm起作用的C源文件 XWMO_CFLAGS := # C编译选项 XWMO_CFLAGS_gcc := # 只对gcc起作用的C编译选项 XWMO_CFLAGS_llvm := # 只对llvm起作用的C编译选项 XWMO_CXXSRCS := # C++源文件 XWMO_CXXSRCS_gcc := # 只对gcc起作用的C++源文件 XWMO_CXXSRCS_llvm := # 只对llvm起作用的C++源文件 XWMO_CXXFLAGS := # C++编译选项 XWMO_CXXFLAGS_gcc := # 只对gcc起作用的C++编译选项 XWMO_CXXFLAGS_llvm := # 只对llvm起作用的C++编译选项 XWMO_INCDIRS := $(call getXwmoDir) # 获取模块路径并增加到头文件搜索路径 XWMO_INCDIRS_gcc := $(call getXwmoDir) # 获取模块路径并增加到gcc头文件搜索路径 XWMO_INCDIRS_llvm := $(call getXwmoDir) # 获取模块路径并增加到llvm头文件搜索路径 XWMO_LUASRCS := # 转换为C语言数组的Lua脚本源文件 include xwbs/xwmo.mk # 引用包含编译规则的Makefile RUST模块 include $(XWOS_WKSPC_DIR)/XWOS.cfg # 包含配置文件 include xwbs/functions.mk # 包含xwbs定义的Makefile函数 include xwbs/xwmo.rust.mk # 引用包含编译规则的Makefile 预编译模块 include $(XWOS_WKSPC_DIR)/XWOS.cfg # 包含配置文件 include xwbs/functions.mk # 包含xwbs定义的Makefile函数 XWMO_PREBUILT := # 预先编译好的.a文件 include xwbs/xwmo.prebuilt.mk # 引用包含编译规则的Makefile xwmo.mk 中可用的函数 getXwmoDir\n用法：$(call getXwmoDir) 简介：获取当前 玄武模块 的路径 getXwmoName\n用法：$(call getXwmoName) 简介：获取当前 玄武模块 的名称 XwmoWildcard\n用法： $(call XwmoWildcard,WILDCARD,DIR) 简介：在目录 DIR 中搜索符合通配符 WILDCARD 的文件，并输出文件列表。 用法举例 示例：XWMO_CSRCS += $(call XwmoWildcard,*.c,picolibc) 说明：在 picolibc 搜索所有的 *.c 文件，并将返回的文件列表赋值给 XWMO_CSRCS XwmoWildcardRecursively\n用法： $(call XwmoWildcardRecursively,WILDCARD,DIR) 简介：在目录 DIR 以及其子目录中搜索符合通配符 WILDCARD 的文件，并输出文件列表。 XwmoReqCfg\n用法： $(call XwmoReqCfg,CFG,VALUE) 简介：测试配置 CFG 是否为 VALUE ，如果不是就报错。 用法举例 示例：$(call XwmoReqCfg,XWCFG_LIBC,picolibc) 说明：如果配置 XWCFG_LIBC 不为 picolibc 就报错。 XwmoReqNotCfg\n用法： $(call XwmoReqNotCfg,CFG,VALUE) 简介：测试配置 CFG 是否为 VALUE ，如果是就报错。 用法举例 示例：$(call XwmoReqCfg,XWCFG_LIBC,picolibc) 说明：如果配置 XWCFG_LIBC 为 picolibc 就报错。 辅助功能 XWOS的编译系统类似于Android，也定义了一些与编译相关的辅助命令。\n初始化环境 source xwbd/WeActMiniStm32H750/env.sh # 以电路板WeActMiniStm32H750为例 命令 xwmc 功能：获取模块编译开关的C语言宏标识符。 用法举例： cd xwem/vm/lua # 进入到vm/lua模块中 xwmc \u003e XWEMCFG_vm_lua # 输出结果 xwmn 功能：获取模块的 .a 文件名。 用法举例： cd xwem/vm/lua # 进入到vm/lua模块中 xwmn \u003e xwem_vm_lua.a # 输出 xwm 功能：编译整个XWOS工程，类似Android的 m 命令。 用法： xwm [选项] [目标] 选项 -B ：全部重新编译一次 目标：make的目标 用法举例： xwm # 编译整个工程 xwm c # 清理 xwm d # 侧底清理 xwmm 功能：单独编译模块，类似Android的 mm 命令，使用当前路径作为模块的路径。 选项 -B ：全部重新编译一次 用法举例： cd xwem/vm/lua # 进入到vm/lua模块中 xwmm xwmmm 功能：单独编译模块，类似Android的 mmm 命令，需要指定模块的路径。 选项 -B ：全部重新编译一次 用法举例： xwmmm xwem/vm/lua xwcroot\n功能：切换到XWOS的根目录，类似Android的 croot 命令。 xwcbd\n功能：切换到电路板描述层目录。 ","categories":["XWOS"],"description":"XWOS的构建系统\n","excerpt":"XWOS的构建系统\n","ref":"/docs/TechRefManual/BuildSystem/","tags":"","title":"构建系统"},{"body":"CAPI参考 头文件 \u003cxwos/osal/thd.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/thd.h\u003e ","ref":"/docs/UserManual/App/Thd/","tags":"","title":"线程"},{"body":"概述 信号选择器类似于事件标志，使用位图来管理一组 同步对象 。使得单一线程可以同时等待多个 同步对象 。\n每个 同步对象 在信号选择器位图中都绑定一个特定的 位 ，\n当这些 同步对象 发送 选择信号 时，信号选择器位图中特定的 位 被置 1 ，同时唤醒正在等待信号选择器的线程。 线程唤醒后可以通过检测哪些 位 被置 1 来判断哪些 同步对象 发送了 选择信号 。\n信号选择器对象与对象描述符描述符 信号选择器对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，信号选择器对象也用 信号选择器对象描述符 xwos_sel_d 来解决有效性和身份合法性的问题。\n信号选择器对象描述符由 信号选择器对象的指针 和 标签 组成：\ntypedef struct { struct xwos_sel * sel; /**\u003c 信号选择器对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_sel_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n同步对象的绑定与解绑 XWOS中所有 同步对象 都带有两个相似的CAPI：\n绑定 xwos_sem_bind() xwos_cond_bind() xwos_flg_bind() xwos_br_bind() xwos_sel_bind() 解绑 xwos_sem_unbind() xwos_cond_unbind() xwos_flg_unbind() xwos_br_unbind() xwos_sel_unbind() 同步对象 绑定操作又分为 独占绑定 与 非独占绑定 ：\n独占绑定：是指 同步对象 一旦绑定了信号选择器位图中的某一位后，其他 同步对象 不可再绑定此位，发送的 选择信号 也被称为 独占 方式的 选择信号 ； 非独占绑定：是指 同步对象 一旦绑定了信号选择器位图中的某一位后，其他 同步对象 还可继续再绑定此位，发送的 选择信号 也被称为 非独占 方式的 选择信号 。 同步对象 采用的绑定方式：\n信号量：独占绑定 条件量：非独占绑定 事件标志：非独占绑定 线程栅栏：非独占绑定 信号选择器：非独占绑定 选择信号 选择信号的设置 选择信号 的设置，对于不同的 同步对象 有不同解释：\n信号量 计数器的值大于 0 时就会被设置。 条件量 广播操作： xwos_cond_broadcast() 事件标志 事件标志位图中任何一位发生改变的操作： xwos_flg_s1m() ：同时设置多个事件标志位 xwos_flg_s1i() ：设置单个事件标志位 xwos_flg_c0m() ：同时清除多个事件标志位 xwos_flg_c0i() ：清除单个事件标志位 xwos_flg_x1m() ：同时翻转多个事件标志位 xwos_flg_x1i() ：翻转单个事件标志位 线程栅栏 所有线程抵达栅栏处，并同时被唤醒； 信号选择器 信号选择器本身也是 同步对象 ，也可绑定在另一个信号选择器上。当源信号选择器收到了 选择信号 ，会将其传递到绑定的另一个目的信号选择器上。 XWOS信号选择器示意图 Photo: xwos.tech / CC-BY\n选择信号的清除 独占 方式的 选择信号 信号量：当信号量中的计数器的值小于等于 0 时， 选择信号 才会被清除。 非独占 方式的 选择信号 非独占 方式绑定的 同步对象 向信号选择器发送 选择信号 后，其位图中的位置会被置 1 。 同时会唤醒所有等待的线程，此时线程们会竞争进入信号选择器的临界区。\n最先进入的线程会读取信号选择器的 选择信号 位图，并与调用函数时传递的 掩码 进行比较，判断是否有 掩码 中的 选择信号 ：\n如果有，会清除信号选择器位图中 所有 的 非独占 方式的 选择信号 ，包括 掩码 中没有设置的 选择信号 。 因此后续线程将无法再检测到任何 非独占 方式的 选择信号 ，会重新阻塞等待。 XWOS不推荐在信号选择器上，多于一个线程等待。 如果没有，线程会重新阻塞等待，然后下一个线程进入临界区检测。 信号选择器的初始化、销毁与动态创建、删除 静态初始化、销毁 静态初始化： xwos_sel_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的信号选择器： xwos_sel_fini() 动态创建、删除 动态创建： xwos_sel_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的信号选择器： xwos_sel_delete() 等待选择信号 xwos_sel_select() ：等待信号选择器中的 选择信号 ，只能在 线程 上下文使用 xwos_sel_select_to() ：限时等待信号选择器中的 选择信号 ，只能在 线程 上下文使用 xwos_sel_tryselect() ：检测信号选择器中是否有 选择信号 ，可在 任意 上下文使用 绑定与解绑其他信号选择器 可以通过 xwos_sel_bind() 将信号选择器绑定到另一个 信号选择器 上，形成传递链。 但信号选择器不可相互绑定形成循环链，否则会造成无限传递。\n绑定后的信号选择器可以通过 xwos_sel_unbind() 解绑。\n信号选择器对象的生命周期管理 信号选择器对象的基类是 XWOS对象 struct xwos_object 。 信号选择器对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_sel_grab() ：增加引用计数。 xwos_sel_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_sel_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_sel_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwos/osal/sync/sel.h\u003e ","categories":["XWOS"],"description":"XWOS的信号选择器\n","excerpt":"XWOS的信号选择器\n","ref":"/docs/TechRefManual/Sync/Sel/","tags":"","title":"信号选择器"},{"body":"CAPI参考 头文件 \u003cxwos/osal/sync/sel.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/sync/sel.h\u003e ","ref":"/docs/UserManual/App/Sync/Sel/","tags":"","title":"信号选择器"},{"body":"XWOS的启动流程 flowchart LR 预初始化阶段 --\u003e 初始化阶段 --\u003e 后初始化阶段 --\u003e 主函数阶段 subgraph 预初始化阶段 direction TB exc[\"异常初始化\"] exc[\"浮点单元初始化\"] exc[\"内存初始化\"] end subgraph 初始化阶段 xwos_init[\"xwos_init()\"] end subgraph 后初始化阶段 direction LR device[\"设备驱动初始化\"] mm[\"动态内存分配器的初始化\"] end subgraph 主函数阶段 direction LR skd_init[\"初始化调度器: xwos_skd_init_lc()\"] thd[\"建立线程\"] skd_start[\"启动调度器: xwos_skd_start_lc()\"] end XWOS将初始化流程分为四个阶段：\n预初始化阶段（用户定义）：xwos_preinit() 初始化阶段（XWOS定义）：xwos_init() 后初始化阶段（用户定义）：xwos_postinit() 主函数阶段（用户定义）：xwos_main() 预初始化阶段 预初始化阶段，用户需要提供函数的定义： void xwos_preinit(void) ：\n需要完成CPU架构低级初始化，例如：中断的初始化，浮点运算单元的初始化等； 需要完成对内存的初始化，以及数据区的重定向工作。 初始化阶段 初始化阶段的函数 void xwos_init(void) 由XWOS定义，对XWOS内核进行初始化。用户不可重新定义此函数。 xwos_init() 会访问全局变量，因此必须保证在 预初始化阶段 完成对内存的初始化以及数据区的重定向工作。 在多核系统中， xwos_init() 在每个CPU的初始化流程中都会被调用一次。\n后初始化阶段 后初始化阶段，用户需要提供函数的定义： void xwos_postinit(void) ：\n用户可选择在此阶段完成驱动的初始化； 用户可选择在此阶段完成动态内存分配器的初始化； 主函数阶段 用户可选择在此阶段完成驱动的初始化； 用户可选择在此阶段完成动态内存分配器的初始化； 用户需要在此阶段建立线程； 用户需要在此阶段调用 xwos_skd_start_lc() 启动调度器。 用户自定义的启动流程 如果用户使用自定义的启动流程，需要在调用XWOS任何API之前调用 xwos_init() 。 此函数会访问全局变量，需要在数据区重定向工作完成之后才可被调用。\n在多核系统中， xwos_init() 需要在每个CPU的初始化流程中被调用一次。\n自定义的启动流程举例 TODO\n","categories":["XWOS"],"description":"XWOS的启动流程\n","excerpt":"XWOS的启动流程\n","ref":"/docs/TechRefManual/BootFlow/","tags":"","title":"启动流程"},{"body":"CAPI参考 头文件 \u003cxwos/osal/swt.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/swt.h\u003e ","ref":"/docs/UserManual/App/Swt/","tags":"","title":"软件定时器"},{"body":"概述 XWOS的内核对象全部继承于 struct xwos_object 。\nstruct xwos_object { xwsq_t tik; xwsq_t magic; atomic_xwsq_t refcnt; xwobj_gc_f gcfunc; }; tik ：对象的标签，是由系统分配的独一无二的整数。此标签即为对象的 身份证ID ； magic ：常数 0x58574F53U ，用于确定内存地址是否为 XWOS的对象 ； refcnt ：XWOS的对象使用引用计数法管理生命周期，当对象的引用计数减为 0 ，会调用 gcfunc() 进行垃圾回收； gcfunc ：垃圾回收函数。 按照面向对象的思想， struct xwos_object 应当作为子类对象结构体的第一个成员。 struct xwos_object * 就可强制类型转换为子类对象的指针。\n对象描述符 当使用对象指针访问对象时，有可能会出现一种情况： 对象已经被释放，甚至被释放后的内存又被用来构建新的对象。但是对象指针的持有者并不知道这种情况。由此引发各种指针问题。 为了解决这类问题，XWOS引入 对象描述符 。对象描述符 由 对象的指针 和 标签 组成：\ntypedef struct { struct xwos_object * obj; xwsq_t tik; } xwobj_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n相应的，当 struct xwos_object 被子类继承后，子类也应该有对应的 对象描述符 。 例如，线程对象的 线程对象描述符 、互斥锁对象的 互斥锁对象描述符 等。\n对象的生命周期 XWOS的对象使用引用计数法管理生命周期，XWOS对象的生命周期分为三个阶段：\n构造阶段 ：对象通过 xwos_object_construct() 构造后进入 构造阶段 ， 此时对象的引用计数为 0 。如果存在派生与继承，需要按照从 基类到子类 的顺序依次调用构造函数。 应用阶段 ：处于构造阶段的对象，通过 xwos_object_activate() 激活后进入 应用阶段 。 如果存在派生与继承，需要按照从 基类到子类 的顺序依次调用激活函数。 此阶段对象的引用计数 \u003e= 1 ，对象可以开始被使用。 释放阶段 ：当对象引用计数从 \u003e= 1 减少为 0 ，对象进入 释放阶段 ，此阶段会调用对象的 gcfunc() 释放对象。 用户需要提供 gcfunc() 的定义， gcfunc() 内还需要调用对象的析构函数 xwos_object_destruct() 如果存在派生与继承，需要按照从 子类到基类 的顺序依次调用析构函数。 至此对象生命周期结束。 对象的生命周期管理 XWOS提供两组对象的生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_object_grab() ：增加引用计数。 xwos_object_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 xwos_object_rawput() ：减少引用计数，引用计数为 0 时不调用垃圾回收函数。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_object_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_object_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 局限性 频繁地管理对象的生命周期会影响CPU的运行效率，因为引用计数的操作是原子操作，原子操作会影响CPU的性能， CPU性能越强，影响越巨大。因此，除了必要的情况，XWOS内核各种对象的CAPI被设计为直接使用 对象的指针 作为参数，并且不会自动管理对象的生命周期。 对象的有效性，身份的合法性，生命周期需要由用户手动管理。\n通常，在简单的MCU RTOS应用，这些对象都是只创建不释放的，也没有必要关心生命周期。 事实上，对象的生命周期的CAPI主要是给高级语言设计的，例如 Lua 虚拟机用来实现对象生命周期的自动管理。\nCAPI参考 头文件 \u003cxwos/lib/object.h\u003e ","categories":["XWOS"],"description":"XWOS的对象\n","excerpt":"XWOS的对象\n","ref":"/docs/TechRefManual/Xwobj/","tags":"","title":"XWOS对象"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/UserManual/App/Lock/","tags":"","title":"锁"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/UserManual/App/Sync/","tags":"","title":"同步"},{"body":"异常与中断 XWOS将中断分为EXC和IRQ：\nEXC是指架构中定义的中断，在某些架构中被称为 异常(Exception) ，中断号用负数表示； IRQ是指外设中断，例如UART的中断等，中断号用 0 和 正数 表示。 内核中断 XWOS内核的中断包括：\n切换上下文的中断：用于切换线程； 滴答定时器的中断：用于提供周期性定时中断； 调度器服务中断：用于启动调度、退出线程、冻结线程、电源管理等其他操作。 中断优先级 XWOS对中断优先级的要求：\n切换上下文的中断为系统中最低优先级中断 切换上下文的中断 \u003c= 滴答定时器的中断 \u003c= 调度器服务中断 CPU中断开关 CPU只能操作自身的中断开关，不可操作其他CPU的中断。下面的函数运行在哪个CPU，就对哪个CPU起作用：\nxwos_cpuirq_enable_lc() ：开启CPU的中断开关 xwos_cpuirq_disable_lc() ：关闭CPU的中断开关 xwos_cpuirq_save_lc() ：保存当前CPU的中断开关状态后关闭 xwos_cpuirq_restore_lc() ：恢复之前保存的CPU的中断开关状态 为某个芯片移植XWOS时，需要在操作系统移植实现层(XWOSIMPL)中给出上述函数的具体实现方法：\n源文件： xwosimpl_irq.h/xwosimpl_irq.c xwospl_cpuirq_enable_lc() ：对应于 xwos_cpuirq_enable_lc() xwospl_cpuirq_disable_lc() ：对应于 xwos_cpuirq_disable_lc() xwospl_cpuirq_save_lc() ：对应于 xwos_cpuirq_save_lc() xwospl_cpuirq_restore_lc() ：对应于 xwos_cpuirq_restore_lc() 使用局限 关闭与开启CPU总中断开关需要确保不会发生嵌套，例如下面的嵌套代码是 错误 的，因为 临界区1 结束时会意外地将CPU中断打开， 从而无法保证 临界区0 的安全性：\nvoid func1(void) { xwos_cpuirq_disable_lc(); /* ... 临界区1 ... */ xwos_cpuirq_enable_lc(); } void func0(void) { xwos_cpuirq_disable_lc(); /* ... 临界区0 ... */ func1(); /* 错误！！！发生嵌套 */ /* 此处CPU中断被意外打开 */ /* ... 临界区0 ... */ xwos_cpuirq_enable_lc(); } 当关闭中断的代码发生嵌套时，需要保存与恢复CPU总中断开关，上面的例子可以更正为：\nvoid func1(void) { xwreg_t cpuirq; xwos_cpuirq_save_lc(\u0026cpuirq); /* ... 临界区1 ... */ xwos_cpuirq_restore_lc(cpuirq); } void func0(void) { xwreg_t cpuirq; xwos_cpuirq_save_lc(\u0026cpuirq); /* ... 临界区0 ... */ func1(); /* ... 临界区0 ... */ xwos_cpuirq_restore_lc(cpuirq); } 外设中断 获取当前代码的中断号 XWOS提供CAPI xwos_irq_get_id() 可以获取当前中断的中断号。 如果不在中断内使用此CAPI，将返回错误码：\n-ENOTISRCTX ：当前上下文不为中断 因此，此CAPI还可用于判断是否为 中断上下文 。\n为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：\n源文件： xwosimpl_irq.h/xwosimpl_irq.c xwospl_irq_get_id() ：对应于 xwos_irq_get_id() 外设中断的其他CAPI xwos_irq_enable() ：开启某个外设中断 xwos_irq_disable() ：关闭某个外设中断 xwos_irq_save() ：保存某个外设中断的开关，然后将其关闭 xwos_irq_restore() ：恢复某个外设中断的开关 为某个芯片移植XWOS时，需要操作系统移植实现层(XWOSIMPL)中给出上述函数的实现方法：\n源文件： xwosimpl_irq.h/xwosimpl_irq.c xwospl_irq_enable() ：对应于 xwos_irq_enable() xwospl_irq_disable() ：对应于 xwos_irq_disable() xwospl_irq_save() ：对应于 xwos_irq_save() xwospl_irq_restore() ：对应于 xwos_irq_restore() CAPI参考 头文件 \u003cxwos/osal/irq.h\u003e ","categories":["XWOS"],"description":"XWOS的中断控制\n","excerpt":"XWOS的中断控制\n","ref":"/docs/TechRefManual/Irq/","tags":"","title":"中断管理"},{"body":"CAPI参考 头文件 \u003cxwos/osal/pm.h\u003e ","categories":"","description":"","excerpt":"CAPI参考 头文件 \u003cxwos/osal/pm.h\u003e ","ref":"/docs/UserManual/App/Pm/","tags":"","title":"电源管理"},{"body":"概述 XWOS调度器最基本的调度单位是 线程 ，暂时不支持 MMU虚拟内存 与 进程 ； 每个 线程 都有自己独立的 栈 内存，但所有内存对所有线程都可见，除非使用MPU增加限制； 每个 线程 都有调度优先级； 调度器可以冻结线程，支持电源管理； 每个CPU都有自己独立的调度器，线程只能在自身CPU的调度器中调度，如果需要在CPU间移动，需要进行 迁移 操作； 优先级 XWOS的优先级，用类型 xwpr_t 表示：\n值越 小 ，优先级越 低 ，优先级的值越 大 ，优先级越 高 。 为了保证今后的扩展性，应该使用宏，而不要直接使用 xwpr_t 的数值： 最小优先级可以通过宏 XWOS_SKD_PRIORITY_RT_MIN 获取 。 最大优先级可以通过宏 XWOS_SKD_PRIORITY_RT_MAX 获取 。 无效优先级可以通过宏 XWOS_SKD_PRIORITY_RT_INVALID 获取 。 其他优先级应该使用最大优先级和最小优先级进行计算获取： 降低优先级可以通过宏 XWOS_SKD_PRIORITY_DROP ； 提高优先级可以通过宏 XWOS_SKD_PRIORITY_RAISE 。 调度算法 数据类型 每个优先级都有一个先进先出(FIFO)的 就绪 队列； 使用一个位图标记每个优先级队列是否为空；非空的队列对应的位被置1，否则被清0。 XWOS调度器就绪队列 Photo: xwos.tech / CC-BY-SA-4.0\n调度流程 定义操作fls：从最高位起查找第一个被置1的位，并返回其序号， 如果所有位都为0，返回-1。此操作需要CPU的相关指令来实现，例如ARM的clz， DEC Alpha的ctlz，x86的lzcnt，PowerPC的cntlz等。\n流程图\nflowchart TB start --\u003e fls fls --\u003e idx idx --否--\u003e idle idx --是--\u003e q q --\u003e t t --\u003e skd skd --\u003e e idle --\u003e e start(\"开始\") fls[\"idx = fls(bitmap)\"] idx{\"idx \u003e= 0 ?\"} idle[\"调度空闲任务\"] q[\"选择优先级为idx的就绪队列\"] t[\"从就绪队列头部选择第一个线程\"] skd[\"调度选择的线程\"] e(\"结束\") 启动调度器 当 启动流程 进入 xwos_main() 后，可调用 xwos_skd_start_lc() 启动调度器，此时上下文(Context)将由 启动 切换为 线程 。\n抢占 调度器始终选择优先级最高的线程，高优先级的线程可以抢占低优先级的线程。\n相同的优先级的线程，调度器按照 先进先出 的方法调度，同优先级线程之间 不能 相互抢占。\n用户可以关闭抢占： xwos_skd_dspmpt_lc() ， 也可以打开抢占： xwos_skd_enpmpt_lc() 。\n调度器中的特殊任务 空闲任务 当调度器中没有任何线程就绪，调度器会调度空闲任务； 空闲任务比较特殊，属于 最低优先级 的线程上下文，但不能使用任何会导致睡眠与阻塞的函数。 用户可在空闲任务中HOOK用户代码，方法： 在配置文件 xwbd/电路板/cfg/board.h 中定义配置 BRDCFG_XWSKD_IDLE_HOOK 为 1 ； 定义函数 board_xwskd_idle_hook() 并在其中增加用户代码。 中断底半部任务 当调度器配置 XWOSCFG_SD_BH 为 1 时， 调度器会为系统预留一个 最高优先级 线程； 中断底半部任务比较特殊，属于线程上下文，但不能使用任何会导致睡眠、阻塞的函数； 中断底半部任务可抢占任何线程； 当开启中断底半部时，调度器的滴答定时器任务运行在中断底半部中； XWOS的中断底半部并未完全开发完成，目前只开放给滴答定时器任务使用。 用户可以关闭中断底半部： xwos_skd_dsbh_lc() ， 也可以打开中断底半部： xwos_skd_enbh_lc() 。\n滴答定时器任务 操作系统内核通常都会包含一个定时器，用于产生固定周期的 滴答 （或称为 节拍 ）中断； 滴答定时器任务也即是在此定时器中断中执行的周期性任务； 如果 中断底半部任务 配置为 1 ，滴答定时器任务运行在中断底半部任务内部； 如果 中断底半部任务 配置为 0 ，滴答定时器任务运行在中断上下文中； 用户可以在滴答定时器任务中HOOK自己的代码，方法： 在配置文件 电路板目录/cfg/board.h 中定义配置 BRDCFG_XWSKD_SYSHWT_HOOK 为 1 ； 定义函数 board_xwskd_syshwt_hook() 并在其中增加用户代码。 调度器的中断 切换上下文的中断 调度器用于切换正在执行的线程的中断 中断优先级： 最低 用户可在切换上下文时，Hook自己的代码： 在切换上下文开始之前： 在配置文件 电路板目录/cfg/board.h 中定义配置 BRDCFG_XWSKD_PRE_SWCX_HOOK 为 1 ； 定义Hook函数 board_thd_preinit_hook() 。 在切换上下文开始之后： 在配置文件 电路板目录/cfg/board.h 中定义配置 BRDCFG_XWSKD_POST_SWCX_HOOK 为 1 ； 定义Hook函数 board_thd_postinit_hook() 。 滴答定时器的中断 用于产生固定周期的 滴答 （或称为 节拍 ）的定时器中断，滴答定时器任务由此中断触发执行。 中断优先级： 切换上下文的中断 \u003c= 滴答定时器的中断 \u003c= 调度器服务中断 调度器服务中断 用于执行调度器特殊操作的软中断，包括： 调度器休眠 xwosplcb_skd_suspend_lic() 线程退出 xwosplcb_thd_exit_lic() 线程冻结 xwosplcb_thd_freeze_lic() 线程迁移 xwosplcb_thd_immigrate_lic() 和 xwosplcb_thd_outmigrate_lic() 中断优先级：切换上下文的中断 \u003c= 滴答定时器的中断 \u003c= 调度器服务中断 硬件定时器 XWOS内核要求每个CPU都有一个私有的滴答定时器，产生固定频率的中断； 通常配置为 1000HZ ，可参考配置文件 xwbd/电路板/cfg/xwos.h 中的配置 XWOSCFG_SYSHWT_PERIOD ； XWOS的滴答定时器会产生三个变量： tickcount 滴答计数 在每次滴答定时器中断时，tickcount 都会自增1； tickcount 可以表示滴答定时器中断了多少次； tickcount 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 tickcount ； 通过CAPI xwtm_nowtc() 可以获取当前CPU的 tickcount 。 timetick 系统时间 XWOS内核使用 纳秒(ns) 作为时间的基本单位，假设滴答器频率 1000HZ ， tickcount 每1ms增加一次，即每1ms增加 1000000 ； timetick 与 tickcount 的关系： timetick = tickcount * 1000000 ； timetick 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 timetick ； 通过CAPI xwtm_now() 可以获取当前CPU的 timetick 。 timestamp 系统时间戳 timestamp 是以纳秒为单位的系统时间戳； timestamp 是通过把滴答定时器到下一次中断还剩多少时间计算出来，再累加到 timetick 上获取的，其精度由SOC的主频与计数器的位宽决定； timestamp 是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的 timestamp ； 通过CAPI xwtm_nowts() 可以获取当前CPU的 timestamp 。 超时管理 时间树 XWOS内核中，每个需要超时管理的对象（线程、软件定时器）都是以 时间树节点 组织到时间树中。 时间树节点 中包含了超时的 系统时间点 ，调度器每次进入滴答定时器任务时，都会检测时间树中是否有节点超时。 在时间树中，所有节点的 系统时间点 都是未来的时间。最先超时的节点一定是 系统时间点 最小的节点。 因此时间树的超时问题就是寻找最小值的问题。XWOS使用红黑树解决此最小值的问题，因此算法被称为 时间树 。\n使用一个 leftmost 指针指向最小值，超时可直接从 leftmost 快速获取最小值，时间复杂度为 O(1) ； 超时后， leftmost 从红黑树中被删除，按照二叉树的性质，下一任 leftmost 是前任的右孩子（即后继）。 如果前任的后继为叶子，下一任 leftmost 一定是前任的父节点，算法时间复杂度为 O(1) ； 删除 leftmost 在系统中是一个高频次的操作，但由于 leftmost 缺少左子树，根据红黑树性质，右子树也不可能太复杂， 意味着删除 leftmost 后，调整红黑树的代价不会太大； 插入操作需要遍历树，时间复杂度为 O(logn) ； 红黑树中不允许存在关键字相同的节点，因此拥有相同 系统时间点 的节点组成链表，超时后它们全部被唤醒。 XWOS时间树 Photo: xwos.tech / CC-BY-SA-4.0\n超时函数的统一形式 XWOS所有带超时管理的CAPI函数，都是以后缀 _to 结尾，超时的参数都为 xwtm_t to ：\n/* 睡眠 */ xwer_t xwos_cthd_sleep_to(xwtm_t to); /* 等待信号量 */ xwer_t xwos_sem_wait_to(struct xwos_sem * sem, xwtm_t to); /* 等待条件量 */ xwer_t xwos_cond_wait_to(struct xwos_cond * cond, union xwlk_ulock lock, xwsq_t lktype, void * lkdata, xwtm_t to, xwsq_t * lkst); /* 等待互斥锁 */ xwer_t xwos_mtx_lock_to(struct xwos_mtx * mtx, xwtm_t to); /* 等待信号旗 */ xwer_t xwos_flg_wait_to(struct xwos_flg * flg, xwsq_t trigger, xwsq_t action, xwbmp_t origin[], xwbmp_t msk[], xwtm_t to); /* 等待信号选择器 */ xwer_t xwos_sel_select_to(struct xwos_sel * sel, xwbmp_t msk[], xwbmp_t trg[], xwtm_t to); /* 等待线程同步 */ xwer_t xwos_br_wait_to(struct xwos_br * br, xwsq_t pos, xwbmp_t sync[], xwtm_t to); 参数 to 表明线程期望在未来的某个时间点被唤醒。\n当用户实现了一个具有超时功能的接口，写接口时发现其中需要调用多个具有超时功能的CAPI， 更糟糕的是这些CAPI内部可能又调用了其他具有超时功能的CAPI。\n计算每个CAPI花费了多少时间，然后将他们从超时时间中减去，显然很难实现。 最简单的方式就是只看结果，即 只关注未来什么时间点要唤醒 。 将这个 未来时间点 在内部CAPI中传递，无论这些带有超时功能的CAPI调用多少层，只要发生超时就唤醒。\n例如：\nxwer_t my_api(..., xwtm_t to) { xwer_t rc; ...省略... rc = xwos_mtx_lock_to(mtx, to); ...省略... rc = xwos_sem_wait_to(sem, to); ...省略... return rc; } 无论 xwos_mtx_lock_to() 等待了多少时间，也不会影响 xwos_sem_wait_to() 在 to 这个时间点唤醒。 当 xwos_mtx_lock_to() 把时间用尽， to 就变成 过去的时间点 ， xwos_sem_wait_to() 会立即返回 -ETIMEDOUT 。\n获取上下文 XWOS提供CAPI xwos_skd_get_context_lc() 可以获取上下文：\nXWOS_SKD_CONTEXT_INIT_EXIT ：初始化与反初始化 XWOS_SKD_CONTEXT_THD ：线程 XWOS_SKD_CONTEXT_ISR ：中断 XWOS_SKD_CONTEXT_BH ：中断底半部 XWOS_SKD_CONTEXT_IDLE ：空闲任务 暂停和继续调度器 xwos_skd_pause_lc() ：暂停本地CPU调度器\n暂停调度器包括几个操作： 关闭本地CPU调度器的抢占； 关闭本地CPU调度器的中断底半部； 关闭本地CPU的系统定时器。 xwos_skd_continue_lc() ：继续运行本地CPU调度器\n继续运行调度器包括几个操作： 启动本地CPU的系统定时器； 打开本地CPU调度器的中断底半部； 打开本地CPU调度器的抢占。 CAPI参考 头文件 \u003cxwos/osal/skd.h\u003e 头文件 \u003cxwos/osal/time.h\u003e ","categories":["XWOS"],"description":"XWOS的调度器\n","excerpt":"XWOS的调度器\n","ref":"/docs/TechRefManual/Skd/","tags":"","title":"调度器"},{"body":"概述 XWOS的移植，包括以下几个环节：\n编译环境 初始化流程 XWOS移植层（XWOSPL） XWOS移植实现层（XWOSIMPL） XWOS采用 适配器模式 的方法来构建移植相关的代码：XWOS移植层（XWOSPL）定义 接口， XWOS移植实现层（XWOSIMPL）提供 实现 。\n为了提高代码的复用性，XWOS移植实现层（XWOSIMPL）相关的代码又细分为：\n架构描述层(ADL) CPU描述层(CDL) SOC描述层(SDL) 电路板描述层(BDL) 例如，ARMv7m架构下，ADL目录为 xwcd/soc/arm/v7m/gcc/ ，其中代码对 STM32、S32K、i.MX RT1052、GD32等都是复用的，m3、m4、m7的差异又由CDL目录来描述， 相同的CPU内核不同SOC又由SDL来描述，不同的电路板由BDL来描述，最后由他们共同完成 对编译环境、初始化流程以及XWOS移植实现层（XWOSIMPL）的 实现 。\nXWOS移植层（XWOSPL）头文件规则 xwos/ospl/*.h ：XWOS提供给BSP的头文件， 不可 被XWOS自身的头文件包含。 前缀 xwospl ：BSP中需要提供实现的函数 前缀 xwosplcb ：BSP中可以调用的函数 xwos/ospl/soc/*.h ：其中包含了BSP提供给XWOS的头文件， 可被 XWOS的头文件包含。 xwos/ospl/soc/type.h ：包含了平台类型的定义 xwos/ospl/soc/compiler.h ：包含了平台编译器相关的定义 xwos/ospl/soc/isa.h ：包含了平台指令和架构相关的定义 xwos/ospl/soc/lfq.h ：包含了无锁队列相关的定义 xwos/ospl/soc/setjmp.h ：包含了 setjmp.h 相关的定义 xwos/ospl/soc/spinlock.h ：包含了自旋锁相关的定义 xwos/ospl/soc/xwaop[bit].h ：包含了原子操作相关的定义 xwos/ospl/soc/xwbmpaop.h ：包含了位图原子操作相关的定义 xwos/ospl/soc/xwbop.h ：包含了位操作相关的定义 xwos/ospl/soc/xwsc.h ：包含了系统调用相关的定义 移植 XWOS的移植，包括：基本类型、编译器、断点、setjmp、系统调用与系统特权、 位操作、原子操作、无锁队列、自旋锁、中断、硬件定时器、调度器。\n基本类型 XWOS定义了自己的一套基本类型，所有源码都是围绕基本类型展开的。\nXWOS头文件： xwos/lib/type.h ， 详见基本类型。 Adapter： xwos/ospl/soc/type.h Adaptee： xwosimpl_soc_type.h 文件对某些类型按照架构的ELFABI规则重新进行了定义， 并且需要将 ARCH_HAVE_xxxx 宏定义为1，表明覆盖 xxxx 的默认定义， 此文件一般位于 ADL 目录，例如 xwcd/soc/arm/v7m/gcc/xwosimpl_soc_type.h 。 基本类型： ARCH_HAVE_XWU8_T ：宏，定义为1表示 arch_type.h 中提供类型 xwu8_t xwu8_t ：类型，8位无符号整数 ARCH_HAVE_ATOMIC_XWU8_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwu8_t atomic_xwu8_t ：类型，原子的8位无符号整数 ARCH_HAVE_XWS8_T ：宏，定义为1表示 arch_type.h 中提供类型 xws8_t xws8_t ：类型，8位有符号整数 ARCH_HAVE_ATOMIC_XWS8_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xws8_t atomic_xws8_t ：类型，原子的8位有符号整数 ARCH_HAVE_XWU16_T ：宏，定义为1表示 arch_type.h 中提供类型 xwu16_t xwu16_t ：类型，16位无符号整数 ARCH_HAVE_ATOMIC_XWU16_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwu16_t atomic_xwu16_t ：类型，原子的16位无符号整数 ARCH_HAVE_XWS16_T ：宏，定义为1表示 arch_type.h 中提供类型 xws16_t xws16_t ：类型，16位有符号整数 ARCH_HAVE_ATOMIC_XWS16_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xws16_t atomic_xws16_t ：类型，原子的16位有符号整数 ARCH_HAVE_XWU32_T ：宏，定义为1表示 arch_type.h 中提供类型 xwu32_t xwu32_t ：类型，32位无符号整数 ARCH_HAVE_ATOMIC_XWU32_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwu32_t atomic_xwu32_t ：类型，原子的32位无符号整数 ARCH_HAVE_XWS32_T ：宏，定义为1表示 arch_type.h 中提供类型 xws32_t xws32_t ：类型，32位有符号整数 ARCH_HAVE_ATOMIC_XWS32_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xws32_t atomic_xws32_t ：类型，原子的32位有符号整数 ARCH_HAVE_XWU64_T ：宏，定义为1表示 arch_type.h 中提供类型 xwu64_t xwu64_t ：类型，64位无符号整数 ARCH_HAVE_ATOMIC_XWU64_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwu64_t atomic_xwu64_t ：类型，原子的64位无符号整数 ARCH_HAVE_XWS64_T ：宏，定义为1表示 arch_type.h 中提供类型 xws64_t xws64_t ：类型，64位有符号整数 ARCH_HAVE_ATOMIC_XWS64_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xws64_t atomic_xws64_t ：类型，原子的64位有符号整数 ARCH_HAVE_XWSZ_T ：宏，定义为1表示 arch_type.h 中提供类型 xwsz_t xwsz_t ：类型，无符号大小值类型 ARCH_HAVE_ATOMIC_XWSZ_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwsz_t atomic_xwsz_t ：类型，原子的无符号大小值类型 ARCH_HAVE_XWSSZ_T ：宏，定义为1表示 arch_type.h 中提供类型 xwssz_t xwssz_t ：类型，有符号大小值类型 ARCH_HAVE_ATOMIC_XWSSZ_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwssz_t atomic_xwssz_t ：类型，原子的有符号大小值类型 ARCH_HAVE_XWSTK_T ：宏，定义为1表示 arch_type.h 中提供类型 xwstk_t xwstk_t ：类型，无符号栈类型 ARCH_HAVE_ATOMIC_XWSTK_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwstk_t atomic_xwstk_t ：类型，原子的无符号栈类型 ARCH_HAVE_XWPTR_T ：宏，定义为1表示 arch_type.h 中提供类型 xwptr_t xwptr_t ：类型，无符号指针值类型 ARCH_HAVE_ATOMIC_XWPTR_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwptr_t atomic_xwptr_t ：类型，原子的无符号指针值类型 ARCH_HAVE_XWREG_T ：宏，定义为1表示 arch_type.h 中提供类型 xwreg_t xwreg_t ：类型，无符号寄存器类型 ARCH_HAVE_ATOMIC_XWREG_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwreg_t atomic_xwreg_t ：类型，原子的无符号寄存器类型 ARCH_HAVE_XWSREG_T ：宏，定义为1表示 arch_type.h 中提供类型 xwsreg_t xwsreg_t ：类型，有符号寄存器类型 ARCH_HAVE_ATOMIC_XWSREG_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwsreg_t atomic_xwsreg_t ：类型，原子的有符号寄存器类型 ARCH_HAVE_XWSQ_T ：宏，定义为1表示 arch_type.h 中提供类型 xwsq_t xwsq_t ：类型，无符号顺序值类型 ARCH_HAVE_ATOMIC_XWSQ_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwsq_t atomic_xwsq_t ：类型，原子的无符号顺序值类型 ARCH_HAVE_XWSSQ_T ：宏，定义为1表示 arch_type.h 中提供类型 xwssq_t xwssq_t ：类型，有符号顺序值类型 ARCH_HAVE_ATOMIC_XWSSQ_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwssq_t atomic_xwssq_t ：类型，原子的有符号顺序值类型 ARCH_HAVE_XWID_T ：宏，定义为1表示 arch_type.h 中提供类型 xwid_t xwid_t ：类型，无符号ID值类型 ARCH_HAVE_ATOMIC_XWID_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwid_t atomic_xwid_t ：类型，原子的无符号ID值类型 ARCH_HAVE_XWSID_T ：宏，定义为1表示 arch_type.h 中提供类型 xwsid_t xwsid_t ：类型，有符号ID值类型 ARCH_HAVE_ATOMIC_XWSID_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwsid_t atomic_xwsid_t ：类型，原子的有符号ID值类型 ARCH_HAVE_XWER_T ：宏，定义为1表示 arch_type.h 中提供类型 xwer_t xwer_t ：类型，有符号错误码类型 ARCH_HAVE_ATOMIC_XWER_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwer_t atomic_xwer_t ：类型，原子的有符号错误码类型 ARCH_HAVE_XWPR_T ：宏，定义为1表示 arch_type.h 中提供类型 xwpr_t xwpr_t ：类型，有符号优先级类型 ARCH_HAVE_ATOMIC_XWPR_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwpr_t atomic_xwpr_t ：类型，原子的有符号优先级类型 ARCH_HAVE_XWBMP_T ：宏，定义为1表示 arch_type.h 中提供类型 xwbmp_t xwbmp_t ：类型，无符号位图类型 ARCH_HAVE_ATOMIC_XWBMP_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwbmp_t xwbmpy_a ：类型，原子的无符号位图类型 ARCH_HAVE_XWTM_T ：宏，定义为1表示 arch_type.h 中提供类型 xwtm_t xwtm_t ：类型，有符号优先级类型 ARCH_HAVE_ATOMIC_XWTM_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwtm_t atomic_xwtm_t ：类型，原子的有符号优先级类型 ARCH_HAVE_XWLFQ_T ：宏，定义为1表示 arch_type.h 中提供类型 xwlfq_t xwlfq_t ：类型，无锁队列类型 ARCH_HAVE_ATOMIC_XWLFQ_T ：宏，定义为1表示 arch_type.h 中提供类型 atomic_xwlfq_t atomic_xwlfq_t ：类型，原子的无锁队列类型 ARCH_HAVE_XWISR_F ：宏，定义为1表示 arch_type.h 中提供类型 xwisr_f atomic_xwer_t ：类型，原子的有符号错误码类型 ARCH_HAVE_XWIRQ_T ：宏，定义为1表示 arch_type.h y中提供类型 xwirq_t xwirq_t ：类型，有符号中断号类型 编译器 XWOS头文件： xwos/lib/compiler.h ，被 xwos/standard.h 包含。 Adapter： xwos/ospl/soc/compiler.h Adaptee： xwosimpl_soc_compiler.h 编译器相关的宏定义：\n__xwcc_section(s) ：表明符号属于段 s 。 __xwcc_aligned(x) ：表明数据的起始地址对齐到x字节处。 __xwcc_inline ：表明函数是内联函数，需要和 static 一起使用。 __xwcc_packed ：表明数据结构体是紧凑分布的，编译器不要做优化对齐处理。 __xwcc_must_check ：表明函数返回值必须被读取，否则编译器会报警告。 __xwcc_unused ：表明变量或函数未被使用，用于去除编译警告。 __xwcc_noreturn ：表明函数不会返回。 __xwcc_hot ：表明函数在代码中经常被调用，可以帮助某些编译器优化编译。 __xwcc_atomic ：表明变量是原子的，C11标准中被定义为_Atomic，C99标准中被定义为volatile。 __xwcc_likely(x) ：表明条件 x 大概率为 true ，用于编译 if..else.. 的优化。 __xwcc_unlikely(x) ：表明条件 x 大概率为 false ，用于编译 if..else.. 的优化。 __xwcc_alignl1cache ：表明数据的起始地址对齐到1级缓存(way-set缓存)的缓存线 __xwcc_alignptr ：表明数据的起始地址对齐到指针的尺寸 xwcc_offsetof(type, member) ：计算member在结构体type中的偏移，等价于标准C库中的 offsetof() 。 架构指令 CPU架构会提供一些特殊指令，一般这些指令很难用C语言表达出，以方便使用，XWOS内核对统一的部分进行了相同的封装。\nXWOS头文件：被包含在 xwos/standard.h 内。 Adapter： xwos/ospl/soc/isa.h Adaptee： xwosimpl_soc_isa.h 这些架构指令包括但不限于：\n断点指令 内存屏障 setjmp/longjmp XWOS的C库中提供了类似于C标准库中的 setjmp()/longjmp() 函数组合， 其实现与切换上下文时如何保存寄存器有密切关系。\nXWOS头文件： xwos/lib/setjmp.h Adapter： xwos/ospl/soc/setjmp.h Adaptee： xwosimpl_soc_setjmp.h 系统调用与系统特权 通常CPU都有两种权限模式：用户和系统。\n系统模式下可以访问所有的寄存器； 用户模式下某些CPU内的寄存器无法被访问（例如开关中断），只能通过特殊指令让CPU进入系统模式才可访问。 XWOS的C库中提供了可切换CPU访问权限的函数 xwsc() ，通过 xwsc() 可以让用户模式暂时拥有系统特权调用某个函数。\nXWOS头文件： xwos/lib/sc.h Adapter： xwos/ospl/soc/xwsc.h Adaptee： xwosimpl_soc_xwsc.h 位操作 XWOS的C库中提供了位操作的函数集合，为提高效率，部分位操作可使用特殊指令实现。\nXWOS头文件： xwos/lib/xwbop.h Adapter： xwos/ospl/soc/xwbop.h Adaptee： xwosimpl_soc_xwbop.h 基本类型的位操作函数集合： 位序镜面翻转：Intel位序（主流的小端CPU都是Inter位序）是越往高位位序号越大， 摩托罗拉位序（PowerPC架构的CPU）是越往高位位序号越小， 因此在两个系统混用时需要将数据的位序进行镜面翻转 xwbop_rbit8() ：镜面翻转8位数据的位序 xwbop_rbit16() ：镜面翻转16位数据的位序 xwbop_rbit32() ：镜面翻转32位数据的位序 xwbop_rbit64() ：镜面翻转64位数据的位序 大小端反转 xwbop_re16() ：反转16位数据的字节序 xwbop_re16s32() ：反转16位数据的字节序，并将符号位扩展到32位，返回有符号32位数据 xwbop_re32() ：反转32位数据的字节序 xwbop_re32s64() ：反转32位数据的字节序，并将符号位扩展到64位，返回有符号64位数据 xwbop_re64() ：：反转64位数据的字节序 查找被置1的位 xwbop_ffs8() ：8位数据，从最低有效位开始查找 xwbop_fls8() ：8位数据，从最高有效位开始查找 xwbop_ffs16() ：16位数据，从最低有效位开始查找 xwbop_fls16() ：16位数据，从最高有效位开始查找 xwbop_ffs32() ：32位数据，从最低有效位开始查找 xwbop_fls32() ：32位数据，从最高有效位开始查找 xwbop_ffs64() ：64位数据，从最低有效位开始查找 xwbop_fls64() ：64位数据，从最高有效位开始查找 原子操作 XWOS的C库中提供了原子操作的函数集合，原子操作的实现依赖于CPU的原子操作指令。\nXWOS头文件： xwos/lib/xwaop.h Adapter： xwos/ospl/soc/xwaop.h Adaptee： xwosimpl_soc_xwaop.h xwosimpl_soc_xwaop/* 说明 其他类型的原子操作，XWOS内核会基于4个基本类型进行封装。 64位原子操作如果不支持可不提供； 如果CPU架构比较简单，无原子操作指令，可通过关中断实现这些原子操作函数； 某些CPU架构只提供与CPU位宽一致的原子操作指令，考虑代码的通用性，最好只使用 与CPU位宽一致的原子数据类型； 基本类型的原子操作函数集合： load() ：加载（可指定内存序） store() ：存储（可指定内存序） read() ：读（内存序：load-require） write() ：写（内存序：store-release） add() ：加法运算 sub() ：减法运算 rsb() ：反向减法运算 and() ：与运算 or() ：或运算 xor() ：异或运算 teq_then_write() ：测试是否与测试值 相等 ，然后 写 teq_then_add() ：测试是否与测试值 相等 ，然后做 加法 运算 teq_then_sub() ：测试是否与测试值 相等 ，然后做 减法 运算 teq_then_rsb() ：测试是否与测试值 相等 ，然后做 反向减法 运算 tne_then_write() ：测试是否与测试值 不相等 ，然后 写 tne_then_add() ：测试是否与测试值 不相等 ，然后做 加法 运算 tne_then_sub() ：测试是否与测试值 不相等 ，然后做 减法 运算 tne_then_rsb() ：测试是否与测试值 不相等 ，然后做 反向减法 运算 tge_then_write() ：测试是否 大于等于 测试值，然后 写 tge_then_add() ：测试是否 大于等于 测试值，然后做 加法 运算 tge_then_sub() ：测试是否 大于等于 测试值，然后做 减法 运算 tge_then_rsb() ：测试是否 大于等于 测试值，然后做 反向减法 运算 tgt_then_write() ：测试是否 大于 测试值，然后 写 tgt_then_add() ：测试是否 大于 测试值，然后做 加法 运算 tgt_then_sub() ：测试是否 大于 测试值，然后做 减法 运算 tgt_then_rsb() ：测试是否 大于 测试值，然后做 反向减法 运算 tle_then_write() ：测试是否 小于等于 测试值，然后 写 tle_then_add() ：测试是否 小于等于 测试值，然后做 加法 运算 tle_then_sub() ：测试是否 小于等于 测试值，然后做 减法 运算 tle_then_rsb() ：测试是否 小于等于 测试值，然后做 反向减法 运算 tlt_then_write() ：测试是否 小于 测试值，然后 写 tlt_then_add() ：测试是否 小于 测试值，然后做 加法 运算 tlt_then_sub() ：测试是否 小于 测试值，然后做 减法 运算 tlt_then_rsb() ：测试是否 小于 测试值，然后做 反向减法 运算 tgele_then_write() ：测试是否旧值是否在闭区间 [l,r] ，然后 写 tgele_then_add() ：测试是否旧值是否在闭区间 [l,r] ，然后做 加法 运算 tgele_then_sub() ：测试是否旧值是否在闭区间 [l,r] ，然后做 减法 运算 tgele_then_rsb() ：测试是否旧值是否在闭区间 [l,r] ，然后做 反向减法 运算 tgelt_then_write() ：测试是否旧值是否在左闭右开区间 [l,r) ，然后 写 tgelt_then_add() ：测试是否旧值是否在左闭右开区间 [l,r) ，然后做 加法 运算 tgelt_then_sub() ：测试是否旧值是否在左闭右开区间 [l,r) ，然后做 减法 运算 tgelt_then_rsb() ：测试是否旧值是否在左闭右开区间 [l,r) ，然后做 反向减法 运算 tgtle_then_write() ：测试是否旧值是否在左开右闭区间 (l,r] ，然后 写 tgtle_then_add() ：测试是否旧值是否在左开右闭区间 (l,r] ，然后做 加法 运算 tgtle_then_sub() ：测试是否旧值是否在左开右闭区间 (l,r] ，然后做 减法 运算 tgtle_then_rsb() ：测试是否旧值是否在左开右闭区间 (l,r] ，然后做 反向减法 运算 tgtlt_then_write() ：测试是否旧值是否在开区间 (l,r) ，然后 写 tgtlt_then_add() ：测试是否旧值是否在开区间 (l,r) ，然后做 加法 运算 tgtlt_then_sub() ：测试是否旧值是否在开区间 (l,r) ，然后做 减法 运算 tgtlt_then_rsb() ：测试是否旧值是否在开区间 (l,r) ，然后做 反向减法 运算 tst_then_op() ：使用 tst() 函数测试，然后使用 op() 函数操作 位图数组的原子操作 xwbmpaop_c0i() ：将第i位清0 xwbmpaop_s1i() ：将第i位置1 xwbmpaop_x1i() ：翻转第i位 xwbmpaop_t1i() ：测试第i位是否为1 xwbmpaop_t0i_then_s1i() ：测试第i位是否为0，然后把它置1 xwbmpaop_t1i_then_c0i() ：测试第i位是否为1，然后把它清0 xwbmpaop_ffs_then_c0i() ：从最低有效位开始查找第一个为1的位并把它清0 xwbmpaop_ffz_then_s1i() ：从最低有效位开始查找第一个为0的位并把它置1 xwbmpaop_fls_then_c0i() ：从最高有效位开始查找第一个为1的位并把它清0 xwbmpaop_flz_then_s1i() ：从最高有效位开始查找第一个为0的位并把它置1 无锁队列 XWOS的C库中提供了无锁队列的函数，无锁队列的实现依赖于CPU的原子操作指令。\nXWOS头文件： xwos/lib/lfq.h Adapter： xwos/ospl/soc/lfq.h Adaptee： xwosimpl_soc_lfq.h 自旋锁 在多核系统中，被多个CPU共同访问的内存区域需要被自旋锁保护，自旋锁的实现依赖于 原子操作指令与内存屏障指令。\nXWOS头文件： xwos/osal/lock/spinlock.h ：自旋锁 xwos/osal/lock/seqlock.h ：自旋锁的派生锁，顺序锁 Adapter： xwos/ospl/soc/spinlock.h Adaptee： xwosimpl_soc_spinlock.h 中断 XWOS头文件： xwos/osal/irq.h Adapter： xwos/ospl/irq.h ： 定义 了BSP中需要适配的函数； Adaptee： xwosimpl_irq.h ： 实现 了XWOS移植层中定义的函数； 中断号： XWOS定义了中断号类型 xwirq_t ，是一个有符号数： 整数和0：表示SOC的外设中断； 负数：表示异常。 中断优先级要求 切换上下文的中断为系统中最低优先级中断 切换上下文的中断 \u003c= 滴答定时器的中断 \u003c= 调度器服务中断 操作系统移植层中需要提供的函数： void xwospl_cpuirq_enable_lc(void) ：开启CPU的中断开关 void xwospl_cpuirq_disable_lc(void) ：关闭CPU的中断开关 void xwospl_cpuirq_restore_lc(xwreg_t cpuirq) ：保存当前CPU的中断开关状态后关闭 void xwospl_cpuirq_save_lc(xwreg_t * cpuirq) ：恢复之前保存的CPU的中断开关状态 xwer_t xwospl_irq_get_id(xwirq_t * irqnbuf) ：获取当前中断的中断号，亦可用于判断上下文 xwer_t xwospl_irq_enable(xwirq_t irqn) ：开启某个外设中断 xwer_t xwospl_irq_disable(xwirq_t irqn) ：关闭某个外设中断 xwer_t xwospl_irq_save(xwirq_t irqn, xwreg_t * flag) ：保存某个外设中断的开关，然后将其关闭 xwer_t xwospl_irq_restore(xwirq_t irqn, xwreg_t flag) ：恢复某个外设中断的开关 硬件定时器 每个CPU都需要一个私有的硬件定时器提供滴答中断，XWOS的调度、超时、软件定时器都基于滴答中断来实现。\nAdapter： xwos/ospl/syshwt.h Adaptee： xwosimpl_syshwt.h 适配函数： xwospl_syshwt_init() ：初始化硬件定时器 xwospl_syshwt_start() ：启动硬件定时器 xwospl_syshwt_stop() ：关闭硬件定时器 xwospl_syshwt_get_timeconfetti() ：返回还有多少纳秒进入下一次定时器中断 调度器 Adapter： xwos/ospl/skd.h Adaptee： xwosimpl_skd.h 适配函数： xwospl_skd_init(struct xwospl_skd * xwskd) ：初始化调度调度器 xwospl_skd_init_stack() ：初始化调度对象（线程）的栈 xwospl_skd_get_id() ：获取当前CPU的ID xwospl_skd_start() ：启动调度器 xwospl_skd_suspend() ：暂停调度器，用于电源管理 xwospl_skd_resume() ：继续调度器，用于电源管理 xwospl_skd_req_swcx() ：请求调度 xwospl_skd_isr_swcx() ：切换上下文的中断 xwospl_thd_exit_lc() ：当前CPU上的线程退出 xwospl_thd_freeze_lc() ：冻结当前CPU中正在运行的线程 xwospl_thd_outmigrate() ：将线程迁出其他CPU，并准备迁入其他CPU（仅限多核） xwospl_thd_immigrate() ：迁移线程至目标CPU（仅限多核） 链接脚本 SOC描述层中包含了SOC的基本链接脚本，使用时需要在电路板目录的 cfg 文件夹中定义一个 XuanWuOS.lds ， 其中包含了SOC的地址空间的定义，然后再 include SOC描述层中的连接脚本即可。 例如： xwbd/WeActH750/cfg/XuanWuOS.lds 中只定义了 MEMORY 和 include xwcd/soc/arm/v7m/gcc/m7/stm32/h7.lds 。\nXWOS定义了一些 段(section) ，链接时，可将内核代码、内核数据放在镜像文件的特定区域。 这需要在 链接脚本 中指明这些 段 如何存放。 __xwos_init_code ：初始化代码，存放在 .xwos.init.text 段 __xwos_init_rodata ：初始化阶段的const数据，存放在 .xwos.init.rodata 段 __xwos_exit_code ：退出代码，存放在 .xwos.exit.text 段 __xwos_exit_rodata ：退出阶段的const数据，存放在 .xwos.exit.rodata 段 __xwos_ivt ：中断向量表，存放在 .xwos.ivt 段 __xwos_isr ：中断代码，存放在 .xwos.isr.text 段 __xwos_bh ：中断底半部代码，存放在 .xwos.isr.text 段 __xwos_code ：XWOS内核代码，存放在 .xwos.text 段 __xwos_api ：XWOS内核API，存放在 .xwos.text 段 __xwos_rodata ：const数据，存放在 .xwos.rodata 段 __xwos_data ：全局变量与静态变量，存放在 .xwos.data 段 如果不需要这些自定义的 段 ，可将上面的宏定义为 空 ，相应的，代码会默认 放在 .text 段，数据会默认放在 .data 段，const数据会默认放在 .rodata 段。 这三个 段 都是由编译器默认产生的。 当 __xwos_data 定义为 空 时，配置文件 cfg/xwos.h 中的配置 XWKNCFG_RELOCATE_DATA 也应该不定义或定义为 0 。 初始化流程 XWOS提供了一个通用的启动流程：\nflowchart LR poweron(\"上电\") --\u003e 低级初始化阶段 --\u003e 系统初始化阶段 --\u003e 用户程序 subgraph 低级初始化阶段 direction TB arch_lowlevel_init[\"arch_lowlevel_init()\"] --\u003e cpu_lowlevel_init cpu_lowlevel_init[\"cpu_lowlevel_init()\"] --\u003e soc_lowlevel_init soc_lowlevel_init[\"soc_lowlevel_init()\"] --\u003e board_lowlevel_init board_lowlevel_init[\"board_lowlevel_init()\"] end subgraph 系统初始化阶段 direction TB xwos_init[\"xwos_init()\"] --\u003e arch_relocate arch_relocate[\"arch_relocate()\"] --\u003e arch_init arch_init[\"arch_init()\"] --\u003e cpu_init cpu_init[\"cpu_init()\"] --\u003e soc_init soc_init[\"soc_init()\"] --\u003e board_init end subgraph 用户程序 direction LR subgraph \"xwos_main()\" direction LR skd[\"启动调度器\"] thd[\"线程初始化\"] device[\"设备驱动初始化\"] libc[\"C/C++标准库初始化\"] lua[\"Lua虚拟机初始化\"] end end 用户可在流程中找地方插入SOC的初始化的代码，但要注意： lowlevel_init的流程中不可访问全局变量，因为还未将全局变量的初值从flash中拷贝到RAM中； cxx_init之后才可开始调用C++的代码； XWOS的初始化流程中，在 soc_init() 中完成对中断控制器、调度器的初始化， 如果用户不使用XWOS的初始化流程，需要依次调用： xwos_init() ：初始化XWOS内核； 多核系统： xwmp_irqc_construct() ：初始化每个CPU的中断控制器； xwmp_irqc_register() ：将每个CPU的中断控制器注册到中断控制子系统； xwmp_skd_init_lc() ：分别在每个CPU上都运行一次这个函数初始化自己的调度器； 单核系统： xwup_irqc_init() ：初始化中断控制器； xwup_skd_init_lc() ：初始化调度器； 编译集成环境 XWOS提供了一个构建系统，可在Windows、Linux上运行。 用户可以选择使用XWOS的编译集成环境，也可以使用其他IDE进行编译。\n使用玄武构建系统 XWOS的构建系统在构建 内核 、 xwmd 模块、 xwcd 模块、 xwem 模块、 xwam 模块、 oem 模块时都是独立编译成静态库 .a ，然后再链接。 各个模块的编译配置（头文件、编译器选项）都是完全独立的，可以理解为不同的子工程。 构建是从 xwbd/电路板名称/ 录下执行命令 make 开始的。 使用其他IDE构建系统 需要增加的头文件搜索路径： XWOS根目录 XWOS 架构描述层(ADL)目录：以ARMv7m为例， xwcd/soc/arm/v7m/gcc CPU描述层(CDL)目录：以ARMv7m7为例， xwcd/soc/arm/v7m/gcc/m7 SOC描述层(SDL)目录：以STM32H7为例， xwcd/soc/arm/v7m/gcc/m7/stm32h7x 电路板目录：以开发板 WeActMiniStm32H750 为例， xwbd/WeActMiniStm32H750 需要包含的源码文件： 内核目录 xwos 架构描述层(ADL)目录：以ARMv7m为例， xwcd/soc/arm/v7m/gcc CPU描述层(CDL)目录：以ARMv7m7为例， xwcd/soc/arm/v7m/gcc/m7 SOC描述层(SDL)目录：以STM32H7为例， xwcd/soc/arm/v7m/gcc/m7/stm32h7x 电路板目录：以开发板WeActH750为例， xwbd/WeActH750 中间件 xwmd 、驱动框架 xwcd/ds 、第三方模块 xwem 、应用模块 xwam 不是必须的，若只使用XWOS内核，这些可以删除。 若其他IDE的工具链不是gcc，则需要重新实现ADL、CDL、SDL中的 xwosimpl 的代码，此种情况 xwcd/soc 中的代码也不需要。 需要修改配置， xwbd/WeActMiniStm32H750/cfg 。 需要在 xwbd/WeActMiniStm32H750 目录，执行一次 make cfg ，生成 然后将 xwbd/WeActMiniStm32H750/wkspc/autogen.h 拷贝到 xwbd/WeActMiniStm32H750/cfg 中。 需要配置IDE的连接脚本。 ","categories":"","description":"","excerpt":"概述 XWOS的移植，包括以下几个环节：\n编译环境 初始化流程 XWOS移植层（XWOSPL） XWOS移植实现层（XWOSIMPL） …","ref":"/docs/Note/SOC/","tags":"","title":"SOC移植"},{"body":"概述 线程 是XWOS最基本的调度单位，在其他RTOS中可能称之为 任务 。 XWOS的线程，除了最基本的运行、睡眠、退出操作外，还支持冻结与解冻，迁移等操作。\nXWOS线程的函数，是仿造 pthread 的函数设计的。\n线程的状态 XWOS线程状态图 Photo: xwos.tech / CC-BY-SA-4.0\n待命（standby） ：线程对象已被初始化，但未指定主函数； 就绪（ready） ：线程已加入到就绪队列中； 运行（running） ：线程正在运行，每个CPU中只可能存在一个线程正在运行； 睡眠（sleeping） ：线程正在睡眠； 阻塞（blocking） ：线程正在等待，可与睡眠态组合； 可被冻结（freezable） ：线程可被冻结； 冻结（frozen） ：线程已被冻结； 退出（exiting） ：线程即将结束； 迁移（migrating） ：线程正处于迁移到别的CPU的过程中； 分离态(detached) ：分离态的线程退出后由操作系统自动回收其内存资源； 已连接(joined) ： 连接态(joinable) 的线程被其他线程 join() 后的状态； 不可被中断（uninterrupted） ：线程的 阻塞 与 睡眠 不可被中断。 线程的分离态与连接态 XWOS线程的分离态与连接态是参考 pthread 设计的：\n连接态(joinable) 线程需要由另一个线程调用 xwos_thd_join() 或 xwos_thd_stop() 来回收其内存资源； 分离态(detached) 的线程退出后，系统自动回收其资源。 线程对象与对象描述符 线程对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，线程对象也用 线程对象描述符 xwos_thd_d 来解决有效性和身份合法性的问题。\n线程对象描述符由 线程对象的指针 和 标签 组成：\ntypedef struct { struct xwos_thd * thd; /**\u003c 线程对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_thd_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n线程的初始化与创建 线程属性 线程在创建或初始化时，可通过参数 struct xwos_thd_attr 设定其属性。 XWOS的线程属性参考 pthread 来实现，其结构体定义也与 pthread_attr_t 类似。\nxwos_thd_attr::privileged ：表示线程拥有系统特权。 在ARMv6m/ARMv7m中，是通过 CONTROL 寄存器的 bit0(nPRIV) 来实现的； 在Embedded PowerPC中，是通过 MSR 寄存器的 bit17(PR) 来实现的； 在RISCV32中，是通过 MCAUSE 寄存器的 bit28 和 bit29(MPP) 来实现的。 xwos_thd_attr::detached ：表示线程是分离的，类似于POSIX线程的detached属性。 分离态(detached) 的线程退出后，系统自动回收其资源； 连接态(joinable) 线程需要由另一个线程调用 xwos_thd_join() 或 xwos_thd_stop() 来回收其内存资源。 xwos_thd_attr::stack ：表示线程的栈的首地址。 xwos_thd_attr::stack_size ：表示线程的栈的字节数。 xwos_thd_attr::stack_guard_size ：表示线程的警戒线位置。 当栈指针sp增长超过了警戒线位置会触发 stackoverflow 警告，但这需要SOC的MPU或MMU来提供支持， 可以在线程创建后的HOOK函数 board_thd_postinit_hook() 来针对不同的SOC设置MPU或MMU。 XWOS内部也提供了一种基于 if...else... 的检测逻辑，但 stack overflow 后导致程序跑飞，可能没有机会运行检测逻辑的代码。 xwos_thd_attr::name ：表示线程的名字，用于调试时的日志输出。 xwos_thd_attr::priority ：表示线程的优先级，XWOS的优先级是数值越大，优先级越高。 静态初始化 静态初始化： xwos_thd_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 静态初始化线程还需预先定义栈数组，作用域为全局。 栈数组的首地址与大小，必须要满足CPU的ABI规则。例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 __xwcc__aligned(8) 来修饰，且大小是8的倍数。 如果CPU内有L1Cache，应该使用 __xwcc_alignl1cache 来修饰栈数组，让其对其到L1Cache的缓存线上。 示例 #define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1) struct xwos_thd static_thd; xwos_thd_d static_thdd; __xwcc_aligned(8) xwstk_t static_thd_stack[512]; xwer_t thd_func(void * arg) { /* ...线程函数... */ } void some_function(void) { xwos_thd_attr_init(\u0026attr); attr.name = \"static.thd\"; attr.stack = static_thd_stack; attr.stack_size = sizeof(static_thd_stack); attr.priority = THD_PRIORITY; attr.detached = false; attr.privileged = true; rc = xwos_thd_init(\u0026static_thd, \u0026static_thdd, \u0026attr, thd_func, NULL); } 动态创建 动态创建： xwos_thd_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 动态方式创建的线程，栈内存也可以动态申请，其地址对齐问题由操作系统内核处理。 动态方式创建的线程，栈内存也支持使用静态方式定义的数组。栈数组的首地址与大小，必须要满足CPU的ABI规则。 例如ARM，就要求8字节对齐，因此在定义栈数组时需要使用 __xwcc__aligned(8) 来修饰，且大小是8的倍数。 如果CPU内有L1Cache，应该使用 __xwcc_alignl1cache 来修饰栈静态方式定义的数组，让其对其到L1Cache的缓存线上。 #define THD_PRIORITY XWOS_SKD_PRIORITY_DROP(XWOS_SKD_PRIORITY_RT_MAX, 1) xwos_thd_d dynamic_thdd; xwer_t thd_func(void * arg) { /* ...线程函数... */ } void some_function(void) { struct xwos_thd_attr attr; xwer_t rc; xwos_thd_attr_init(\u0026attr); attr.name = \"dynamic.thd\"; attr.stack = NULL; attr.stack_size = 2048; attr.priority = THD_PRIORITY; attr.detached = false; attr.privileged = true; rc = xwos_thd_create(\u0026dynamic_thdd, \u0026attr, thd_func, NULL); } 中断线程的阻塞态与睡眠态 但线程调用了会 阻塞 或 睡眠 的函数而进入 阻塞态 或 睡眠态 时，它会让出CPU，调度器会重新调度。 其他线程或上下文可以通过 xwos_thd_intr() 中断其 阻塞态 或 睡眠态 ， 阻塞 或 睡眠 的函数会以错误码 -EINTR ( -4 ) 返回。\n线程的退出与返回值 线程的退出 线程退出通常有两种方式：\n主函数直接 return xwer_t thd_func(void * arg) { /* ...省略... */ return rc; } 主函数中调用 xwos_cthd_exit(rc) 此CAPI的用法类似于POSIX中的函数 pthread_exit() ，调用的线程会立即终止并抛出返回值。\nxwer_t thd_func(void * arg) { /* ...省略... */ xwos_cthd_exit(XWOK); /* 线程在此处结束，并抛出返回值 */ /* 后面的代码不再执行 ... */ } 线程分离 线程退出的行为，与属性 xwos_thd_attr::detached 有关：\n分离态(detached) 的线程退出后，系统自动回收其资源； 连接态(joinable) 线程需要由另一个线程调用 xwos_thd_join() 或 xwos_thd_stop() 来回收其内存资源。 若忘记调用，资源不会自动被回收。 通知线程退出 xwos_thd_quit() 可用于通知线程退出。 调用此CAPI，可为线程设置 退出状态 ，并中断线程的 阻塞状态 和 睡眠状态 。\n被通知退出的线程 正在调用的 阻塞和睡眠 的CAPI将以返回值 -EINTR 返回。除非 被通知退出的线程 是 不可被中断 的。\n线程自己可以通过 xwos_cthd_shld_stop() 或 xwos_cthd_frz_shld_stop() 检测 退出状态 。\n等待线程退出 若线程是 连接态(joinable) 的，其他线程可通过 xwos_thd_join() 等待线程结束并获取其返回值。 此CAPI调用后，操作系统还会回收线程的资源。\n终止线程 xwos_thd_stop() 可终止线程并等待它退出。 此CAPI等价于 xwos_thd_quit() + xwos_thd_join() 。\n线程自身检测 退出状态 线程自己可以通过 xwos_cthd_shld_stop() 检测 退出状态 。 可以作为线程循环的结束条件：\nxwer_t thd_func(void * arg) { while (!xwos_cthd_shld_stop()) { /* ...thread loop... */ ; } } 线程自身的睡眠 XWOS内核提供多种线程睡眠方式：\nxwos_cthd_sleep() ：睡眠的时间的起点由此CAPI自己获取，这种方式只需告诉CAPI需要睡眠多少事件，使用简单，但精度较低。 xwos_cthd_sleep_to() ：指定未来的某个时间点被唤醒，精度较高。 xwos_cthd_sleep_from()：睡眠时间的起点和持续时间由调用者提供，时间起点可以是 过去 的时间点。 如果线程只是想让调度器在同优先级的就绪队列中重新调度一下，可以通过调用 xwos_cthd_sleep() 。\n线程的冻结与解冻 线程自身冻结 线程的冻结，是用来支持内核的一些特殊功能的，用户不能随意冻结线程。 在以下情况，XWOS内核要求线程进入冻结状态：\n系统准备进入低功耗模式。如果此时线程还在运行，很有可能因其正在访问硬件资源、 占用锁，导致系统关闭硬件、清理资源时发生异常。因此线程需要运行到一个特殊的点后冻结，这个点就是 冻结点 。 线程进入冻结点前，需要返回到最外层的主函数中，并释放掉所有的锁和硬件资源。 线程迁移至另一个CPU。线程迁移时，也需要返回至最外层的冻结点，保证不能占用当前CPU的任何资源。 线程可以通过 xwos_cthd_shld_frz() 检测 可被冻结 状态。 一旦检测到 可被冻结 状态，就需要调用 xwos_cthd_freeze() 冻结自己。\n示例：\nxwer_t thd_func(void * arg) { /* ...省略... */ while (!xwos_cthd_shld_stop()) { /* 判断线程是否需要退出 */ rc = do_sth(/* ... */); /* 线程在内部阻塞在某个同步对象或锁上 */ if (-EINTR == rc) { /* 当线程需要冻结，阻塞/睡眠将被中断会以-EINTR返回 */ if (xwos_cthd_shld_frz()) { /* 判断是否需要冻结 */ release_resource(); /* 释放资源... */ xwos_cthd_freeze(); /* 冻结 */ /* 线程解冻后，从这里继续执行。*/ /* 如果线程发生了迁移，线程在另一个CPU上也是从此处开始运行。*/ acquire_resource(); /* 重新获取资源... */ } else { /* 处理其他原因导致的中断... */ } } } /* ...省略... */ } 如果线程冻结之前不需要释放任何资源，可以使用 xwos_cthd_frz_shld_stop() 。 此CAPI等价于 xwos_cthd_shld_frz() + xwos_cthd_freeze() + xwos_cthd_shld_stop()\n线程循环：\nxwer_t thd_func(void * arg) { bool wasfrz; /* ...省略... */ while (!xwos_cthd_frz_shld_stop(\u0026wasfrz)) { /* 通过wasfrz可以获知线程是否被冻结过 */ /* ...线程循环... */; } /* ...省略... */ } 解冻 线程的解冻不由用户来操作，系统完成特殊功能后会自动对线程进行解冻：\n系统退出低功耗模式时 线程迁移操作已经完成 线程的迁移 在多核系统中，XWOS的线程只会在某个CPU上被调度，XWOS内核并不会自动对线程做均衡处理，但支持将线程迁移到另一个CPU上。\n迁移流程 假定条件：线程正在CPU-A上，准备迁移到CPU-B上 流程： 用户在任意CPU的任意上下文调用CAPI： xwos_thd_migrate() ； 系统向CPU-A发送调度器服务中断，提出 迁移出 的申请； CPU-A切换至调度器服务中断，向线程设置冻结标志，并中断线程的阻塞态和睡眠态，然后退出中断上下文； CPU-A中线程被重新调度，并运行到冻结点； 线程在冻结点向CPU-A发送调度器服务中断，执行 冻结 操作； 线程冻结后，CPU-A向CPU-B申请调度器服务中断，提出 迁移进 的申请； CPU-B切换至调度器服务中断，把线程加入到自己的调度器中，解除线程的冻结状态，并加入就绪列表中； 迁移完成，线程开始在CPU-B中调度。 线程的本地存储 C11 标准之后引入线程本地存储(TLS)，XWOS支持关键字 _Thread_local ( C99 )、 thread_local ( C2X ) ， 以及 gcc 以及 clang 编译器扩展的关键字 __thread 。\n如果使用 C99 以前的标准，用户可以通过：\nxwos_cthd_set_data() ：设置线程自身私有变量 xwos_cthd_get_data() ：获取线程自身私有变量 xwos_thd_set_data() ：设置任意线程私有变量 xwos_thd_get_data() ：获取任意线程私有变量 线程对象的生命周期管理 线程对象的基类是 XWOS对象 struct xwos_object 。 线程对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_thd_grab() ：增加引用计数。 xwos_thd_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_thd_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_thd_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwos/osal/thd.h\u003e ","categories":["XWOS"],"description":"XWOS的线程\n","excerpt":"XWOS的线程\n","ref":"/docs/TechRefManual/Thd/","tags":"","title":"线程"},{"body":"概述 软件定时器是基于调度器的滴答定时器任务实现的，因此时间精度最小为滴答定时器的中断频率。 软件定时器可以是 单次 的，也可以是 周期 的。\n软件定时器对象与对象描述符描述符 软件定时器对象是 XWOS对象 struct xwos_object 的派生类 。 类似的，软件定时器对象也用 软件定时器对象描述符 xwos_swt_d 来解决有效性和身份合法性的问题。\n软件定时器对象描述符由 软件定时器对象的指针 和 标签 组成：\ntypedef struct { struct xwos_swt * swt; /**\u003c 软件定时器对象的指针 */ xwsq_t tik; /**\u003c 标签 */ } xwos_swt_d; 通过对象描述符引用对象时，首先检测 obj-\u003emagic 的值，是否为 0x58574F53U ，由此可确定指针 obj 指向一个有效的 XWOS的对象 。 然后对比标签 obj-\u003etik 和 tik 是否相等，由此可以确定对象的 身份 。 因为对象的 tik 是全局唯一的，当对象被释放后，它的 tik 会被析构函数析构为 0 。 当内存地址被重新构建为新的对象，那么它的 tik 一定与对象描述符的 tik 不一致。\n软件定时器的初始化、销毁与动态创建、删除 静态初始化、销毁 静态初始化： xwos_swt_init() 静态 是指用户预先定义线程结构体对象，这些对象在编译期由编译器分配内存。 销毁静态初始化的软件定时器： xwos_swt_fini() 动态创建、删除 动态创建： xwos_swt_create() 动态 是指程序在运行时，通过内存分配函数申请内存，并在申请的内存上构造对象。 删除动态创建的软件定时器： xwos_swt_delete() 软件定时器的标志 软件定时器在初始化或创建时，需要指定 标志 ：\nXWOS_SWT_FLAG_NULL ：无任何标志，占位符，也表示定时器为单次的。 XWOS_SWT_FLAG_RESTART ：定时器为周期性的，即超时后自动重新开始。 启动软件定时器 软件定时器初始化或创建完成后，可以使用 xwos_swt_start() 启动。\n启动时，需要指定开始的时间起点，周期，以及回调函数 xwos_swt_f 。\n软件定时器的回调函数 软件定时器超时后，其回调函数 xwos_swt_f 会被调用。其原型被定义为：\ntypedef void(* xwos_swt_f) (struct xwos_swt *, void *) 其中第一个参数是软件定时器自己的指针，第二个参数是在 xwos_swt_start() 指定的回调函数的参数。\n软件定时器的回调函数运行在滴答定时器任务中：\n当开启中断底半部时，软件定时器的回调函数运行在中断底半部中； 当关闭中断底半部时，软件定时器的回调函数运行在中断上下文中。 无论是运行在中断底半部还是中断上下文，软件定时器的回调函数都 不 可使用任何会导致睡眠、阻塞的API。\n停止软件定时器 用户可以通过 xwos_swt_stop() 停止已经启动的软件定时器。\n对于未启动的软件定时器，此函数 xwos_swt_stop() 只会返回错误码， 不会产生任何破坏性的影响。\n软件定时器对象的生命周期管理 软件定时器对象的基类是 XWOS对象 struct xwos_object 。 软件定时器对象也有两组生命周期管理的CAPI：\n使用 对象指针 访问生命周期管理的CAPI：需要确保调用CAPI时，对象一定是有效的，且不存在 释放-又被申请 为另一个对象的情况。\nxwos_swt_grab() ：增加引用计数。 xwos_swt_put() ：减少引用计数，当引用计数减少为 0 时，调用垃圾回收函数释放对象。 使用 对象描述符 访问生命周期管理的CAPI：用户无法确保对象一定有效或无法确保对象不会变成另一个对象时使用。\nxwos_swt_acquire() ：通过对象描述符确定对象有效且合法，再增加引用计数。 xwos_swt_release() ：通过对象描述符确定对象有效且合法，再减少引用计数。 当引用计数减少为 0 时，调用垃圾回收函数释放对象。 CAPI参考 头文件 \u003cxwos/osal/swt.h\u003e ","categories":["XWOS"],"description":"XWOS的软件定时器\n","excerpt":"XWOS的软件定时器\n","ref":"/docs/TechRefManual/Swt/","tags":"","title":"软件定时器"},{"body":"临界区管理 临界区是指访问共用资源的程序片段，传统RTOS中，通常使用以下几种方式保护临界区资源：\n使用协作式内核：线程（任务）不主动放弃CPU不会发生调度，因此共享的资源在 线程（任务）中访问都是安全的。 关闭抢占：可用于保护被多个线程（任务）共享的资源。 关闭中断：可用于保护线程与线程、线程与中断共享的资源。 互斥锁：可用于保护被多个线程（任务）共享的资源。 XWOS内核是假定系统为MP来设计的（UP可以视为MP的特例）， 因此在进入临界区的方式与传统RTOS有些区别：\n关闭抢占：使用自旋锁或其派生锁的lock与unlock形式的API； 关闭CPU总中断：使用自旋锁或其派生锁的lock_cpuirq与unlock_cpuirq形式的API。 若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用lock_cpuirqsv与unlock_cpuirqrs 形式的API来保存与恢复CPU总中断开关标志，防止内层锁解锁时意外地把CPU总中断打开； 关闭部分中断：使用自旋锁或其派生锁的lock_irqs与unlock_irqs形式的API， 若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用lock_irqssv与unlock_irqsrs 形式的API来保存与恢复部分中断开关标志，防止内层锁解锁时意外地把这些中断打开； 关闭中断底半部：使用自旋锁或其派生锁的lock_bh与unlock_bh形式的API； 互斥锁：只能用于保护被多个线程共享的资源； 原子操作：XWOS中提供原子操作的函数库xwos/lib/xwaop.h，并抽象了std:atomic类似的内存模型。 ","categories":["XWOS"],"description":"XWOS的锁\n","excerpt":"XWOS的锁\n","ref":"/docs/TechRefManual/Lock/","tags":"","title":"锁"},{"body":"XWOS提供多种同步机制，它们统一称为同步对象：\n信号量 条件量 事件标志 线程栅栏 信号选择器 信号量与条件量是操作系统最基本的两种同步机制， 其他复杂的同步机制都可基于这两种同步机制实现。\n","categories":["XWOS"],"description":"XWOS的同步\n","excerpt":"XWOS的同步\n","ref":"/docs/TechRefManual/Sync/","tags":"","title":"同步"},{"body":"XWOS提供四种内存管理的算法。\n简单内存分配器 简单内存分配器只分配大小最适应内存块，不对内存进行回收。\n优点： 简单，代码量非常小； 运行时间稳定。 缺点：内存一旦分配出去不再回收，释放函数只是一个 Dummy 函数； 适用性：简单的RTOS应用场合或不需要回收内存的场合 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。 CAPI参考： 头文件 \u003cxwos/mm/sma.h\u003e 内存切片分配器 内存切片分配器将内存切割成等量的块，就像 卡片 一样，然后将它们连接在一起形成队列， 每次分配时取一块内存，回收时再把内存切片放回到队列中。\n优点： 简单，代码量较小； 支持释放操作； 申请与释放操作的运行时间是稳定的； 反复申请与释放不会造成内存碎片。 缺点： 内存块大小固定，如果要求的内存过小，会造成内存浪费； 如果要求的内存超过内存块的大小，无法满足需求； 连续申请的两块内存不能保证是连续的。 适用性：对时间稳定性要求高的RTOS应用场合。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。 CAPI参考： 头文件 \u003cxwos/mm/memslice.h\u003e 伙伴算法分配器 伙伴算法分配器在分配时，会将内存不断地二等分，直到切割到能满足要求的最小内存大小为止。 释放时会检查与之相邻并等长的内存块（称为伙伴）是否也空闲， 如果是，就和“伙伴”合并成更大的内存块， 然后继续检测合并后的内存块是否也存在可以合并的伙伴，一直向上合并到不能合并为止。\n优点： 支持释放操作； 支持大小不固定的内存申请操作； 反复申请与释放不会造成内存碎片。 缺点： 代码稍微复杂； 因为存在合并与切割的循环，申请与释放操作的所需要的时间不是特别稳定； 内存大小固定为2的指数，如果申请的内存过小，会造成内存浪费。 适用性：对内存复用性要求高的应用场合。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。 CAPI参考： 头文件 \u003cxwos/mm/bma.h\u003e 内存池 内存池是结合了内存切片分配器与伙伴算法分配器的算法。内存管理的基本单位为页， 一页内存为4096字节，页内存使用伙伴算法分配器管理。 内存池还使用对象缓存算法建立各种小尺寸的块：8字节、16字节、32字节、 64字节、96字节、128字节、160字节、192字节、256字节、320字节、384字节、 512字节、768字节、1024字节、2048字节。 当申请内存大于2048字节，直接分配页内存；当申请的内存小于等于2048字节， 就从尺寸最合适的对象缓存分配器中分配一块内存。\n优点： 支持释放操作； 支持大小不固定的内存申请操作； 反复申请与释放不会造成内存碎片； 小内存块不会浪费过多的内存。 缺点： 代码复杂； 申请与释放操作的所需要的时间不稳定。 适用性：外接尺寸较大的SRAM或SDRAM的内存管理，C++和Lua虚拟机的对象池。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。 CAPI参考： 头文件 \u003cxwos/mm/mempool.h\u003e ","categories":["XWOS"],"description":"XWOS的内存管理\n","excerpt":"XWOS的内存管理\n","ref":"/docs/TechRefManual/Mm/","tags":"","title":"内存管理"},{"body":"概述 XWOS有两套电源管理框架，分别用于MP系统和UP系统。\nXWOS的电源管理框架只提供了基本流程，最终SOC如何休眠由BSP中的回调函数实现： 用户可以自行决定是否保持SDRAM的刷新、是否保持某些GPIO的输出、或则是否进入最低功耗的待机等等。\nMP系统的电源管理 电源管理领域 MP系统中，CPU不唯一，XWOS中使用 电源管理领域(PMDM) 来统一管理所有CPU的休眠与唤醒。\n流程 MP系统电源管理流程 Photo: xwos.tech / CC-BY-SA-4.0\n图中，左列为休眠流程，右列为唤醒流程，箭头代表了可以进行 电源管理阶段 转换的方向。 电源管理领域 将电源管理分为四个阶段（图中绿色的框）：\n正在运行 ( XWMP_PMDM_STAGE_RUNNING ) 所有CPU正常运行，可以使用下面CAPI进入休眠的流程：\nxwer_t xwos_pm_suspend(void); 此CAPI是操作系统抽象层 OSAL 中的CAPI，实际调用的是：\nxwer_t xwmp_pmdm_suspend(void); 冻结调度器 —— 解冻调度器 ( XWMP_PMDM_STAGE_FREEZING - XWMP_PMDM_STAGE_THAWING ) 一旦开始休眠流程，PMDM会通知所有CPU冻结线程。当调度器中线程全部冻结后，调度器会向PMDM报告 已经暂停 的状态。 调度器冻结线程的过程是一个比较复杂的过程，这个阶段又分为几个子阶段（图中蓝色的框）：\n冻结线程 —— 解冻线程 ( XWMP_SKD_WKLKCNT_FREEZING - XWMP_SKD_WKLKCNT_THAWING ) 调度器会中断所有线程的 等待 和 睡眠 态，并为所有线程设置 可冻结 标志， 然后依次调度每个线程，直到它们运行到 冻结点 进行冻结，这个过程耗时比较长， 在执行过程中如果遇到唤醒事件，调度器会在唤醒事件中断中切换为解冻流程： 解冻已经冻结的线程，并取消未冻结的线程的 可冻结 标志。\n全部线程已经冻结 ( XWMP_SKD_WKLKCNT_ALLFRZ ) 最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。 如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断。 休眠流程切换为唤醒流程，并重新打开滴答定时器。 按照 调度器的中断 中的约束，唤醒事件中断的优先级低于调度器服务中断， 因此唤醒事件中断一定会在调度器服务中断退出后才开始执行， 滴答定时器一定会先关闭，然后再打开，顺序不会错乱。\n调度器已经暂停 ( XWMP_SKD_WKLKCNT_SUSPENDED ) CPU从上一步骤的调度器服务中断中退出后，会切换回线程上下文，此时因所有线程已经冻结， CPU只可能运行在 空闲任务 中。 CPU会在空闲任务中向PMDM报告调度器 已经暂停 的状态。此过程不能在调度器服务中断中进行， 因为调度器服务中断是最高优先级中断，不能被唤醒事件中断打断，有可能会导致无法唤醒的问题。\n正在暂停 —— 正在恢复 ( XWMP_PMDM_STAGE_SUSPENDING - XWMP_PMDM_STAGE_RESUMING ) 当最后一个CPU报告了 已经暂停 的状态后，会在最后一个CPU的 空闲任务 中执行用户的 suspend() 回调函数。 此时，如果出现唤醒事件，电源管理的阶段会从 正在暂停 切换为 正在恢复 ，并执行用户的 resume() 回调函数。\nsuspend() 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等； resume() 回调函数用于在唤醒之前执行与 suspend() 回调函数相反的操作； 执行这两个函数时，PMDM会自动锁定 resume-suspend锁 ，并关闭当前CPU的总中断开关。 resume-suspend锁 是自旋锁，如果CPU-1正在执行 suspend() 回调函数，此时出现了唤醒事件，会分下面两种情况进行处理： 唤醒事件中断也绑定在CPU-1上，唤醒事件中断会挂起，直到 suspend() 回调函数返回， PMDM解锁 resume-suspend锁 并打开CPU总中断开关，才被处理，然后执行 resume() 回调函数； 唤醒事件中断绑定在CPU-2上，CPU-2会立即进入唤醒事件中断，但一直会 自旋 等待CPU-1释放 resume-suspend锁 ， 直到获得 resume-suspend锁 后，才会执行 resume() 回调函数； 示例WeActMiniStm32H750的 resume() 与 suspend() 回调函数： /* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */ void stm32cube_pm_resume(void) { ... /* 恢复stm32cube中的所有设备 */ xwds_pm_resume(\u0026stm32cube_ds); } void stm32cube_pm_suspend(void) { ... /* 暂停stm32cube： + 暂停所有设备 + 配置GPIO */ xwds_pm_suspend(\u0026stm32cube_ds); /* 设置休眠方式为STOP模式： STOP模式下寄存器与内部RAM数据不丢失， 因此休眠方式为SuspendToRAM，唤醒后运行状态可恢复。*/ LL_PWR_SetRegulModeDS(LL_PWR_REGU_DSMODE_LOW_POWER); LL_PWR_EnableFlashPowerDown(); LL_PWR_CPU_SetD1PowerMode(LL_PWR_CPU_MODE_D1STOP); LL_PWR_CPU_SetD2PowerMode(LL_PWR_CPU_MODE_D2STOP); LL_PWR_CPU_SetD3PowerMode(LL_PWR_CPU_MODE_D3STOP); LL_LPM_EnableDeepSleep(); /* 设置ARMv7-m的DEEPSLEEP位 */ LL_LPM_EnableDeepSleep(); } 已经暂停 ( XWMP_PMDM_STAGE_SUSPENDED ) 此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：\nsleep() ：休眠SOC wakeup() ：唤醒SOC 当最后一个CPU的 空闲任务 执行完上一阶段的 suspend() 回调函数后， PMDM将电源管理步骤切换到此阶段，并执行 sleep() 回调函数。 SOC系统在 sleep() 回调函数内部进入低功耗状态， 此时时钟停止，代码停止运行， sleep() 回调函数不会返回。\nXWOS将 sleep() 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。 例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ WFI ），低优先级的唤醒中断无法把系统唤醒。\n当唤醒事件出现， wakeup() 回调函数在唤醒事件中断中执行。\n回调函数 sleep() 与 wakeup() 之间没有锁的保护， 因此 sleep() 回调函数需要设计成能被 wakeup() 回调函数打断。\n示例，WeActMiniStm32H750的 wakeup() 与 sleep() 回调函数：\n/* XWOS/xwbd/WeActMiniStm32H750/bm/xwac/xwds/pm.c */ void stm32cube_pm_wakeup(void) { LL_LPM_EnableSleep(); /* 清除DEEPSLEEP位 */ SystemClock_Config(); /* 从STOP模式恢复后，需要重新配置时钟 */ } void stm32cube_pm_sleep(void) { /* 位置1 */ cm_wfi(); /* 位置2 */ } 分为两种情况讨论：\nstm32cube_pm_sleep() 中的 WFI 指令执行后出现唤醒事件： 唤醒流程执行完毕后，代码会回到 stm32cube_pm_sleep() 中 位置2 ； stm32cube_pm_sleep() 中的 WFI 指令执行之前出现唤醒事件： 唤醒事件中断会打断 stm32cube_pm_sleep() 函数， 然后执行 stm32cube_pm_wakeup() 函数， 函数 LL_LPM_EnableSleep() 会清除ARMv7-m的DEEPSLEEP位，接下来的唤醒流程也会将滴答定时器重新打开， 当再次回到 stm32cube_pm_sleep() 的 位置1 时， WFI 指令只会使CPU进入ARMv7-m的SLEEP模式， 只是短暂地暂停了一下CPU时钟，即将到来的滴答定时器中断可使系统恢复正常。 UP内核的电源管理 流程 UP系统电源管理流程 Photo: xwos.tech / CC-BY-SA-4.0\n图中，左列为休眠流程，右列为唤醒流程，箭头代表了 电源管理阶段 切换的方向。 UP系统电源管理分为五个阶段：\n正在运行 ( XWUP_PM_STAGE_RUNNING ) 调度器正常运行，可以使用下面CAPI进入休眠的流程：\nxwer_t xwup_skd_suspend(void); 正在冻结线程 —— 正在解冻线程 ( XWUP_PM_STAGE_FREEZING - XWUP_PM_STAGE_THAWING ) 一旦开始休眠流程，调度器会中断所有线程的 等待 和 睡眠 态，并通知所有线程冻结。这个过程耗时比较长， 在执行过程中如果遇到唤醒事件，调度器可在唤醒事件中断中切换为解冻流程：解冻已冻结的线程，并将调度器状态逐步恢复至 正在运行 。\n调度器中全部线程已经冻结 ( XWUP_PM_STAGE_ALLFRZ ) 最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。 如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断， 休眠流程切换为唤醒流程，并重新打开滴答定时器。 按照 调度器的中断 中的约束，唤醒事件中断的优先级低于调度器服务中断， 因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，滴答定时器一定会先关闭，然后再打开，顺序不会错乱。\n正在暂停 —— 正在恢复 ( XWUP_PM_STAGE_SUSPENDING - XWUP_PM_STAGE_RESUMING ) 当全部线程冻结后，调度器只能调度 空闲任务 ，调度器会在 空闲任务 中执行用户的 suspend() 回调函数。 此时，如果出现唤醒事件，系统会在唤醒事件中断中将状态从 正在暂停 切换为 正在恢复 ，并执行用户的 resume() 回调函数。\nsuspend() 回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等； resume() 回调函数用于在唤醒之前执行与 suspend() 回调函数相反的操作； 执行这两个函数时系统会关闭CPU总中断开关。如果正在执行 suspend() 回调函数时出现了唤醒事件， 唤醒事件中断会挂起，直到 suspend() 回调函数，系统打开CPU总中断开关时才被处理，然后执行 resume() 回调函数； 已经暂停 ( XWUP_PM_STAGE_SUSPENDED ) 此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。此阶段提供给用户的回调函数：\nsleep() ：休眠SOC wakeup() ：唤醒SOC 当 空闲任务 执行完上一阶段的 suspend() 回调函数后，电源管理步骤切换到此阶段，并执行 sleep() 回调函数。 SOC系统在 sleep() 回调函数内部进入休眠状态，此时时钟停止，代码停止运行， sleep() 回调函数不会返回。\nXWOS将 sleep() 回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能导致系统无法唤醒。 例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了休眠指令（ WFI ），低优先级的唤醒中断无法把系统唤醒。\n当唤醒事件出现， wakeup() 回调函数在唤醒事件中断中执行。\n回调函数 sleep() 与 wakeup() 之间没有锁的保护， 因此 sleep() 回调函数需要设计成能被 wakeup() 回调函数打断。\nCAPI参考 头文件 \u003cxwos/osal/pm.h\u003e ","categories":["XWOS"],"description":"XWOS的电源管理\n","excerpt":"XWOS的电源管理\n","ref":"/docs/TechRefManual/Pm/","tags":"","title":"电源管理"},{"body":"","categories":["XWOS"],"description":"XWOS基本C函数库\n","excerpt":"XWOS基本C函数库\n","ref":"/docs/TechRefManual/Xwlib/","tags":"","title":"通用库"},{"body":"","categories":["XWOS"],"description":"XWOS的通讯机制\n","excerpt":"XWOS的通讯机制\n","ref":"/docs/TechRefManual/Isc/","tags":"","title":"系统间通讯机制"},{"body":"","categories":["XWOS"],"description":"XWOS的C/C++标准库\n","excerpt":"XWOS的C/C++标准库\n","ref":"/docs/TechRefManual/C_C++/","tags":"","title":"C/C++"},{"body":"现代的MCU已经有足够的性能运行解释型语言。XWOS集成了Lua语言 —— 一种轻量小巧的脚本语言。 Lua语言在XWOS中的移植被称为 XWLUA ， XWLUA 有以下特性：\n交互式解释器：一个独立的线程，用户通过串口终端，可在线运行Lua语言的函数，也可运行文件系统中的脚本； 多线程：Lua语言并不支持多线程，XWLUA扩展了Lua语言，实现了多线程的功能； 锁机制：支持互斥锁、自旋锁、顺序锁； 同步机制：支持信号量、条件量、事件标志、信号选择器、线程栅栏； 驱动库：已经完成部分驱动的封装。 GPIO I2C SPI UART XWLUA交互式解释器 运行Lua虚拟机需要有足够的内存和浮点运算单元，因此只能在资源比较丰富的MCU上开启Lua语言， XWOS自带的参考工程中，以下工程开启了Lua语言：\nEmbedFireStm32H743XWOS：野火STM32H743-Pro开发板 AtkApolloH743XWOS：正点原子阿波罗STM32H743开发板 FK429M1XWOS：反客STM32F429-M1开发板 WeActMiniStm32H750XWOS：微行电子MiniStm32H750开发板 工程结构 工程路径： xwem/vm/lua 目录结构 src ：lua的官方源码 xwlua ：xwlua的实现 port.h, port.c, prefix.h, readline.c ：Lua语言在XWOS上的移植代码 lua.c ：以XWOS线程方式运行的交互式解释器(REPL) xwvm ：虚拟机库：虚拟机之间的数据交换 xwos ：XWOS内核的binding库：包括线程、信号量、条件量、事件标志、信号选择器、线程栅栏、互斥锁、自旋锁、顺序锁、电源管理 xwlib ：XWOS基本C函数的binding库 xwds ：玄武设备栈的binding库 xwxt ：多线程共享数据的全局导出表 mif.h, mif.c ：玄武模块的启动接口，交互式解释器(REPL)线程在此处启动 xwmo.mk ：玄武模块的编译规则 XWLUA的扩展 多线程 原生的Lua语言不支持多线程（Lua中的类型 thread 并不是真正的线程，而是协程。），脚本中的全局变量只能由执行脚本的线程自身访问。 XWLUA在C语言层面开发了多线程的功能，每个线程都拥有一个 独立的Lua虚拟机 。\n全局导出表 为了实现多线程共享数据，XWLUA中实现了一个 全局导出表(xwxt) ，全局导出表中的数据对所有线程可见，并且是线程安全的。 全局导出表也是Lua中的一个独立的虚拟机。\n新的Metamethod：__copy 元方法 __copy() 用于将用户数据从一个虚拟机（全局导出表、线程） 深拷贝 到另一个虚拟机（线程、全局导出表）中。 只有 userdata 可以定义 __copy() 元方法。\n元方法 __copy() 有两个参数，第一个参数是 数据 ，第二参数是 目的虚拟机 ，无返回值。 元方法 __copy() 运行在 保护模式 ，可以 抛出错误 。\n实现元方法 __copy() 时，若拷贝失败，应该在 目的虚拟机 中压入一个 nil 。\nXWLUA的对象都提供了元方法 __copy() 。\n对象强指针 XWLUA使用 对象强指针 管理XWOS内核中的对象（线程、信号量、条件量、事件标志、信号选择器、线程栅栏、互斥锁、自旋锁、顺序锁）。 对象强指针 是一种 userdata 。 对象强指针 就是对XWOS中的 对象描述符 的封装。 再借助于Lua虚拟机的GC机制，可实现对象的生命周期自动管理：\nLua虚拟机每引用一个 对象强指针 ，都会增加相关联对象的引用计数； Lua虚拟机每 “GC” 一个 对象强指针 ，都会减少相关联对象的引用计数； 当相关联对象的引用计数为 0 时，就会执行C语言层面对象的 GC 函数 。 对象强指针 的概念源于Lua语言的 强引用 。\nLuaAPI参考手册 ","categories":["XWLUA"],"description":"XWLUA的说明\n","excerpt":"XWLUA的说明\n","ref":"/docs/TechRefManual/Lua/","tags":"","title":"Lua语言"},{"body":"RustAPI参考手册 ","categories":["XWRUST"],"description":"","excerpt":"RustAPI参考手册 ","ref":"/docs/TechRefManual/Rust/","tags":"","title":"Rust语言"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/Note/Newlib/","tags":"","title":"Newlib"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/Note/Picolibc/","tags":"","title":"Picolibc"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/Note/Lua/","tags":"","title":"Lua开发笔记"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/Note/Rust/","tags":"","title":"Rust开发笔记"},{"body":"概述 XWOS的代码，大致遵循 MISRA-C:2012 规范进行编写，但有些 MISRA-C:2012 的规则不利于 编写操作系统，XWOS的代码趋向于选择更优的性能以及尝试使用更新的语言特性。\n本文将详细描述 MISRA-C:2012 检查的方法，以及 MISRA-C:2012 规范的符合程度。\nMISRA-C:2012 规范的检查方法 使用 cppcheck 工具的 misra 插件。\ncppcheck -I. -I$(XWOS_ARCH_DIR) -I$(XWOS_CPU_DIR) -I$(XWOS_SOC_DIR) -I$(XWOS_BRD_DIR) \\ --force --addon=misra --cppcheck-build-dir=$(CPPCHECK_OUT) \\ --template=gcc --inline-suppr --suppressions-list=xwbs/util/cppcheck/misra-c2012-suppressions.txt -i ignore_path src_path MISRA-C:2012 规范的符合程度 全局禁用的规则 uninitvar\n禁用原因：误报。实际上未初始化变量，编译器会当成错误来处理。 misra-c2012-1.4 : Emergent language features shall not be used\n禁用原因：作为一个长期持续维护的项目，XWOS在新版本中会偏向于引入新的语言特性。 misra-c2012-2.3 : A project should not contain unused type declarations\n禁用原因：操作系统作为一个 生态系统 的基本环境，其中定义的类型、宏、函数、符号等可能在各种衍生项目中被用到。 misra-c2012-2.4 : A project should not contain unused tag declarations\n禁用原因：操作系统作为一个 生态系统 的基本环境，其中定义的类型、宏、函数、符号等可能在各种衍生项目中被用到。 misra-c2012-2.5 : A project should not contain unused macro declarations\n禁用原因：操作系统作为一个 生态系统 的基本环境，其中定义的类型、宏、函数、符号等可能在各种衍生项目中被用到。 misra-c2012-3.1 : The character sequences /* and // shall not be used within a comment\n禁用原因：XWOS内使用doxygen来抓取注释生成文档，文档中如果出现URL，必然会出现 // ，例如 https://... ，除此种情况，禁止在注释中出现 // 。 misra-c2012-5.9 : Identifiers that define objects or functions with internal linkage should be unique\n禁用原因：包含 static inline 内联函数的头文件多处使用时，内联函数被认为重复定义。 misra-c2012-8.7 : Functions and objects should not be defined with external linkage if they are referenced in only one translation unit\n禁用原因：XWOS提供的API并不一定被自己使用，对于 MISRA-C2012 规范的检查工具，可能会因为只检查到一次符号而报错。 misra-c2012-8.9 : An object should be defined at block scope if its identifier only appears in a single function\n禁用原因：有些数据定义为全局，是为了链接时放在特定的段。 misra-c2012-11.3 : A cast shall not be performed between a pointer to object type and a pointer to a diﬀerent object type\n禁用原因 XWOS中各类型的原子操作和位操作是根据位宽转换为8位、16位、32位、64位基本类型来实现的； 动态内存管理； C语言面向对象。 misra-c2012-11.4 : A conversion should not be performed between a pointer to object and an integer type\n禁用原因 在指令和寄存器级别的代码； xwcc_derof() 宏的实现； 动态内存管理； C语言面向对象。 misra-c2012-11.5 : A conversion should not be performed from pointer to void into pointer to object\n禁用原因 动态内存管理； 通讯协议协议的变长消息； 回调函数的用户参数是个泛型指针。 misra-c2012-11.6 : A cast shall not be performed between pointer to void and an arithmetic type\n禁用原因 XWOS将 -1 至 -4095 的指针值当作错误码指针。但是指针是一个无符号整数。 因此是以补码形式表示。 -1 即 0xFFFFFFFF ， -4095 即 0xFFFFF001 。 动态内存管理。 misra-c2012-15.1 : The goto statement should not be used\n禁用原因：XWOS只在下面两种情况下使用 goto 。 XWOS内某些比较核心的算法（例如红黑树），会使用 goto 来提高效率。 1.1. 因为这类代码在整个内核中被大量使用，效率是优先考虑的重点； 1.2. 这类代码被验证得最充分，稳定性与安全性最高。 XWOS使用 goto 来处理出错时的代码返回。 2.1. 如果代码中包含了大量的操作，每个操作都有返回值，若使用 if...else... 将使得嵌套特别深。使用 goto 能使得代码更美观易读； 2.2. 如果代码中包含了大量的操作，每个操作都有对应的反操作，操作与反操作需要像 “栈” 结构一样先进后出，使用 if...else... 很容易 遗漏反操作或将反操作的顺序搞错，但使用 goto 就可完美解决这一问题。 /* 如果包含大量操作，使用 `if...else...` 将使得代码行过长， * 并且anti_operationX() 很容易写错位置或者遗漏。 */ int func1(void) { rc = operation1(); if (0 == rc) { rc = operation3(); if (0 == rc) { rc = operation8(); if (0 == rc) { rc = operation2(); if (0 == rc) { rc = operation6(); if (0 == rc) { rc = operation5(); if (0 == rc) { } else { anti_operation6(); } } else { anti_operation2(); } } else { anti_operation8(); } } else { anti_operation3(); } } else { anti_operation1(); } } else { } return rc; } /* 使用 `goto` 将避免 `if...else...` 上述的两个问题。*/ int func2(void) { rc = operation1(); if (rc \u003c 0) { goto err_operation1; } rc = operation3(); if (rc \u003c 0) { goto err_operation3; } rc = operation8(); if (rc \u003c 0) { goto err_operation8; } rc = operation2(); if (rc \u003c 0) { goto err_operation2; } rc = operation6(); if (rc \u003c 0) { goto err_operation6; } rc = operation5(); if (rc \u003c 0) { goto err_operation5; } return rc; anti_operation5(); err_operation5: anti_operation6(); err_operation6: anti_operation2(); err_operation2: anti_operation8(); err_operation8: anti_operation3(); err_operation3: anti_operation1(); err_operation1: return rc; } misra-c2012-17.1 : The features of \u003cstdarg.h\u003e shall not be used\n禁用原因：不应该完全禁止语言特性。 misra-c2012-18.8 : Variable-length array types shall not be used\n禁用原因：变长数组是C99标准引入的特性，XWOS在新版本中会偏向于引入新的语言特性。 misra-c2012-19.2 : The union keyword should not be used\n禁用原因： 编写操作系统时不可避免地需要将内存地址转换为不同类型的指针，使用 union 可以避免直接对 void * 进行转换，提高可读性。 misra-c2012-20.9 : All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define ’d before evaluation\n禁用原因：检测工具会误报，但XWOS的代码是遵循此规则的。 misra-c2012-21.1 : ** #define and #undef shall not be used on a reserved identifier or reserved macro name**\n禁用原因：C语言将任何以 _ 开头的符号作为保留，但有些符号来自于编译器的扩展语法，例如 __attribute__((x)) ，通常将它们定义为两个 _ 开头的宏来使用， 以显示它们和正常的变量、函数、宏的区别。 misra-c2012-21.3 The memory allocation and deallocation functions of \u003cstdlib.h\u003e shall not be used\n禁用原因：完全禁止动态内存管理不利于引入高级语言。 仅当安全等级非常高时才禁止动态内存管理，相应的一些功能也不可被使用，例如Lua语言。 misra-c2012-21.6 : The Standard Library input/output functions shall not be used\n禁用原因： stdio.h 的函数在XWOS内被重新定义过。 misra-c2012-21.10 : The Standard Library time and date functions shall not be used\n禁用原因： time.h 的函数在XWOS内被重新定义过。 部分文件禁用的规则 misra-c2012-2.7 : There should be no unused parameters in functions\n禁用原因：此头文件中包含CPU架构指令级别的函数，这些函数使用内联汇编语法编写， 在C语法层面看起来有些参数未使用，实际上这些参数是根据 EABI 规则通过寄存器在使用。 适用范围： xwcd/soc/arm/v6m/armv6m_isa.h xwcd/soc/arm/v7m/armv7m_isa.h xwcd/soc/powerpc/e200x/e200x_isa.h xwcd/soc/riscv/nuclei/riscv_isa.h misra-c2012-5.7 : A tag name shall be a unique identifier\n禁用原因：匿名结构体被认为 tag name 重复是误报。 适用范围： xwcd/soc/arm/v6m/armv6m_isa.h xwcd/soc/arm/v7m/armv7m_isa.h xwcd/soc/powerpc/e200x/e200x_isa.h xwcd/soc/riscv/nuclei/riscv_isa.h xwcd/ds/uart/common.h xwcd/ds/uart/controller.h xwcd/ds/soc/chip.h xwos/lib/xwbop.c xwos/mp/skd.h xwos/up/skd.h xwos/mp/thd.h xwos/up/thd.h xwos/mp/sync/obj.h xwos/up/sync/obj.h xwos/mm/mempool/objcache.h xwos/mm/mempool/page.h xwmd/isc/xwssc/protocol.h xwmd/libc/newlibac/lock.c xwmd/libc/picolibac/lock.c 禁用原因：libc要求定义的符号 适用范围： xwmd/libc/newlibac/lock.c xwmd/libc/picolibac/lock.c misra-c2012-5.8 : A tag name shall be a unique identifier\n禁用原因：结构体内部的成员名是在结构体的namespace内的，不会和外面符号发生冲突。 适用范围： xwmd/isc/xwssc/hwifal.h xwos/mm/mempool/i_allocator.h xwmd/libc/picolibcac/mem.c xwos/mm/mempool/page.h 禁用原因：对LIBC中的标准函数进行重写。 适用范围： xwmd/libc/picolibcac/fops.c misra-c2012-8.4 : A compatible declaration shall be visible when an object or function with external linkage is defined\n禁用原因：误报 适用范围： xwos/ospl/xwosplcb.c 禁用原因：Rust语言的 ffi 不是在C语言层面进行链接。 适用范围： xwmd/xwrust/ffi/*.c misra-c2012-8.5 : An external object or function shall be declared once in one and only one file\n禁用原因： xwos/ospl/soc/*.h 是操作系统移植层的代码，对符号再次定义，起到汇总与强调的作用。提示用户移植时需要提供这些符号的定义。 适用范围： xwos/ospl/soc/*.h xwos/lib/xwbop.h xwos/lib/lfq.h 禁用原因：误报 适用范围 xwmd/libc/newlibac/*.c xwmd/libc/picolibcac/*.c misra-c2012-8.6 : An identifier with external linkage shall have exactly one external definition\n禁用原因：误报 适用范围 xwmd/libc/newlibac/*.c xwmd/libc/picolibcac/*.c misra-c2012-8.14 : The restrict type qualifier shall not be used\n禁用原因：对LIBC中的标准函数进行重写。 适用范围： xwmd/libc/newlibac/string.c xwmd/libc/picolibcac/string.c xwmd/libc/newlibac/time.c xwmd/libc/picolibcac/time.c misra-c2012-9.2 : The initializer for an aggregate or union shall be enclosed in braces\n禁用原因：误报 适用范围： xwmd/libc/newlibac/fops.c xwmd/libc/picolibcac/fops.c misra-c2012-9.3 : Arrays shall not be partially initialized\n禁用原因：误报 适用范围： xwmd/libc/newlibac/fops.c xwmd/libc/picolibcac/fops.c misra-c2012-10.8 : The value of a composite expression shall not be cast to a diﬀerent essential type category or a wider essential type\n禁用原因：宏定义的表达式是复合的表达式，不得不使用强制类型转换 适用范围： xwos/mm/mempool/page.c misra-c2012-11.1 : Conversions shall not be performed between a pointer to a function and any other type\n禁用原因：操作系统抽象层到实现层的必要转换 适用范围： xwos/osal/thd.h xwos/osal/swt.h misra-c2012-12.3 : The comma operator should not be used\n禁用原因：XWOS的链表( xwos/lib/bclst.h )中的迭代操作宏不得不使用逗号表达式来定义。 适用范围： xwos/mp/skd.c xwos/up/skd.c misra-c2012-14.2 : A for loop shall be well-formed\n禁用原因：XWOS的链表( xwos/lib/bclst.h )中的迭代操作过于复杂，使用宏定义来简化代码。 适用范围： xwos/mp/skd.c xwos/up/skd.c misra-c2012-15.2 : The goto statement shall jump to a label declared later in the same function\n禁用原因：这部分代码是XWOS低中断延迟的关键代码，必须优先考虑实时性和性能，因此不得不用 goto 来实现。 适用范围： xwos/mp/tt.c xwos/up/tt.c 禁用原因：误报。 适用范围： xwmd/isc/xwssc/mif.c misra-c2012-15.4 : There should be no more than one break or goto statement used to terminate any iteration statement\n禁用原因：这部分代码是XWOS低中断延迟的关键代码，必须优先考虑实时性和性能，因此不得不用 goto 来实现。 适用范围： xwos/mp/tt.c xwos/up/tt.c 禁用原因：使用率较高的代码只使用一个 break 或 goto 影响效率。 适用范围： xwos/up/skd.c xwos/mp/sync/evt.c xwos/up/sync/evt.c xwmd/isc/xwssc/hwifal.c xwmd/isc/xwssc/protocol.c misra-c2012-15.5 : A function should have a single point of exit at the end\n禁用原因：函数参数检测的代码被定义为一个宏，其中包含了一个 return 。 适用范围： xwmd/isc/xwssc/mif.c misra-c2012-17.2 : Functions shall not call themselves, either directly or indirectly\n禁用原因：这部分代码是XWOS独创的开中断调度技术的关键代码，不得不使用递归函数来实现。此处代码被验证得非常充分，稳定性与安全性不用担心。 适用范围： xwos/mp/skd.c xwos/up/skd.c misra-c2012-17.7 : The value returned by a function having non-void return type shall be used\n禁用原因：C库函数 memset() , memcpy() 等有返回值，但这里并不使用它们。 适用范围： xwos/mp/rtrq.c xwos/up/rtrq.c xwos/mp/sync/evt.c xwos/up/sync/evt.c xwmd/isc/xwcq/xwcq.c xwmd/isc/xwssc/hwifal.c xwmd/isc/xwssc/mif.c xwmd/isc/xwssc/protocol.c xwmd/libc/newlibac/mif.c xwmd/libc/picolibcac/mif.c xwmd/libc/newlibac/mem.c xwmd/libc/picolibcac/mem.c 禁用原因：确定不使用返回值的地方，使用 cppcheck-suppress [misra-c2012-17.7] 标注。 适用范围： xwos/init.c xwos/mp/lock/mtx.c xwos/up/lock/mtx.c xwos/mp/lock/spinlock.c xwos/up/lock/seqlock.c xwmd/isc/xwssc/mif.c xwmd/isc/xwssc/protocol.c xwos/mm/mempool/objcache.c xwos/mm/mempool/allocator.c xwos/mm/mempool/page.c misra-c2012-17.8 : A function parameter should not be modified\n禁用原因：为了追求效率以及内存使用率，不遵循此规则。 适用范围： xwos/lib/xwbop.c xwos/mm/bma.c xwos/mm/mempool/objcache.c xwos/mm/mempool/page.c xwos/mm/mempool/allocator.c xwos/mp/lock/mtx.c xwos/up/lock/mtx.c xwmd/isc/xwssc/protocol.c xwmd/libc/newlibac/string.c xwmd/libc/picolibcac/string.c misra-c2012-20.7 : Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses\n禁用原因：这部分代码使用宏来模拟C++的函数模板，其中作为类型名的参数不能使用括号封闭起来。 适用范围： xwos/lib/xwaop.h xwos/lib/xwbop.h 禁用原因：这部分代码使用宏来定义数组，其中作为数组名参数不能使用括号封闭起来。 适用范围： xwos/mm/bma.h xwos/mm/mempool/allocator.h xwmd/isc/xwssc/mif.h xwmd/isc/xwcq/mif.h misra-c2012-20.10 : The # and ## preprocessor operators should not be used\n禁用原因：这部分代码使用宏来模拟C++的函数模板，必须使用到 # 和 ## 。 适用范围： xwos/lib/xwaop.h xwos/lib/xwbop.h misra-c2012-20.12 : A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators\n禁用原因：这部分代码使用宏来模拟C++的函数模板。 适用范围： xwos/lib/xwaop.h xwos/lib/xwbop.h misra-c2012-21.2 A reserved identifier or macro name shall not be declared\n禁用原因：对LIBC中的标准函数进行重写。 适用范围： xwmd/libc/newlibac/string.c xwmd/libc/picolibcac/string.c xwmd/libc/picolibcac/fops.c xwmd/libc/picolibcac/mem.c misra-c2012-21.4 The standard header file \u003csetjmp.h\u003e shall not be used\n禁用原因：不应该完全禁止语言特性，XWOS对 \u003csetjmp.h\u003e 提供了支持 。 适用范围： xwmd/libc/newlibac/setjmp.c xwmd/libc/picolibcac/setjmp.c ","categories":"","description":"","excerpt":"概述 XWOS的代码，大致遵循 MISRA-C:2012 规范进行编写，但有些 MISRA-C:2012 的规则不利于 编写操作系 …","ref":"/docs/Note/MISRA-C2012/","tags":"","title":"MISRA-C2012"},{"body":"","categories":"","description":"XWOS的开发与使用笔记\n","excerpt":"XWOS的开发与使用笔记\n","ref":"/docs/Note/","tags":"","title":"笔记"},{"body":"","categories":"","description":"XWOS的代码规范\n","excerpt":"XWOS的代码规范\n","ref":"/docs/Standard/","tags":"","title":"规范"},{"body":" XWOS核心代码 XWOS核心代码采用 MPL-2.0 发布； 适用范围： xwos 、 xwmd 文件夹下的源码； XWOS的外围代码 XWOS的外围代码采用 Apache-2.0 发布； 适用范围： xwcd 、 xwbd 、 xwam 、 xwbs 、 xwxr 文件夹下的源码。 第三方软件 适用范围： xwem 文件夹下的源码以及 xwbd 中第三方提供的驱动源码； 免责声明 ： XWOS项目中集成的第三方开源软件仅供参考，用户需自行检查这些软件的缺陷以及 LICENSE ， 并 自行承担相关的缺陷风险及法律风险 。XWOS开发团队 不承担任何法律责任 。 ","categories":"","description":"XWOS的开源协议\n","excerpt":"XWOS的开源协议\n","ref":"/docs/License/","tags":"","title":"开源协议"},{"body":"示例工程 S32K1XWOS：S32K144官方评估板 S32K3XWOS：S32K312官方评估板 ","categories":"","description":"","excerpt":"示例工程 S32K1XWOS：S32K144官方评估板 S32K3XWOS：S32K312官方评估板 ","ref":"/docs/UserManual/Board/S32K/","tags":"","title":"S32K"},{"body":"示例工程 KEA128XWOS：NXP KEA128核心板 ","categories":"","description":"","excerpt":"示例工程 KEA128XWOS：NXP KEA128核心板 ","ref":"/docs/UserManual/Board/KEA/","tags":"","title":"KEA"},{"body":"示例工程 APM32F103CBXWOS：APM32F103CB核心板 ","categories":"","description":"","excerpt":"示例工程 APM32F103CBXWOS：APM32F103CB核心板 ","ref":"/docs/UserManual/Board/APM32/","tags":"","title":"APM32"},{"body":"示例工程 CH32F103C8XWOS：CH32F103CB核心板 ","categories":"","description":"","excerpt":"示例工程 CH32F103C8XWOS：CH32F103CB核心板 ","ref":"/docs/UserManual/Board/CH32/","tags":"","title":"CH32"},{"body":"示例工程 GD32F103CBXWOS：GD32F103CB核心板 GD32F303CCXWOS：GD32F303CC核心板 ","categories":"","description":"","excerpt":"示例工程 GD32F103CBXWOS：GD32F103CB核心板 GD32F303CCXWOS：GD32F303CC核心板 ","ref":"/docs/UserManual/Board/GD32/","tags":"","title":"GD32"},{"body":"示例工程 xwos.tech提供了比较多的示例工程：\nSTM32F072C8XWOS：STM32F072C8最小系统 STM32F103C8XWOS：STM32F103C8最小系统 ATKSTM32F103ZXWOS：正点原子F103核心板 ATKSTM32F407ZXWOS：正点原子F407核心板 EmbedFireStm32H743XWOS：野火STM32H743-Pro开发板 AtkApolloH743XWOS：正点原子阿波罗STM32H743开发板 FK429M1XWOS：反客STM32F429-M1开发板 WeActMiniStm32H750XWOS：微行电子MiniStm32H750开发板 ","categories":"","description":"","excerpt":"示例工程 xwos.tech提供了比较多的示例工程：\nSTM32F072C8XWOS：STM32F072C8 …","ref":"/docs/UserManual/Board/STM32/","tags":"","title":"STM32"},{"body":"示例工程 GD32VF103XWOS：Longan nano开发板 ","categories":"","description":"","excerpt":"示例工程 GD32VF103XWOS：Longan nano开发板 ","ref":"/docs/UserManual/Board/GD32V/","tags":"","title":"GD32V"},{"body":"示例工程 MPC5607BXWOS：MPC5607B核心板 ","categories":"","description":"","excerpt":"示例工程 MPC5607BXWOS：MPC5607B核心板 ","ref":"/docs/UserManual/Board/EPPC/","tags":"","title":"EPPC"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/STM32/","tags":"","title":"STM32"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/STM32/","tags":"","title":"STM32"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/XWLUA/","tags":"","title":"XWLUA"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/XWOS/","tags":"","title":"XWOS"},{"body":" XWOS 玄武实时操作系统\n文档 CAPI LuaAPI RustAPI 码云 github Photo by Alexandre P. Junior from Pexels 玄武操作系统是一款运行在嵌入式微控制器上的通用实时操作系统。\n特性 CPU架构 支持PowerPC、ARM、RISC-V。\n单核/多核 支持单核(UP)与多核(MP)两种内核。\n电源管理 集成电源管理框架，提供休眠/唤醒的基本流程。\n更多 …\n开发平台 Ubuntu Windows 编译系统 集成编译系统，可与其他软件一起构建您的工程。\n更多 …\n编译器 gcc llvm C/C++语言 支持C/C++混合开发。\n更多 …\nLua语言 支持Lua-5.4脚本化开发。\n更多 …\nRust语言 支持Rust开发。\n更多 …\nMISRA-C2012 经过静态代码分析，符合MISRA:C2012标准。\n命名空间 命名前缀，防止与其他软件发生命名冲突。\n微信 邮箱 xwos@xwos.tech\n","categories":"","description":"","excerpt":" XWOS 玄武实时操作系统\n文档 CAPI LuaAPI RustAPI 码云 github Photo by Alexandre P. …","ref":"/","tags":"","title":"XWOS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/XWRUST/","tags":"","title":"XWRUST"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"搜索结果"}]